/*
Package api is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /home/stefan/dev/github.com/openconfig/ygot/genutil/names.go
using the following YANG input files:
	- yang/iana-if-type.yang
	- yang/ietf-inet-types.yang
	- yang/ietf-interfaces.yang
	- yang/ietf-yang-types.yang
	- yang/sonic-auto_techsupport.yang
	- yang/sonic-breakout_cfg.yang
	- yang/sonic-console.yang
	- yang/sonic-dhcp-server.yang
	- yang/sonic-dhcpv6-relay.yang
	- yang/sonic-extension.yang
	- yang/sonic-feature.yang
	- yang/sonic-flex_counter.yang
	- yang/sonic-gnmi.yang
	- yang/sonic-hash.yang
	- yang/sonic-interface.yang
	- yang/sonic-kdump.yang
	- yang/sonic-kubernetes_master.yang
	- yang/sonic-lldp.yang
	- yang/sonic-loopback-interface.yang
	- yang/sonic-lossless-traffic-pattern.yang
	- yang/sonic-macsec.yang
	- yang/sonic-mclag.yang
	- yang/sonic-mgmt_interface.yang
	- yang/sonic-mgmt_port.yang
	- yang/sonic-mgmt_vrf.yang
	- yang/sonic-mux-cable.yang
	- yang/sonic-nat.yang
	- yang/sonic-ntp.yang
	- yang/sonic-nvgre-tunnel.yang
	- yang/sonic-passwh.yang
	- yang/sonic-pbh.yang
	- yang/sonic-peer-switch.yang
	- yang/sonic-port.yang
	- yang/sonic-portchannel.yang
	- yang/sonic-restapi.yang
	- yang/sonic-route-common.yang
	- yang/sonic-route-map.yang
	- yang/sonic-routing-policy-sets.yang
	- yang/sonic-scheduler.yang
	- yang/sonic-sflow.yang
	- yang/sonic-snmp.yang
	- yang/sonic-static-route.yang
	- yang/sonic-storm-control.yang
	- yang/sonic-telemetry.yang
	- yang/sonic-types.yang
	- yang/sonic-versions.yang
	- yang/sonic-vlan-sub-interface.yang
	- yang/sonic-vlan.yang
	- yang/sonic-vrf.yang
	- yang/sonic-vxlan.yang
Imported modules were sourced from:
*/
package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

var (
	SchemaTree map[string]*yang.Entry
	ΛEnumTypes map[string][]reflect.Type
)

func init() {
	var err error
	initΛEnumTypes()
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " +  err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root: &Device{},
		SchemaTree: uzp,
		Unmarshal: Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn )
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// Device represents the /device YANG schema element.
type Device struct {
	SonicAutoTechsupport	*SonicAutoTechsupport_SonicAutoTechsupport	`path:"sonic-auto_techsupport" module:"sonic-auto_techsupport"`
	SonicBreakoutCfg	*SonicBreakoutCfg_SonicBreakoutCfg	`path:"sonic-breakout_cfg" module:"sonic-breakout_cfg"`
	SonicConsole	*SonicConsole_SonicConsole	`path:"sonic-console" module:"sonic-console"`
	SonicDhcpServer	*SonicDhcpServer_SonicDhcpServer	`path:"sonic-dhcp-server" module:"sonic-dhcp-server"`
	SonicDhcpv6Relay	*SonicDhcpv6Relay_SonicDhcpv6Relay	`path:"sonic-dhcpv6-relay" module:"sonic-dhcpv6-relay"`
	SonicFeature	*SonicFeature_SonicFeature	`path:"sonic-feature" module:"sonic-feature"`
	SonicFlexCounter	*SonicFlexCounter_SonicFlexCounter	`path:"sonic-flex_counter" module:"sonic-flex_counter"`
	SonicGnmi	*SonicGnmi_SonicGnmi	`path:"sonic-gnmi" module:"sonic-gnmi"`
	SonicHash	*SonicHash_SonicHash	`path:"sonic-hash" module:"sonic-hash"`
	SonicInterface	*SonicInterface_SonicInterface	`path:"sonic-interface" module:"sonic-interface"`
	SonicKdump	*SonicKdump_SonicKdump	`path:"sonic-kdump" module:"sonic-kdump"`
	SonicKubernetesMaster	*SonicKubernetesMaster_SonicKubernetesMaster	`path:"sonic-kubernetes_master" module:"sonic-kubernetes_master"`
	SonicLldp	*SonicLldp_SonicLldp	`path:"sonic-lldp" module:"sonic-lldp"`
	SonicLoopbackInterface	*SonicLoopbackInterface_SonicLoopbackInterface	`path:"sonic-loopback-interface" module:"sonic-loopback-interface"`
	SonicLosslessTrafficPattern	*SonicLosslessTrafficPattern_SonicLosslessTrafficPattern	`path:"sonic-lossless-traffic-pattern" module:"sonic-lossless-traffic-pattern"`
	SonicMacsec	*SonicMacsec_SonicMacsec	`path:"sonic-macsec" module:"sonic-macsec"`
	SonicMclag	*SonicMclag_SonicMclag	`path:"sonic-mclag" module:"sonic-mclag"`
	SonicMgmtInterface	*SonicMgmtInterface_SonicMgmtInterface	`path:"sonic-mgmt_interface" module:"sonic-mgmt_interface"`
	SonicMgmtPort	*SonicMgmtPort_SonicMgmtPort	`path:"sonic-mgmt_port" module:"sonic-mgmt_port"`
	SonicMgmtVrf	*SonicMgmtVrf_SonicMgmtVrf	`path:"sonic-mgmt_vrf" module:"sonic-mgmt_vrf"`
	SonicMuxCable	*SonicMuxCable_SonicMuxCable	`path:"sonic-mux-cable" module:"sonic-mux-cable"`
	SonicNat	*SonicNat_SonicNat	`path:"sonic-nat" module:"sonic-nat"`
	SonicNtp	*SonicNtp_SonicNtp	`path:"sonic-ntp" module:"sonic-ntp"`
	SonicNvgreTunnel	*SonicNvgreTunnel_SonicNvgreTunnel	`path:"sonic-nvgre-tunnel" module:"sonic-nvgre-tunnel"`
	SonicPasswh	*SonicPasswh_SonicPasswh	`path:"sonic-passwh" module:"sonic-passwh"`
	SonicPbh	*SonicPbh_SonicPbh	`path:"sonic-pbh" module:"sonic-pbh"`
	SonicPeerSwitch	*SonicPeerSwitch_SonicPeerSwitch	`path:"sonic-peer-switch" module:"sonic-peer-switch"`
	SonicPort	*SonicPort_SonicPort	`path:"sonic-port" module:"sonic-port"`
	SonicPortchannel	*SonicPortchannel_SonicPortchannel	`path:"sonic-portchannel" module:"sonic-portchannel"`
	SonicRestapi	*SonicRestapi_SonicRestapi	`path:"sonic-restapi" module:"sonic-restapi"`
	SonicRouteCommon	*SonicRouteCommon_SonicRouteCommon	`path:"sonic-route-common" module:"sonic-route-common"`
	SonicRouteMap	*SonicRouteMap_SonicRouteMap	`path:"sonic-route-map" module:"sonic-route-map"`
	SonicRoutingPolicySets	*SonicRoutingPolicySets_SonicRoutingPolicySets	`path:"sonic-routing-policy-sets" module:"sonic-routing-policy-sets"`
	SonicScheduler	*SonicScheduler_SonicScheduler	`path:"sonic-scheduler" module:"sonic-scheduler"`
	SonicSflow	*SonicSflow_SonicSflow	`path:"sonic-sflow" module:"sonic-sflow"`
	SonicSnmp	*SonicSnmp_SonicSnmp	`path:"sonic-snmp" module:"sonic-snmp"`
	SonicStaticRoute	*SonicStaticRoute_SonicStaticRoute	`path:"sonic-static-route" module:"sonic-static-route"`
	SonicStormControl	*SonicStormControl_SonicStormControl	`path:"sonic-storm-control" module:"sonic-storm-control"`
	SonicTelemetry	*SonicTelemetry_SonicTelemetry	`path:"sonic-telemetry" module:"sonic-telemetry"`
	SonicVersions	*SonicVersions_SonicVersions	`path:"sonic-versions" module:"sonic-versions"`
	SonicVlan	*SonicVlan_SonicVlan	`path:"sonic-vlan" module:"sonic-vlan"`
	SonicVlanSubInterface	*SonicVlanSubInterface_SonicVlanSubInterface	`path:"sonic-vlan-sub-interface" module:"sonic-vlan-sub-interface"`
	SonicVrf	*SonicVrf_SonicVrf	`path:"sonic-vrf" module:"sonic-vrf"`
	SonicVxlan	*SonicVxlan_SonicVxlan	`path:"sonic-vxlan" module:"sonic-vxlan"`
}

// IsYANGGoStruct ensures that Device implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Device) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Device"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Device) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Device.
func (*Device) ΛBelongingModule() string {
	return ""
}


// SonicAutoTechsupport_SonicAutoTechsupport represents the /sonic-auto_techsupport/sonic-auto_techsupport YANG schema element.
type SonicAutoTechsupport_SonicAutoTechsupport struct {
	AUTO_TECHSUPPORT	*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT	`path:"AUTO_TECHSUPPORT" module:"sonic-auto_techsupport"`
	AUTO_TECHSUPPORT_FEATURE	*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE	`path:"AUTO_TECHSUPPORT_FEATURE" module:"sonic-auto_techsupport"`
}

// IsYANGGoStruct ensures that SonicAutoTechsupport_SonicAutoTechsupport implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicAutoTechsupport_SonicAutoTechsupport) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicAutoTechsupport_SonicAutoTechsupport) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicAutoTechsupport_SonicAutoTechsupport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicAutoTechsupport_SonicAutoTechsupport) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicAutoTechsupport_SonicAutoTechsupport) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicAutoTechsupport_SonicAutoTechsupport.
func (*SonicAutoTechsupport_SonicAutoTechsupport) ΛBelongingModule() string {
	return "sonic-auto_techsupport"
}


// SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT represents the /sonic-auto_techsupport/sonic-auto_techsupport/AUTO_TECHSUPPORT YANG schema element.
type SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT struct {
	GLOBAL	*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_GLOBAL	`path:"GLOBAL" module:"sonic-auto_techsupport"`
}

// IsYANGGoStruct ensures that SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT.
func (*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT) ΛBelongingModule() string {
	return "sonic-auto_techsupport"
}


// SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE represents the /sonic-auto_techsupport/sonic-auto_techsupport/AUTO_TECHSUPPORT_FEATURE YANG schema element.
type SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE struct {
	AUTO_TECHSUPPORT_FEATURE_LIST	map[string]*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST	`path:"AUTO_TECHSUPPORT_FEATURE_LIST" module:"sonic-auto_techsupport"`
}

// IsYANGGoStruct ensures that SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE) IsYANGGoStruct() {}

// NewAUTO_TECHSUPPORT_FEATURE_LIST creates a new entry in the AUTO_TECHSUPPORT_FEATURE_LIST list of the
// SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE) NewAUTO_TECHSUPPORT_FEATURE_LIST(FeatureName string) (*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AUTO_TECHSUPPORT_FEATURE_LIST == nil {
		t.AUTO_TECHSUPPORT_FEATURE_LIST = make(map[string]*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST)
	}

	key := FeatureName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AUTO_TECHSUPPORT_FEATURE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AUTO_TECHSUPPORT_FEATURE_LIST", key)
	}

	t.AUTO_TECHSUPPORT_FEATURE_LIST[key] = &SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST{
		FeatureName: &FeatureName,
	}

	return t.AUTO_TECHSUPPORT_FEATURE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE.
func (*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE) ΛBelongingModule() string {
	return "sonic-auto_techsupport"
}


// SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST represents the /sonic-auto_techsupport/sonic-auto_techsupport/AUTO_TECHSUPPORT_FEATURE/AUTO_TECHSUPPORT_FEATURE_LIST YANG schema element.
type SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST struct {
	AvailableMemThreshold	*float64	`path:"available_mem_threshold" module:"sonic-auto_techsupport"`
	FeatureName	*string	`path:"feature_name" module:"sonic-auto_techsupport"`
	RateLimitInterval	*uint16	`path:"rate_limit_interval" module:"sonic-auto_techsupport"`
	State	E_SonicTypes_AdminMode	`path:"state" module:"sonic-auto_techsupport"`
}

// IsYANGGoStruct ensures that SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST struct, which is a YANG list entry.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FeatureName == nil {
		return nil, fmt.Errorf("nil value for key FeatureName")
	}

	return map[string]interface{}{
		"feature_name": *t.FeatureName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST.
func (*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_FEATURE_AUTO_TECHSUPPORT_FEATURE_LIST) ΛBelongingModule() string {
	return "sonic-auto_techsupport"
}


// SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_GLOBAL represents the /sonic-auto_techsupport/sonic-auto_techsupport/AUTO_TECHSUPPORT/GLOBAL YANG schema element.
type SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_GLOBAL struct {
	AvailableMemThreshold	*float64	`path:"available_mem_threshold" module:"sonic-auto_techsupport"`
	MaxCoreLimit	*float64	`path:"max_core_limit" module:"sonic-auto_techsupport"`
	MaxTechsupportLimit	*float64	`path:"max_techsupport_limit" module:"sonic-auto_techsupport"`
	MinAvailableMem	*uint32	`path:"min_available_mem" module:"sonic-auto_techsupport"`
	RateLimitInterval	*uint16	`path:"rate_limit_interval" module:"sonic-auto_techsupport"`
	Since	*string	`path:"since" module:"sonic-auto_techsupport"`
	State	E_SonicTypes_AdminMode	`path:"state" module:"sonic-auto_techsupport"`
}

// IsYANGGoStruct ensures that SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_GLOBAL implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_GLOBAL) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_GLOBAL) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_GLOBAL"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_GLOBAL) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_GLOBAL) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_GLOBAL.
func (*SonicAutoTechsupport_SonicAutoTechsupport_AUTO_TECHSUPPORT_GLOBAL) ΛBelongingModule() string {
	return "sonic-auto_techsupport"
}


// SonicBreakoutCfg_SonicBreakoutCfg represents the /sonic-breakout_cfg/sonic-breakout_cfg YANG schema element.
type SonicBreakoutCfg_SonicBreakoutCfg struct {
	BREAKOUT_CFG	*SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG	`path:"BREAKOUT_CFG" module:"sonic-breakout_cfg"`
}

// IsYANGGoStruct ensures that SonicBreakoutCfg_SonicBreakoutCfg implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicBreakoutCfg_SonicBreakoutCfg) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicBreakoutCfg_SonicBreakoutCfg) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicBreakoutCfg_SonicBreakoutCfg"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicBreakoutCfg_SonicBreakoutCfg) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicBreakoutCfg_SonicBreakoutCfg) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicBreakoutCfg_SonicBreakoutCfg.
func (*SonicBreakoutCfg_SonicBreakoutCfg) ΛBelongingModule() string {
	return "sonic-breakout_cfg"
}


// SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG represents the /sonic-breakout_cfg/sonic-breakout_cfg/BREAKOUT_CFG YANG schema element.
type SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG struct {
	BREAKOUT_CFG_LIST	map[string]*SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST	`path:"BREAKOUT_CFG_LIST" module:"sonic-breakout_cfg"`
}

// IsYANGGoStruct ensures that SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG) IsYANGGoStruct() {}

// NewBREAKOUT_CFG_LIST creates a new entry in the BREAKOUT_CFG_LIST list of the
// SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG struct. The keys of the list are populated from the input
// arguments.
func (t *SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG) NewBREAKOUT_CFG_LIST(Port string) (*SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BREAKOUT_CFG_LIST == nil {
		t.BREAKOUT_CFG_LIST = make(map[string]*SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST)
	}

	key := Port

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BREAKOUT_CFG_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BREAKOUT_CFG_LIST", key)
	}

	t.BREAKOUT_CFG_LIST[key] = &SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST{
		Port: &Port,
	}

	return t.BREAKOUT_CFG_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG.
func (*SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG) ΛBelongingModule() string {
	return "sonic-breakout_cfg"
}


// SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST represents the /sonic-breakout_cfg/sonic-breakout_cfg/BREAKOUT_CFG/BREAKOUT_CFG_LIST YANG schema element.
type SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST struct {
	BrkoutMode	*string	`path:"brkout_mode" module:"sonic-breakout_cfg"`
	Port	*string	`path:"port" module:"sonic-breakout_cfg"`
}

// IsYANGGoStruct ensures that SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST struct, which is a YANG list entry.
func (t *SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Port == nil {
		return nil, fmt.Errorf("nil value for key Port")
	}

	return map[string]interface{}{
		"port": *t.Port,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST.
func (*SonicBreakoutCfg_SonicBreakoutCfg_BREAKOUT_CFG_BREAKOUT_CFG_LIST) ΛBelongingModule() string {
	return "sonic-breakout_cfg"
}


// SonicConsole_SonicConsole represents the /sonic-console/sonic-console YANG schema element.
type SonicConsole_SonicConsole struct {
	CONSOLE_PORT	*SonicConsole_SonicConsole_CONSOLE_PORT	`path:"CONSOLE_PORT" module:"sonic-console"`
	CONSOLE_SWITCH	*SonicConsole_SonicConsole_CONSOLE_SWITCH	`path:"CONSOLE_SWITCH" module:"sonic-console"`
}

// IsYANGGoStruct ensures that SonicConsole_SonicConsole implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicConsole_SonicConsole) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicConsole_SonicConsole) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicConsole_SonicConsole"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicConsole_SonicConsole) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicConsole_SonicConsole) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicConsole_SonicConsole.
func (*SonicConsole_SonicConsole) ΛBelongingModule() string {
	return "sonic-console"
}


// SonicConsole_SonicConsole_CONSOLE_PORT represents the /sonic-console/sonic-console/CONSOLE_PORT YANG schema element.
type SonicConsole_SonicConsole_CONSOLE_PORT struct {
	CONSOLE_PORT_LIST	map[uint16]*SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST	`path:"CONSOLE_PORT_LIST" module:"sonic-console"`
}

// IsYANGGoStruct ensures that SonicConsole_SonicConsole_CONSOLE_PORT implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicConsole_SonicConsole_CONSOLE_PORT) IsYANGGoStruct() {}

// NewCONSOLE_PORT_LIST creates a new entry in the CONSOLE_PORT_LIST list of the
// SonicConsole_SonicConsole_CONSOLE_PORT struct. The keys of the list are populated from the input
// arguments.
func (t *SonicConsole_SonicConsole_CONSOLE_PORT) NewCONSOLE_PORT_LIST(Name uint16) (*SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CONSOLE_PORT_LIST == nil {
		t.CONSOLE_PORT_LIST = make(map[uint16]*SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.CONSOLE_PORT_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list CONSOLE_PORT_LIST", key)
	}

	t.CONSOLE_PORT_LIST[key] = &SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST{
		Name: &Name,
	}

	return t.CONSOLE_PORT_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicConsole_SonicConsole_CONSOLE_PORT) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicConsole_SonicConsole_CONSOLE_PORT"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicConsole_SonicConsole_CONSOLE_PORT) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicConsole_SonicConsole_CONSOLE_PORT) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicConsole_SonicConsole_CONSOLE_PORT.
func (*SonicConsole_SonicConsole_CONSOLE_PORT) ΛBelongingModule() string {
	return "sonic-console"
}


// SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST represents the /sonic-console/sonic-console/CONSOLE_PORT/CONSOLE_PORT_LIST YANG schema element.
type SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST struct {
	BaudRate	*uint32	`path:"baud_rate" module:"sonic-console"`
	FlowControl	*string	`path:"flow_control" module:"sonic-console"`
	Name	*uint16	`path:"name" module:"sonic-console"`
	RemoteDevice	*string	`path:"remote_device" module:"sonic-console"`
}

// IsYANGGoStruct ensures that SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST struct, which is a YANG list entry.
func (t *SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST.
func (*SonicConsole_SonicConsole_CONSOLE_PORT_CONSOLE_PORT_LIST) ΛBelongingModule() string {
	return "sonic-console"
}


// SonicConsole_SonicConsole_CONSOLE_SWITCH represents the /sonic-console/sonic-console/CONSOLE_SWITCH YANG schema element.
type SonicConsole_SonicConsole_CONSOLE_SWITCH struct {
	ConsoleMgmt	*SonicConsole_SonicConsole_CONSOLE_SWITCH_ConsoleMgmt	`path:"console_mgmt" module:"sonic-console"`
}

// IsYANGGoStruct ensures that SonicConsole_SonicConsole_CONSOLE_SWITCH implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicConsole_SonicConsole_CONSOLE_SWITCH) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicConsole_SonicConsole_CONSOLE_SWITCH) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicConsole_SonicConsole_CONSOLE_SWITCH"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicConsole_SonicConsole_CONSOLE_SWITCH) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicConsole_SonicConsole_CONSOLE_SWITCH) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicConsole_SonicConsole_CONSOLE_SWITCH.
func (*SonicConsole_SonicConsole_CONSOLE_SWITCH) ΛBelongingModule() string {
	return "sonic-console"
}


// SonicConsole_SonicConsole_CONSOLE_SWITCH_ConsoleMgmt represents the /sonic-console/sonic-console/CONSOLE_SWITCH/console_mgmt YANG schema element.
type SonicConsole_SonicConsole_CONSOLE_SWITCH_ConsoleMgmt struct {
	Enabled	*string	`path:"enabled" module:"sonic-console"`
}

// IsYANGGoStruct ensures that SonicConsole_SonicConsole_CONSOLE_SWITCH_ConsoleMgmt implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicConsole_SonicConsole_CONSOLE_SWITCH_ConsoleMgmt) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicConsole_SonicConsole_CONSOLE_SWITCH_ConsoleMgmt) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicConsole_SonicConsole_CONSOLE_SWITCH_ConsoleMgmt"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicConsole_SonicConsole_CONSOLE_SWITCH_ConsoleMgmt) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicConsole_SonicConsole_CONSOLE_SWITCH_ConsoleMgmt) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicConsole_SonicConsole_CONSOLE_SWITCH_ConsoleMgmt.
func (*SonicConsole_SonicConsole_CONSOLE_SWITCH_ConsoleMgmt) ΛBelongingModule() string {
	return "sonic-console"
}


// SonicDhcpServer_SonicDhcpServer represents the /sonic-dhcp-server/sonic-dhcp-server YANG schema element.
type SonicDhcpServer_SonicDhcpServer struct {
	DHCP_SERVER	*SonicDhcpServer_SonicDhcpServer_DHCP_SERVER	`path:"DHCP_SERVER" module:"sonic-dhcp-server"`
}

// IsYANGGoStruct ensures that SonicDhcpServer_SonicDhcpServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicDhcpServer_SonicDhcpServer) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicDhcpServer_SonicDhcpServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicDhcpServer_SonicDhcpServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicDhcpServer_SonicDhcpServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicDhcpServer_SonicDhcpServer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicDhcpServer_SonicDhcpServer.
func (*SonicDhcpServer_SonicDhcpServer) ΛBelongingModule() string {
	return "sonic-dhcp-server"
}


// SonicDhcpServer_SonicDhcpServer_DHCP_SERVER represents the /sonic-dhcp-server/sonic-dhcp-server/DHCP_SERVER YANG schema element.
type SonicDhcpServer_SonicDhcpServer_DHCP_SERVER struct {
	DHCP_SERVER_LIST	map[string]*SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST	`path:"DHCP_SERVER_LIST" module:"sonic-dhcp-server"`
}

// IsYANGGoStruct ensures that SonicDhcpServer_SonicDhcpServer_DHCP_SERVER implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicDhcpServer_SonicDhcpServer_DHCP_SERVER) IsYANGGoStruct() {}

// NewDHCP_SERVER_LIST creates a new entry in the DHCP_SERVER_LIST list of the
// SonicDhcpServer_SonicDhcpServer_DHCP_SERVER struct. The keys of the list are populated from the input
// arguments.
func (t *SonicDhcpServer_SonicDhcpServer_DHCP_SERVER) NewDHCP_SERVER_LIST(Ip string) (*SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DHCP_SERVER_LIST == nil {
		t.DHCP_SERVER_LIST = make(map[string]*SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DHCP_SERVER_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DHCP_SERVER_LIST", key)
	}

	t.DHCP_SERVER_LIST[key] = &SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST{
		Ip: &Ip,
	}

	return t.DHCP_SERVER_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicDhcpServer_SonicDhcpServer_DHCP_SERVER) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicDhcpServer_SonicDhcpServer_DHCP_SERVER"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicDhcpServer_SonicDhcpServer_DHCP_SERVER) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicDhcpServer_SonicDhcpServer_DHCP_SERVER) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicDhcpServer_SonicDhcpServer_DHCP_SERVER.
func (*SonicDhcpServer_SonicDhcpServer_DHCP_SERVER) ΛBelongingModule() string {
	return "sonic-dhcp-server"
}


// SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST represents the /sonic-dhcp-server/sonic-dhcp-server/DHCP_SERVER/DHCP_SERVER_LIST YANG schema element.
type SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST struct {
	Ip	*string	`path:"ip" module:"sonic-dhcp-server"`
}

// IsYANGGoStruct ensures that SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST struct, which is a YANG list entry.
func (t *SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST.
func (*SonicDhcpServer_SonicDhcpServer_DHCP_SERVER_DHCP_SERVER_LIST) ΛBelongingModule() string {
	return "sonic-dhcp-server"
}


// SonicDhcpv6Relay_SonicDhcpv6Relay represents the /sonic-dhcpv6-relay/sonic-dhcpv6-relay YANG schema element.
type SonicDhcpv6Relay_SonicDhcpv6Relay struct {
	DHCP_RELAY	*SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY	`path:"DHCP_RELAY" module:"sonic-dhcpv6-relay"`
}

// IsYANGGoStruct ensures that SonicDhcpv6Relay_SonicDhcpv6Relay implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicDhcpv6Relay_SonicDhcpv6Relay) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicDhcpv6Relay_SonicDhcpv6Relay) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicDhcpv6Relay_SonicDhcpv6Relay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicDhcpv6Relay_SonicDhcpv6Relay) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicDhcpv6Relay_SonicDhcpv6Relay) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicDhcpv6Relay_SonicDhcpv6Relay.
func (*SonicDhcpv6Relay_SonicDhcpv6Relay) ΛBelongingModule() string {
	return "sonic-dhcpv6-relay"
}


// SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY represents the /sonic-dhcpv6-relay/sonic-dhcpv6-relay/DHCP_RELAY YANG schema element.
type SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY struct {
	DHCP_RELAY_LIST	map[string]*SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST	`path:"DHCP_RELAY_LIST" module:"sonic-dhcpv6-relay"`
}

// IsYANGGoStruct ensures that SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY) IsYANGGoStruct() {}

// NewDHCP_RELAY_LIST creates a new entry in the DHCP_RELAY_LIST list of the
// SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY struct. The keys of the list are populated from the input
// arguments.
func (t *SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY) NewDHCP_RELAY_LIST(Name string) (*SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DHCP_RELAY_LIST == nil {
		t.DHCP_RELAY_LIST = make(map[string]*SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DHCP_RELAY_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DHCP_RELAY_LIST", key)
	}

	t.DHCP_RELAY_LIST[key] = &SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST{
		Name: &Name,
	}

	return t.DHCP_RELAY_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY.
func (*SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY) ΛBelongingModule() string {
	return "sonic-dhcpv6-relay"
}


// SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST represents the /sonic-dhcpv6-relay/sonic-dhcpv6-relay/DHCP_RELAY/DHCP_RELAY_LIST YANG schema element.
type SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST struct {
	Dhcpv6Servers	[]string	`path:"dhcpv6_servers" module:"sonic-dhcpv6-relay"`
	Name	*string	`path:"name" module:"sonic-dhcpv6-relay"`
	Rfc6939Support	*bool	`path:"rfc6939_support" module:"sonic-dhcpv6-relay"`
}

// IsYANGGoStruct ensures that SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST struct, which is a YANG list entry.
func (t *SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST.
func (*SonicDhcpv6Relay_SonicDhcpv6Relay_DHCP_RELAY_DHCP_RELAY_LIST) ΛBelongingModule() string {
	return "sonic-dhcpv6-relay"
}


// SonicFeature_SonicFeature represents the /sonic-feature/sonic-feature YANG schema element.
type SonicFeature_SonicFeature struct {
	FEATURE	*SonicFeature_SonicFeature_FEATURE	`path:"FEATURE" module:"sonic-feature"`
}

// IsYANGGoStruct ensures that SonicFeature_SonicFeature implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFeature_SonicFeature) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFeature_SonicFeature) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFeature_SonicFeature"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFeature_SonicFeature) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFeature_SonicFeature) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFeature_SonicFeature.
func (*SonicFeature_SonicFeature) ΛBelongingModule() string {
	return "sonic-feature"
}


// SonicFeature_SonicFeature_FEATURE represents the /sonic-feature/sonic-feature/FEATURE YANG schema element.
type SonicFeature_SonicFeature_FEATURE struct {
	FEATURE_LIST	map[string]*SonicFeature_SonicFeature_FEATURE_FEATURE_LIST	`path:"FEATURE_LIST" module:"sonic-feature"`
}

// IsYANGGoStruct ensures that SonicFeature_SonicFeature_FEATURE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFeature_SonicFeature_FEATURE) IsYANGGoStruct() {}

// NewFEATURE_LIST creates a new entry in the FEATURE_LIST list of the
// SonicFeature_SonicFeature_FEATURE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicFeature_SonicFeature_FEATURE) NewFEATURE_LIST(Name string) (*SonicFeature_SonicFeature_FEATURE_FEATURE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.FEATURE_LIST == nil {
		t.FEATURE_LIST = make(map[string]*SonicFeature_SonicFeature_FEATURE_FEATURE_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.FEATURE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list FEATURE_LIST", key)
	}

	t.FEATURE_LIST[key] = &SonicFeature_SonicFeature_FEATURE_FEATURE_LIST{
		Name: &Name,
	}

	return t.FEATURE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFeature_SonicFeature_FEATURE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFeature_SonicFeature_FEATURE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFeature_SonicFeature_FEATURE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFeature_SonicFeature_FEATURE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFeature_SonicFeature_FEATURE.
func (*SonicFeature_SonicFeature_FEATURE) ΛBelongingModule() string {
	return "sonic-feature"
}


// SonicFeature_SonicFeature_FEATURE_FEATURE_LIST represents the /sonic-feature/sonic-feature/FEATURE/FEATURE_LIST YANG schema element.
type SonicFeature_SonicFeature_FEATURE_FEATURE_LIST struct {
	AutoRestart	*string	`path:"auto_restart" module:"sonic-feature"`
	CheckUpStatus	*string	`path:"check_up_status" module:"sonic-feature"`
	HasGlobalScope	*string	`path:"has_global_scope" module:"sonic-feature"`
	HasPerAsicScope	*string	`path:"has_per_asic_scope" module:"sonic-feature"`
	HasTimer	*string	`path:"has_timer" module:"sonic-feature"`
	HighMemAlert	*string	`path:"high_mem_alert" module:"sonic-feature"`
	Name	*string	`path:"name" module:"sonic-feature"`
	SetOwner	*string	`path:"set_owner" module:"sonic-feature"`
	State	*string	`path:"state" module:"sonic-feature"`
	SupportSyslogRateLimit	*string	`path:"support_syslog_rate_limit" module:"sonic-feature"`
}

// IsYANGGoStruct ensures that SonicFeature_SonicFeature_FEATURE_FEATURE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFeature_SonicFeature_FEATURE_FEATURE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicFeature_SonicFeature_FEATURE_FEATURE_LIST struct, which is a YANG list entry.
func (t *SonicFeature_SonicFeature_FEATURE_FEATURE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFeature_SonicFeature_FEATURE_FEATURE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFeature_SonicFeature_FEATURE_FEATURE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFeature_SonicFeature_FEATURE_FEATURE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFeature_SonicFeature_FEATURE_FEATURE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFeature_SonicFeature_FEATURE_FEATURE_LIST.
func (*SonicFeature_SonicFeature_FEATURE_FEATURE_LIST) ΛBelongingModule() string {
	return "sonic-feature"
}


// SonicFlexCounter_SonicFlexCounter represents the /sonic-flex_counter/sonic-flex_counter YANG schema element.
type SonicFlexCounter_SonicFlexCounter struct {
	FLEX_COUNTER_TABLE	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE	`path:"FLEX_COUNTER_TABLE" module:"sonic-flex_counter"`
	FLOW_COUNTER_ROUTE_PATTERN	*SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN	`path:"FLOW_COUNTER_ROUTE_PATTERN" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter.
func (*SonicFlexCounter_SonicFlexCounter) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE struct {
	ACL	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_ACL	`path:"ACL" module:"sonic-flex_counter"`
	BUFFER_POOL_WATERMARK	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_BUFFER_POOL_WATERMARK	`path:"BUFFER_POOL_WATERMARK" module:"sonic-flex_counter"`
	DEBUG_COUNTER	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_DEBUG_COUNTER	`path:"DEBUG_COUNTER" module:"sonic-flex_counter"`
	FLOW_CNT_ROUTE	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_ROUTE	`path:"FLOW_CNT_ROUTE" module:"sonic-flex_counter"`
	FLOW_CNT_TRAP	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_TRAP	`path:"FLOW_CNT_TRAP" module:"sonic-flex_counter"`
	PFCWD	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PFCWD	`path:"PFCWD" module:"sonic-flex_counter"`
	PG_DROP	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_DROP	`path:"PG_DROP" module:"sonic-flex_counter"`
	PG_WATERMARK	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_WATERMARK	`path:"PG_WATERMARK" module:"sonic-flex_counter"`
	PORT	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT	`path:"PORT" module:"sonic-flex_counter"`
	PORT_BUFFER_DROP	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_BUFFER_DROP	`path:"PORT_BUFFER_DROP" module:"sonic-flex_counter"`
	PORT_RATES	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_RATES	`path:"PORT_RATES" module:"sonic-flex_counter"`
	QUEUE	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE	`path:"QUEUE" module:"sonic-flex_counter"`
	QUEUE_WATERMARK	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE_WATERMARK	`path:"QUEUE_WATERMARK" module:"sonic-flex_counter"`
	RIF	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF	`path:"RIF" module:"sonic-flex_counter"`
	RIF_RATES	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF_RATES	`path:"RIF_RATES" module:"sonic-flex_counter"`
	TUNNEL	*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_TUNNEL	`path:"TUNNEL" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_ACL represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/ACL YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_ACL struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
	POLL_INTERVAL	*uint32	`path:"POLL_INTERVAL" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_ACL implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_ACL) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_ACL) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_ACL"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_ACL) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_ACL) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_ACL.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_ACL) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_BUFFER_POOL_WATERMARK represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/BUFFER_POOL_WATERMARK YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_BUFFER_POOL_WATERMARK struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
	POLL_INTERVAL	*uint32	`path:"POLL_INTERVAL" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_BUFFER_POOL_WATERMARK implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_BUFFER_POOL_WATERMARK) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_BUFFER_POOL_WATERMARK) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_BUFFER_POOL_WATERMARK"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_BUFFER_POOL_WATERMARK) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_BUFFER_POOL_WATERMARK) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_BUFFER_POOL_WATERMARK.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_BUFFER_POOL_WATERMARK) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_DEBUG_COUNTER represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/DEBUG_COUNTER YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_DEBUG_COUNTER struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_DEBUG_COUNTER implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_DEBUG_COUNTER) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_DEBUG_COUNTER) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_DEBUG_COUNTER"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_DEBUG_COUNTER) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_DEBUG_COUNTER) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_DEBUG_COUNTER.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_DEBUG_COUNTER) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_ROUTE represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/FLOW_CNT_ROUTE YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_ROUTE struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
	POLL_INTERVAL	*uint32	`path:"POLL_INTERVAL" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_ROUTE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_ROUTE) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_ROUTE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_ROUTE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_ROUTE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_ROUTE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_ROUTE.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_ROUTE) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_TRAP represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/FLOW_CNT_TRAP YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_TRAP struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
	POLL_INTERVAL	*uint32	`path:"POLL_INTERVAL" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_TRAP implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_TRAP) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_TRAP) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_TRAP"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_TRAP) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_TRAP) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_TRAP.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_FLOW_CNT_TRAP) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PFCWD represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/PFCWD YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PFCWD struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PFCWD implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PFCWD) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PFCWD) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PFCWD"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PFCWD) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PFCWD) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PFCWD.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PFCWD) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_DROP represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/PG_DROP YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_DROP struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
	POLL_INTERVAL	*uint32	`path:"POLL_INTERVAL" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_DROP implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_DROP) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_DROP) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_DROP"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_DROP) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_DROP) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_DROP.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_DROP) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_WATERMARK represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/PG_WATERMARK YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_WATERMARK struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
	POLL_INTERVAL	*uint32	`path:"POLL_INTERVAL" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_WATERMARK implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_WATERMARK) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_WATERMARK) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_WATERMARK"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_WATERMARK) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_WATERMARK) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_WATERMARK.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PG_WATERMARK) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/PORT YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
	POLL_INTERVAL	*uint32	`path:"POLL_INTERVAL" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_BUFFER_DROP represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/PORT_BUFFER_DROP YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_BUFFER_DROP struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
	POLL_INTERVAL	*uint32	`path:"POLL_INTERVAL" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_BUFFER_DROP implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_BUFFER_DROP) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_BUFFER_DROP) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_BUFFER_DROP"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_BUFFER_DROP) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_BUFFER_DROP) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_BUFFER_DROP.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_BUFFER_DROP) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_RATES represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/PORT_RATES YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_RATES struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_RATES implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_RATES) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_RATES) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_RATES"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_RATES) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_RATES) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_RATES.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_PORT_RATES) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/QUEUE YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
	POLL_INTERVAL	*uint32	`path:"POLL_INTERVAL" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE_WATERMARK represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/QUEUE_WATERMARK YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE_WATERMARK struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
	POLL_INTERVAL	*uint32	`path:"POLL_INTERVAL" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE_WATERMARK implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE_WATERMARK) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE_WATERMARK) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE_WATERMARK"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE_WATERMARK) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE_WATERMARK) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE_WATERMARK.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_QUEUE_WATERMARK) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/RIF YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
	POLL_INTERVAL	*uint32	`path:"POLL_INTERVAL" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF_RATES represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/RIF_RATES YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF_RATES struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF_RATES implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF_RATES) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF_RATES) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF_RATES"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF_RATES) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF_RATES) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF_RATES.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_RIF_RATES) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_TUNNEL represents the /sonic-flex_counter/sonic-flex_counter/FLEX_COUNTER_TABLE/TUNNEL YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_TUNNEL struct {
	FLEX_COUNTER_DELAY_STATUS	*string	`path:"FLEX_COUNTER_DELAY_STATUS" module:"sonic-flex_counter"`
	FLEX_COUNTER_STATUS	E_SonicFlexCounter_FlexStatus	`path:"FLEX_COUNTER_STATUS" module:"sonic-flex_counter"`
	POLL_INTERVAL	*uint32	`path:"POLL_INTERVAL" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_TUNNEL implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_TUNNEL) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_TUNNEL) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_TUNNEL"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_TUNNEL) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_TUNNEL) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_TUNNEL.
func (*SonicFlexCounter_SonicFlexCounter_FLEX_COUNTER_TABLE_TUNNEL) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN represents the /sonic-flex_counter/sonic-flex_counter/FLOW_COUNTER_ROUTE_PATTERN YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN struct {
	FLOW_COUNTER_ROUTE_PATTERN_LIST	map[string]*SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST	`path:"FLOW_COUNTER_ROUTE_PATTERN_LIST" module:"sonic-flex_counter"`
	FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST	map[SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST_Key]*SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST	`path:"FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN) IsYANGGoStruct() {}

// SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST_Key represents the key for list FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST of element /sonic-flex_counter/sonic-flex_counter/FLOW_COUNTER_ROUTE_PATTERN.
type SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST_Key struct {
	VrfName	string	`path:"vrf_name"`
	IpPrefix	string	`path:"ip_prefix"`
}

// IsYANGGoKeyStruct ensures that SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST_Key key struct.
func (t SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"vrf_name": t.VrfName,
		"ip_prefix": t.IpPrefix,
	}, nil
}

// NewFLOW_COUNTER_ROUTE_PATTERN_LIST creates a new entry in the FLOW_COUNTER_ROUTE_PATTERN_LIST list of the
// SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN struct. The keys of the list are populated from the input
// arguments.
func (t *SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN) NewFLOW_COUNTER_ROUTE_PATTERN_LIST(IpPrefix string) (*SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.FLOW_COUNTER_ROUTE_PATTERN_LIST == nil {
		t.FLOW_COUNTER_ROUTE_PATTERN_LIST = make(map[string]*SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST)
	}

	key := IpPrefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.FLOW_COUNTER_ROUTE_PATTERN_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list FLOW_COUNTER_ROUTE_PATTERN_LIST", key)
	}

	t.FLOW_COUNTER_ROUTE_PATTERN_LIST[key] = &SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST{
		IpPrefix: &IpPrefix,
	}

	return t.FLOW_COUNTER_ROUTE_PATTERN_LIST[key], nil
}

// NewFLOW_COUNTER_ROUTE_PATTERN_VRF_LIST creates a new entry in the FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST list of the
// SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN struct. The keys of the list are populated from the input
// arguments.
func (t *SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN) NewFLOW_COUNTER_ROUTE_PATTERN_VRF_LIST(VrfName string, IpPrefix string) (*SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST == nil {
		t.FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST = make(map[SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST_Key]*SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST)
	}

	key := SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST_Key{
		VrfName: VrfName,
		IpPrefix: IpPrefix,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST", key)
	}

	t.FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST[key] = &SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST{
		VrfName: &VrfName,
		IpPrefix: &IpPrefix,
	}

	return t.FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN.
func (*SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST represents the /sonic-flex_counter/sonic-flex_counter/FLOW_COUNTER_ROUTE_PATTERN/FLOW_COUNTER_ROUTE_PATTERN_LIST YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST struct {
	IpPrefix	*string	`path:"ip_prefix" module:"sonic-flex_counter"`
	MaxMatchCount	*uint32	`path:"max_match_count" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST struct, which is a YANG list entry.
func (t *SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	return map[string]interface{}{
		"ip_prefix": *t.IpPrefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST.
func (*SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_LIST) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST represents the /sonic-flex_counter/sonic-flex_counter/FLOW_COUNTER_ROUTE_PATTERN/FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST YANG schema element.
type SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST struct {
	IpPrefix	*string	`path:"ip_prefix" module:"sonic-flex_counter"`
	MaxMatchCount	*uint32	`path:"max_match_count" module:"sonic-flex_counter"`
	VrfName	*string	`path:"vrf_name" module:"sonic-flex_counter"`
}

// IsYANGGoStruct ensures that SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST struct, which is a YANG list entry.
func (t *SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	if t.VrfName == nil {
		return nil, fmt.Errorf("nil value for key VrfName")
	}

	return map[string]interface{}{
		"ip_prefix": *t.IpPrefix,
		"vrf_name": *t.VrfName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST.
func (*SonicFlexCounter_SonicFlexCounter_FLOW_COUNTER_ROUTE_PATTERN_FLOW_COUNTER_ROUTE_PATTERN_VRF_LIST) ΛBelongingModule() string {
	return "sonic-flex_counter"
}


// SonicGnmi_SonicGnmi represents the /sonic-gnmi/sonic-gnmi YANG schema element.
type SonicGnmi_SonicGnmi struct {
	GNMI	*SonicGnmi_SonicGnmi_GNMI	`path:"GNMI" module:"sonic-gnmi"`
}

// IsYANGGoStruct ensures that SonicGnmi_SonicGnmi implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicGnmi_SonicGnmi) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicGnmi_SonicGnmi) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicGnmi_SonicGnmi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicGnmi_SonicGnmi) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicGnmi_SonicGnmi) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicGnmi_SonicGnmi.
func (*SonicGnmi_SonicGnmi) ΛBelongingModule() string {
	return "sonic-gnmi"
}


// SonicGnmi_SonicGnmi_GNMI represents the /sonic-gnmi/sonic-gnmi/GNMI YANG schema element.
type SonicGnmi_SonicGnmi_GNMI struct {
	Certs	*SonicGnmi_SonicGnmi_GNMI_Certs	`path:"certs" module:"sonic-gnmi"`
	Gnmi	*SonicGnmi_SonicGnmi_GNMI_Gnmi	`path:"gnmi" module:"sonic-gnmi"`
}

// IsYANGGoStruct ensures that SonicGnmi_SonicGnmi_GNMI implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicGnmi_SonicGnmi_GNMI) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicGnmi_SonicGnmi_GNMI) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicGnmi_SonicGnmi_GNMI"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicGnmi_SonicGnmi_GNMI) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicGnmi_SonicGnmi_GNMI) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicGnmi_SonicGnmi_GNMI.
func (*SonicGnmi_SonicGnmi_GNMI) ΛBelongingModule() string {
	return "sonic-gnmi"
}


// SonicGnmi_SonicGnmi_GNMI_Certs represents the /sonic-gnmi/sonic-gnmi/GNMI/certs YANG schema element.
type SonicGnmi_SonicGnmi_GNMI_Certs struct {
	CaCrt	*string	`path:"ca_crt" module:"sonic-gnmi"`
	ServerCrt	*string	`path:"server_crt" module:"sonic-gnmi"`
	ServerKey	*string	`path:"server_key" module:"sonic-gnmi"`
}

// IsYANGGoStruct ensures that SonicGnmi_SonicGnmi_GNMI_Certs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicGnmi_SonicGnmi_GNMI_Certs) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicGnmi_SonicGnmi_GNMI_Certs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicGnmi_SonicGnmi_GNMI_Certs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicGnmi_SonicGnmi_GNMI_Certs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicGnmi_SonicGnmi_GNMI_Certs) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicGnmi_SonicGnmi_GNMI_Certs.
func (*SonicGnmi_SonicGnmi_GNMI_Certs) ΛBelongingModule() string {
	return "sonic-gnmi"
}


// SonicGnmi_SonicGnmi_GNMI_Gnmi represents the /sonic-gnmi/sonic-gnmi/GNMI/gnmi YANG schema element.
type SonicGnmi_SonicGnmi_GNMI_Gnmi struct {
	ClientAuth	*bool	`path:"client_auth" module:"sonic-gnmi"`
	LogLevel	*uint8	`path:"log_level" module:"sonic-gnmi"`
	Port	*uint16	`path:"port" module:"sonic-gnmi"`
}

// IsYANGGoStruct ensures that SonicGnmi_SonicGnmi_GNMI_Gnmi implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicGnmi_SonicGnmi_GNMI_Gnmi) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicGnmi_SonicGnmi_GNMI_Gnmi) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicGnmi_SonicGnmi_GNMI_Gnmi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicGnmi_SonicGnmi_GNMI_Gnmi) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicGnmi_SonicGnmi_GNMI_Gnmi) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicGnmi_SonicGnmi_GNMI_Gnmi.
func (*SonicGnmi_SonicGnmi_GNMI_Gnmi) ΛBelongingModule() string {
	return "sonic-gnmi"
}


// SonicHash_SonicHash represents the /sonic-hash/sonic-hash YANG schema element.
type SonicHash_SonicHash struct {
	SWITCH_HASH	*SonicHash_SonicHash_SWITCH_HASH	`path:"SWITCH_HASH" module:"sonic-hash"`
}

// IsYANGGoStruct ensures that SonicHash_SonicHash implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicHash_SonicHash) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicHash_SonicHash) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicHash_SonicHash"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicHash_SonicHash) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicHash_SonicHash) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicHash_SonicHash.
func (*SonicHash_SonicHash) ΛBelongingModule() string {
	return "sonic-hash"
}


// SonicHash_SonicHash_SWITCH_HASH represents the /sonic-hash/sonic-hash/SWITCH_HASH YANG schema element.
type SonicHash_SonicHash_SWITCH_HASH struct {
	GLOBAL	*SonicHash_SonicHash_SWITCH_HASH_GLOBAL	`path:"GLOBAL" module:"sonic-hash"`
}

// IsYANGGoStruct ensures that SonicHash_SonicHash_SWITCH_HASH implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicHash_SonicHash_SWITCH_HASH) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicHash_SonicHash_SWITCH_HASH) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicHash_SonicHash_SWITCH_HASH"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicHash_SonicHash_SWITCH_HASH) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicHash_SonicHash_SWITCH_HASH) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicHash_SonicHash_SWITCH_HASH.
func (*SonicHash_SonicHash_SWITCH_HASH) ΛBelongingModule() string {
	return "sonic-hash"
}


// SonicHash_SonicHash_SWITCH_HASH_GLOBAL represents the /sonic-hash/sonic-hash/SWITCH_HASH/GLOBAL YANG schema element.
type SonicHash_SonicHash_SWITCH_HASH_GLOBAL struct {
	EcmpHash	[]E_SonicHash_HashField	`path:"ecmp_hash" module:"sonic-hash"`
	LagHash	[]E_SonicHash_HashField	`path:"lag_hash" module:"sonic-hash"`
}

// IsYANGGoStruct ensures that SonicHash_SonicHash_SWITCH_HASH_GLOBAL implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicHash_SonicHash_SWITCH_HASH_GLOBAL) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicHash_SonicHash_SWITCH_HASH_GLOBAL) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicHash_SonicHash_SWITCH_HASH_GLOBAL"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicHash_SonicHash_SWITCH_HASH_GLOBAL) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicHash_SonicHash_SWITCH_HASH_GLOBAL) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicHash_SonicHash_SWITCH_HASH_GLOBAL.
func (*SonicHash_SonicHash_SWITCH_HASH_GLOBAL) ΛBelongingModule() string {
	return "sonic-hash"
}


// SonicInterface_SonicInterface represents the /sonic-interface/sonic-interface YANG schema element.
type SonicInterface_SonicInterface struct {
	INTERFACE	*SonicInterface_SonicInterface_INTERFACE	`path:"INTERFACE" module:"sonic-interface"`
}

// IsYANGGoStruct ensures that SonicInterface_SonicInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicInterface_SonicInterface) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicInterface_SonicInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicInterface_SonicInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicInterface_SonicInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicInterface_SonicInterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicInterface_SonicInterface.
func (*SonicInterface_SonicInterface) ΛBelongingModule() string {
	return "sonic-interface"
}


// SonicInterface_SonicInterface_INTERFACE represents the /sonic-interface/sonic-interface/INTERFACE YANG schema element.
type SonicInterface_SonicInterface_INTERFACE struct {
	INTERFACE_IPPREFIX_LIST	map[SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Key]*SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST	`path:"INTERFACE_IPPREFIX_LIST" module:"sonic-interface"`
	INTERFACE_LIST	map[string]*SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST	`path:"INTERFACE_LIST" module:"sonic-interface"`
}

// IsYANGGoStruct ensures that SonicInterface_SonicInterface_INTERFACE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicInterface_SonicInterface_INTERFACE) IsYANGGoStruct() {}

// SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Key represents the key for list INTERFACE_IPPREFIX_LIST of element /sonic-interface/sonic-interface/INTERFACE.
type SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Key struct {
	Name	string	`path:"name"`
	IpPrefix	string	`path:"ip-prefix"`
}

// IsYANGGoKeyStruct ensures that SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Key key struct.
func (t SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
		"ip-prefix": t.IpPrefix,
	}, nil
}

// NewINTERFACE_IPPREFIX_LIST creates a new entry in the INTERFACE_IPPREFIX_LIST list of the
// SonicInterface_SonicInterface_INTERFACE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicInterface_SonicInterface_INTERFACE) NewINTERFACE_IPPREFIX_LIST(Name string, IpPrefix string) (*SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.INTERFACE_IPPREFIX_LIST == nil {
		t.INTERFACE_IPPREFIX_LIST = make(map[SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Key]*SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST)
	}

	key := SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Key{
		Name: Name,
		IpPrefix: IpPrefix,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.INTERFACE_IPPREFIX_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list INTERFACE_IPPREFIX_LIST", key)
	}

	t.INTERFACE_IPPREFIX_LIST[key] = &SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST{
		Name: &Name,
		IpPrefix: &IpPrefix,
	}

	return t.INTERFACE_IPPREFIX_LIST[key], nil
}

// NewINTERFACE_LIST creates a new entry in the INTERFACE_LIST list of the
// SonicInterface_SonicInterface_INTERFACE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicInterface_SonicInterface_INTERFACE) NewINTERFACE_LIST(Name string) (*SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.INTERFACE_LIST == nil {
		t.INTERFACE_LIST = make(map[string]*SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.INTERFACE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list INTERFACE_LIST", key)
	}

	t.INTERFACE_LIST[key] = &SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST{
		Name: &Name,
	}

	return t.INTERFACE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicInterface_SonicInterface_INTERFACE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicInterface_SonicInterface_INTERFACE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicInterface_SonicInterface_INTERFACE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicInterface_SonicInterface_INTERFACE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicInterface_SonicInterface_INTERFACE.
func (*SonicInterface_SonicInterface_INTERFACE) ΛBelongingModule() string {
	return "sonic-interface"
}


// SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST represents the /sonic-interface/sonic-interface/INTERFACE/INTERFACE_IPPREFIX_LIST YANG schema element.
type SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST struct {
	Family	E_SonicTypes_IpFamily	`path:"family" module:"sonic-interface"`
	IpPrefix	*string	`path:"ip-prefix" module:"sonic-interface"`
	Name	*string	`path:"name" module:"sonic-interface"`
	Scope	E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope	`path:"scope" module:"sonic-interface"`
}

// IsYANGGoStruct ensures that SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST struct, which is a YANG list entry.
func (t *SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST.
func (*SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST) ΛBelongingModule() string {
	return "sonic-interface"
}


// SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST represents the /sonic-interface/sonic-interface/INTERFACE/INTERFACE_LIST YANG schema element.
type SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST struct {
	LoopbackAction	*string	`path:"loopback_action" module:"sonic-interface"`
	Mpls	E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls	`path:"mpls" module:"sonic-interface"`
	Name	*string	`path:"name" module:"sonic-interface"`
	NatZone	*uint8	`path:"nat_zone" module:"sonic-interface"`
	VrfName	*string	`path:"vrf_name" module:"sonic-interface"`
}

// IsYANGGoStruct ensures that SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST struct, which is a YANG list entry.
func (t *SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST.
func (*SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST) ΛBelongingModule() string {
	return "sonic-interface"
}


// SonicKdump_SonicKdump represents the /sonic-kdump/sonic-kdump YANG schema element.
type SonicKdump_SonicKdump struct {
	KDUMP	*SonicKdump_SonicKdump_KDUMP	`path:"KDUMP" module:"sonic-kdump"`
}

// IsYANGGoStruct ensures that SonicKdump_SonicKdump implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicKdump_SonicKdump) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicKdump_SonicKdump) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicKdump_SonicKdump"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicKdump_SonicKdump) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicKdump_SonicKdump) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicKdump_SonicKdump.
func (*SonicKdump_SonicKdump) ΛBelongingModule() string {
	return "sonic-kdump"
}


// SonicKdump_SonicKdump_KDUMP represents the /sonic-kdump/sonic-kdump/KDUMP YANG schema element.
type SonicKdump_SonicKdump_KDUMP struct {
	Config	*SonicKdump_SonicKdump_KDUMP_Config	`path:"config" module:"sonic-kdump"`
}

// IsYANGGoStruct ensures that SonicKdump_SonicKdump_KDUMP implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicKdump_SonicKdump_KDUMP) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicKdump_SonicKdump_KDUMP) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicKdump_SonicKdump_KDUMP"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicKdump_SonicKdump_KDUMP) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicKdump_SonicKdump_KDUMP) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicKdump_SonicKdump_KDUMP.
func (*SonicKdump_SonicKdump_KDUMP) ΛBelongingModule() string {
	return "sonic-kdump"
}


// SonicKdump_SonicKdump_KDUMP_Config represents the /sonic-kdump/sonic-kdump/KDUMP/config YANG schema element.
type SonicKdump_SonicKdump_KDUMP_Config struct {
	Enabled	*bool	`path:"enabled" module:"sonic-kdump"`
	Memory	*string	`path:"memory" module:"sonic-kdump"`
	NumDumps	*uint8	`path:"num_dumps" module:"sonic-kdump"`
}

// IsYANGGoStruct ensures that SonicKdump_SonicKdump_KDUMP_Config implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicKdump_SonicKdump_KDUMP_Config) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicKdump_SonicKdump_KDUMP_Config) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicKdump_SonicKdump_KDUMP_Config"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicKdump_SonicKdump_KDUMP_Config) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicKdump_SonicKdump_KDUMP_Config) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicKdump_SonicKdump_KDUMP_Config.
func (*SonicKdump_SonicKdump_KDUMP_Config) ΛBelongingModule() string {
	return "sonic-kdump"
}


// SonicKubernetesMaster_SonicKubernetesMaster represents the /sonic-kubernetes_master/sonic-kubernetes_master YANG schema element.
type SonicKubernetesMaster_SonicKubernetesMaster struct {
	KUBERNETES_MASTER	*SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER	`path:"KUBERNETES_MASTER" module:"sonic-kubernetes_master"`
}

// IsYANGGoStruct ensures that SonicKubernetesMaster_SonicKubernetesMaster implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicKubernetesMaster_SonicKubernetesMaster) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicKubernetesMaster_SonicKubernetesMaster) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicKubernetesMaster_SonicKubernetesMaster"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicKubernetesMaster_SonicKubernetesMaster) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicKubernetesMaster_SonicKubernetesMaster) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicKubernetesMaster_SonicKubernetesMaster.
func (*SonicKubernetesMaster_SonicKubernetesMaster) ΛBelongingModule() string {
	return "sonic-kubernetes_master"
}


// SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER represents the /sonic-kubernetes_master/sonic-kubernetes_master/KUBERNETES_MASTER YANG schema element.
type SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER struct {
	SERVER	*SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER_SERVER	`path:"SERVER" module:"sonic-kubernetes_master"`
}

// IsYANGGoStruct ensures that SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER.
func (*SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER) ΛBelongingModule() string {
	return "sonic-kubernetes_master"
}


// SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER_SERVER represents the /sonic-kubernetes_master/sonic-kubernetes_master/KUBERNETES_MASTER/SERVER YANG schema element.
type SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER_SERVER struct {
	Disable	*string	`path:"disable" module:"sonic-kubernetes_master"`
	Insecure	*string	`path:"insecure" module:"sonic-kubernetes_master"`
	Ip	*string	`path:"ip" module:"sonic-kubernetes_master"`
	Port	*uint16	`path:"port" module:"sonic-kubernetes_master"`
}

// IsYANGGoStruct ensures that SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER_SERVER implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER_SERVER) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER_SERVER) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER_SERVER"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER_SERVER) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER_SERVER) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER_SERVER.
func (*SonicKubernetesMaster_SonicKubernetesMaster_KUBERNETES_MASTER_SERVER) ΛBelongingModule() string {
	return "sonic-kubernetes_master"
}


// SonicLldp_SonicLldp represents the /sonic-lldp/sonic-lldp YANG schema element.
type SonicLldp_SonicLldp struct {
	LLDP	*SonicLldp_SonicLldp_LLDP	`path:"LLDP" module:"sonic-lldp"`
	LLDP_PORT	*SonicLldp_SonicLldp_LLDP_PORT	`path:"LLDP_PORT" module:"sonic-lldp"`
}

// IsYANGGoStruct ensures that SonicLldp_SonicLldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicLldp_SonicLldp) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLldp_SonicLldp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicLldp_SonicLldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLldp_SonicLldp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicLldp_SonicLldp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicLldp_SonicLldp.
func (*SonicLldp_SonicLldp) ΛBelongingModule() string {
	return "sonic-lldp"
}


// SonicLldp_SonicLldp_LLDP represents the /sonic-lldp/sonic-lldp/LLDP YANG schema element.
type SonicLldp_SonicLldp_LLDP struct {
	GLOBAL	*SonicLldp_SonicLldp_LLDP_GLOBAL	`path:"GLOBAL" module:"sonic-lldp"`
}

// IsYANGGoStruct ensures that SonicLldp_SonicLldp_LLDP implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicLldp_SonicLldp_LLDP) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLldp_SonicLldp_LLDP) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicLldp_SonicLldp_LLDP"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLldp_SonicLldp_LLDP) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicLldp_SonicLldp_LLDP) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicLldp_SonicLldp_LLDP.
func (*SonicLldp_SonicLldp_LLDP) ΛBelongingModule() string {
	return "sonic-lldp"
}


// SonicLldp_SonicLldp_LLDP_GLOBAL represents the /sonic-lldp/sonic-lldp/LLDP/GLOBAL YANG schema element.
type SonicLldp_SonicLldp_LLDP_GLOBAL struct {
	Enabled	*bool	`path:"enabled" module:"sonic-lldp"`
	HelloTime	*uint8	`path:"hello_time" module:"sonic-lldp"`
	Mode	E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode	`path:"mode" module:"sonic-lldp"`
	Multiplier	*uint8	`path:"multiplier" module:"sonic-lldp"`
	SuppMgmtAddressTlv	*bool	`path:"supp_mgmt_address_tlv" module:"sonic-lldp"`
	SuppSystemCapabilitiesTlv	*bool	`path:"supp_system_capabilities_tlv" module:"sonic-lldp"`
	SystemDescription	*string	`path:"system_description" module:"sonic-lldp"`
	SystemName	*string	`path:"system_name" module:"sonic-lldp"`
}

// IsYANGGoStruct ensures that SonicLldp_SonicLldp_LLDP_GLOBAL implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicLldp_SonicLldp_LLDP_GLOBAL) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLldp_SonicLldp_LLDP_GLOBAL) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicLldp_SonicLldp_LLDP_GLOBAL"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLldp_SonicLldp_LLDP_GLOBAL) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicLldp_SonicLldp_LLDP_GLOBAL) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicLldp_SonicLldp_LLDP_GLOBAL.
func (*SonicLldp_SonicLldp_LLDP_GLOBAL) ΛBelongingModule() string {
	return "sonic-lldp"
}


// SonicLldp_SonicLldp_LLDP_PORT represents the /sonic-lldp/sonic-lldp/LLDP_PORT YANG schema element.
type SonicLldp_SonicLldp_LLDP_PORT struct {
	LLDP_PORT_LIST	map[string]*SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST	`path:"LLDP_PORT_LIST" module:"sonic-lldp"`
}

// IsYANGGoStruct ensures that SonicLldp_SonicLldp_LLDP_PORT implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicLldp_SonicLldp_LLDP_PORT) IsYANGGoStruct() {}

// NewLLDP_PORT_LIST creates a new entry in the LLDP_PORT_LIST list of the
// SonicLldp_SonicLldp_LLDP_PORT struct. The keys of the list are populated from the input
// arguments.
func (t *SonicLldp_SonicLldp_LLDP_PORT) NewLLDP_PORT_LIST(Ifname string) (*SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LLDP_PORT_LIST == nil {
		t.LLDP_PORT_LIST = make(map[string]*SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST)
	}

	key := Ifname

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LLDP_PORT_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LLDP_PORT_LIST", key)
	}

	t.LLDP_PORT_LIST[key] = &SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST{
		Ifname: &Ifname,
	}

	return t.LLDP_PORT_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLldp_SonicLldp_LLDP_PORT) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicLldp_SonicLldp_LLDP_PORT"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLldp_SonicLldp_LLDP_PORT) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicLldp_SonicLldp_LLDP_PORT) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicLldp_SonicLldp_LLDP_PORT.
func (*SonicLldp_SonicLldp_LLDP_PORT) ΛBelongingModule() string {
	return "sonic-lldp"
}


// SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST represents the /sonic-lldp/sonic-lldp/LLDP_PORT/LLDP_PORT_LIST YANG schema element.
type SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST struct {
	Enabled	*bool	`path:"enabled" module:"sonic-lldp"`
	Ifname	*string	`path:"ifname" module:"sonic-lldp"`
	Mode	E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode	`path:"mode" module:"sonic-lldp"`
}

// IsYANGGoStruct ensures that SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST struct, which is a YANG list entry.
func (t *SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ifname == nil {
		return nil, fmt.Errorf("nil value for key Ifname")
	}

	return map[string]interface{}{
		"ifname": *t.Ifname,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST.
func (*SonicLldp_SonicLldp_LLDP_PORT_LLDP_PORT_LIST) ΛBelongingModule() string {
	return "sonic-lldp"
}


// SonicLoopbackInterface_SonicLoopbackInterface represents the /sonic-loopback-interface/sonic-loopback-interface YANG schema element.
type SonicLoopbackInterface_SonicLoopbackInterface struct {
	LOOPBACK_INTERFACE	*SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE	`path:"LOOPBACK_INTERFACE" module:"sonic-loopback-interface"`
}

// IsYANGGoStruct ensures that SonicLoopbackInterface_SonicLoopbackInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicLoopbackInterface_SonicLoopbackInterface) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLoopbackInterface_SonicLoopbackInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicLoopbackInterface_SonicLoopbackInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLoopbackInterface_SonicLoopbackInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicLoopbackInterface_SonicLoopbackInterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicLoopbackInterface_SonicLoopbackInterface.
func (*SonicLoopbackInterface_SonicLoopbackInterface) ΛBelongingModule() string {
	return "sonic-loopback-interface"
}


// SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE represents the /sonic-loopback-interface/sonic-loopback-interface/LOOPBACK_INTERFACE YANG schema element.
type SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE struct {
	LOOPBACK_INTERFACE_IPPREFIX_LIST	map[SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Key]*SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST	`path:"LOOPBACK_INTERFACE_IPPREFIX_LIST" module:"sonic-loopback-interface"`
	LOOPBACK_INTERFACE_LIST	map[string]*SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST	`path:"LOOPBACK_INTERFACE_LIST" module:"sonic-loopback-interface"`
}

// IsYANGGoStruct ensures that SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE) IsYANGGoStruct() {}

// SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Key represents the key for list LOOPBACK_INTERFACE_IPPREFIX_LIST of element /sonic-loopback-interface/sonic-loopback-interface/LOOPBACK_INTERFACE.
type SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Key struct {
	Name	string	`path:"name"`
	IpPrefix	string	`path:"ip-prefix"`
}

// IsYANGGoKeyStruct ensures that SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Key key struct.
func (t SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
		"ip-prefix": t.IpPrefix,
	}, nil
}

// NewLOOPBACK_INTERFACE_IPPREFIX_LIST creates a new entry in the LOOPBACK_INTERFACE_IPPREFIX_LIST list of the
// SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE) NewLOOPBACK_INTERFACE_IPPREFIX_LIST(Name string, IpPrefix string) (*SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LOOPBACK_INTERFACE_IPPREFIX_LIST == nil {
		t.LOOPBACK_INTERFACE_IPPREFIX_LIST = make(map[SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Key]*SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST)
	}

	key := SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Key{
		Name: Name,
		IpPrefix: IpPrefix,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LOOPBACK_INTERFACE_IPPREFIX_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LOOPBACK_INTERFACE_IPPREFIX_LIST", key)
	}

	t.LOOPBACK_INTERFACE_IPPREFIX_LIST[key] = &SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST{
		Name: &Name,
		IpPrefix: &IpPrefix,
	}

	return t.LOOPBACK_INTERFACE_IPPREFIX_LIST[key], nil
}

// NewLOOPBACK_INTERFACE_LIST creates a new entry in the LOOPBACK_INTERFACE_LIST list of the
// SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE) NewLOOPBACK_INTERFACE_LIST(Name string) (*SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LOOPBACK_INTERFACE_LIST == nil {
		t.LOOPBACK_INTERFACE_LIST = make(map[string]*SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LOOPBACK_INTERFACE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LOOPBACK_INTERFACE_LIST", key)
	}

	t.LOOPBACK_INTERFACE_LIST[key] = &SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST{
		Name: &Name,
	}

	return t.LOOPBACK_INTERFACE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE.
func (*SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE) ΛBelongingModule() string {
	return "sonic-loopback-interface"
}


// SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST represents the /sonic-loopback-interface/sonic-loopback-interface/LOOPBACK_INTERFACE/LOOPBACK_INTERFACE_IPPREFIX_LIST YANG schema element.
type SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST struct {
	Family	E_SonicTypes_IpFamily	`path:"family" module:"sonic-loopback-interface"`
	IpPrefix	*string	`path:"ip-prefix" module:"sonic-loopback-interface"`
	Name	*string	`path:"name" module:"sonic-loopback-interface"`
	Scope	E_SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope	`path:"scope" module:"sonic-loopback-interface"`
}

// IsYANGGoStruct ensures that SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST struct, which is a YANG list entry.
func (t *SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST.
func (*SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST) ΛBelongingModule() string {
	return "sonic-loopback-interface"
}


// SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST represents the /sonic-loopback-interface/sonic-loopback-interface/LOOPBACK_INTERFACE/LOOPBACK_INTERFACE_LIST YANG schema element.
type SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST struct {
	Name	*string	`path:"name" module:"sonic-loopback-interface"`
	NatZone	*uint8	`path:"nat_zone" module:"sonic-loopback-interface"`
	VrfName	*string	`path:"vrf_name" module:"sonic-loopback-interface"`
}

// IsYANGGoStruct ensures that SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST struct, which is a YANG list entry.
func (t *SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST.
func (*SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_LIST) ΛBelongingModule() string {
	return "sonic-loopback-interface"
}


// SonicLosslessTrafficPattern_SonicLosslessTrafficPattern represents the /sonic-lossless-traffic-pattern/sonic-lossless-traffic-pattern YANG schema element.
type SonicLosslessTrafficPattern_SonicLosslessTrafficPattern struct {
	LOSSLESS_TRAFFIC_PATTERN	*SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN	`path:"LOSSLESS_TRAFFIC_PATTERN" module:"sonic-lossless-traffic-pattern"`
}

// IsYANGGoStruct ensures that SonicLosslessTrafficPattern_SonicLosslessTrafficPattern implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicLosslessTrafficPattern_SonicLosslessTrafficPattern) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLosslessTrafficPattern_SonicLosslessTrafficPattern) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicLosslessTrafficPattern_SonicLosslessTrafficPattern"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLosslessTrafficPattern_SonicLosslessTrafficPattern) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicLosslessTrafficPattern_SonicLosslessTrafficPattern) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicLosslessTrafficPattern_SonicLosslessTrafficPattern.
func (*SonicLosslessTrafficPattern_SonicLosslessTrafficPattern) ΛBelongingModule() string {
	return "sonic-lossless-traffic-pattern"
}


// SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN represents the /sonic-lossless-traffic-pattern/sonic-lossless-traffic-pattern/LOSSLESS_TRAFFIC_PATTERN YANG schema element.
type SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN struct {
	LOSSLESS_TRAFFIC_PATTERN_LIST	map[string]*SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST	`path:"LOSSLESS_TRAFFIC_PATTERN_LIST" module:"sonic-lossless-traffic-pattern"`
}

// IsYANGGoStruct ensures that SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN) IsYANGGoStruct() {}

// NewLOSSLESS_TRAFFIC_PATTERN_LIST creates a new entry in the LOSSLESS_TRAFFIC_PATTERN_LIST list of the
// SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN struct. The keys of the list are populated from the input
// arguments.
func (t *SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN) NewLOSSLESS_TRAFFIC_PATTERN_LIST(Name string) (*SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LOSSLESS_TRAFFIC_PATTERN_LIST == nil {
		t.LOSSLESS_TRAFFIC_PATTERN_LIST = make(map[string]*SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LOSSLESS_TRAFFIC_PATTERN_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LOSSLESS_TRAFFIC_PATTERN_LIST", key)
	}

	t.LOSSLESS_TRAFFIC_PATTERN_LIST[key] = &SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST{
		Name: &Name,
	}

	return t.LOSSLESS_TRAFFIC_PATTERN_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN.
func (*SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN) ΛBelongingModule() string {
	return "sonic-lossless-traffic-pattern"
}


// SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST represents the /sonic-lossless-traffic-pattern/sonic-lossless-traffic-pattern/LOSSLESS_TRAFFIC_PATTERN/LOSSLESS_TRAFFIC_PATTERN_LIST YANG schema element.
type SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST struct {
	Mtu	*uint16	`path:"mtu" module:"sonic-lossless-traffic-pattern"`
	Name	*string	`path:"name" module:"sonic-lossless-traffic-pattern"`
	SmallPacketPercentage	*uint8	`path:"small_packet_percentage" module:"sonic-lossless-traffic-pattern"`
}

// IsYANGGoStruct ensures that SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST struct, which is a YANG list entry.
func (t *SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST.
func (*SonicLosslessTrafficPattern_SonicLosslessTrafficPattern_LOSSLESS_TRAFFIC_PATTERN_LOSSLESS_TRAFFIC_PATTERN_LIST) ΛBelongingModule() string {
	return "sonic-lossless-traffic-pattern"
}


// SonicMacsec_SonicMacsec represents the /sonic-macsec/sonic-macsec YANG schema element.
type SonicMacsec_SonicMacsec struct {
	MACSEC_PROFILE	*SonicMacsec_SonicMacsec_MACSEC_PROFILE	`path:"MACSEC_PROFILE" module:"sonic-macsec"`
}

// IsYANGGoStruct ensures that SonicMacsec_SonicMacsec implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMacsec_SonicMacsec) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMacsec_SonicMacsec) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMacsec_SonicMacsec"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMacsec_SonicMacsec) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMacsec_SonicMacsec) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMacsec_SonicMacsec.
func (*SonicMacsec_SonicMacsec) ΛBelongingModule() string {
	return "sonic-macsec"
}


// SonicMacsec_SonicMacsec_MACSEC_PROFILE represents the /sonic-macsec/sonic-macsec/MACSEC_PROFILE YANG schema element.
type SonicMacsec_SonicMacsec_MACSEC_PROFILE struct {
	MACSEC_PROFILE_LIST	map[string]*SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST	`path:"MACSEC_PROFILE_LIST" module:"sonic-macsec"`
}

// IsYANGGoStruct ensures that SonicMacsec_SonicMacsec_MACSEC_PROFILE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMacsec_SonicMacsec_MACSEC_PROFILE) IsYANGGoStruct() {}

// NewMACSEC_PROFILE_LIST creates a new entry in the MACSEC_PROFILE_LIST list of the
// SonicMacsec_SonicMacsec_MACSEC_PROFILE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicMacsec_SonicMacsec_MACSEC_PROFILE) NewMACSEC_PROFILE_LIST(Name string) (*SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MACSEC_PROFILE_LIST == nil {
		t.MACSEC_PROFILE_LIST = make(map[string]*SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MACSEC_PROFILE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MACSEC_PROFILE_LIST", key)
	}

	t.MACSEC_PROFILE_LIST[key] = &SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST{
		Name: &Name,
	}

	return t.MACSEC_PROFILE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMacsec_SonicMacsec_MACSEC_PROFILE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMacsec_SonicMacsec_MACSEC_PROFILE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMacsec_SonicMacsec_MACSEC_PROFILE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMacsec_SonicMacsec_MACSEC_PROFILE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMacsec_SonicMacsec_MACSEC_PROFILE.
func (*SonicMacsec_SonicMacsec_MACSEC_PROFILE) ΛBelongingModule() string {
	return "sonic-macsec"
}


// SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST represents the /sonic-macsec/sonic-macsec/MACSEC_PROFILE/MACSEC_PROFILE_LIST YANG schema element.
type SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST struct {
	CipherSuite	*string	`path:"cipher_suite" module:"sonic-macsec"`
	EnableReplayProtect	*string	`path:"enable_replay_protect" module:"sonic-macsec"`
	FallbackCak	*string	`path:"fallback_cak" module:"sonic-macsec"`
	FallbackCkn	*string	`path:"fallback_ckn" module:"sonic-macsec"`
	Name	*string	`path:"name" module:"sonic-macsec"`
	Policy	*string	`path:"policy" module:"sonic-macsec"`
	PrimaryCak	*string	`path:"primary_cak" module:"sonic-macsec"`
	PrimaryCkn	*string	`path:"primary_ckn" module:"sonic-macsec"`
	Priority	*uint8	`path:"priority" module:"sonic-macsec"`
	RekeyPeriod	*uint32	`path:"rekey_period" module:"sonic-macsec"`
	ReplayWindow	*uint32	`path:"replay_window" module:"sonic-macsec"`
	SendSci	*string	`path:"send_sci" module:"sonic-macsec"`
}

// IsYANGGoStruct ensures that SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST struct, which is a YANG list entry.
func (t *SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST.
func (*SonicMacsec_SonicMacsec_MACSEC_PROFILE_MACSEC_PROFILE_LIST) ΛBelongingModule() string {
	return "sonic-macsec"
}


// SonicMclag_SonicMclag represents the /sonic-mclag/sonic-mclag YANG schema element.
type SonicMclag_SonicMclag struct {
	MCLAG_DOMAIN	*SonicMclag_SonicMclag_MCLAG_DOMAIN	`path:"MCLAG_DOMAIN" module:"sonic-mclag"`
	MCLAG_INTERFACE	*SonicMclag_SonicMclag_MCLAG_INTERFACE	`path:"MCLAG_INTERFACE" module:"sonic-mclag"`
	MCLAG_UNIQUE_IP	*SonicMclag_SonicMclag_MCLAG_UNIQUE_IP	`path:"MCLAG_UNIQUE_IP" module:"sonic-mclag"`
}

// IsYANGGoStruct ensures that SonicMclag_SonicMclag implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMclag_SonicMclag) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMclag_SonicMclag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMclag_SonicMclag) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMclag_SonicMclag.
func (*SonicMclag_SonicMclag) ΛBelongingModule() string {
	return "sonic-mclag"
}


// SonicMclag_SonicMclag_MCLAG_DOMAIN represents the /sonic-mclag/sonic-mclag/MCLAG_DOMAIN YANG schema element.
type SonicMclag_SonicMclag_MCLAG_DOMAIN struct {
	MCLAG_DOMAIN_LIST	map[uint16]*SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST	`path:"MCLAG_DOMAIN_LIST" module:"sonic-mclag"`
}

// IsYANGGoStruct ensures that SonicMclag_SonicMclag_MCLAG_DOMAIN implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMclag_SonicMclag_MCLAG_DOMAIN) IsYANGGoStruct() {}

// NewMCLAG_DOMAIN_LIST creates a new entry in the MCLAG_DOMAIN_LIST list of the
// SonicMclag_SonicMclag_MCLAG_DOMAIN struct. The keys of the list are populated from the input
// arguments.
func (t *SonicMclag_SonicMclag_MCLAG_DOMAIN) NewMCLAG_DOMAIN_LIST(DomainId uint16) (*SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MCLAG_DOMAIN_LIST == nil {
		t.MCLAG_DOMAIN_LIST = make(map[uint16]*SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST)
	}

	key := DomainId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MCLAG_DOMAIN_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MCLAG_DOMAIN_LIST", key)
	}

	t.MCLAG_DOMAIN_LIST[key] = &SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST{
		DomainId: &DomainId,
	}

	return t.MCLAG_DOMAIN_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag_MCLAG_DOMAIN) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMclag_SonicMclag_MCLAG_DOMAIN"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag_MCLAG_DOMAIN) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMclag_SonicMclag_MCLAG_DOMAIN) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMclag_SonicMclag_MCLAG_DOMAIN.
func (*SonicMclag_SonicMclag_MCLAG_DOMAIN) ΛBelongingModule() string {
	return "sonic-mclag"
}


// SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST represents the /sonic-mclag/sonic-mclag/MCLAG_DOMAIN/MCLAG_DOMAIN_LIST YANG schema element.
type SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST struct {
	DomainId	*uint16	`path:"domain_id" module:"sonic-mclag"`
	KeepaliveInterval	*uint16	`path:"keepalive_interval" module:"sonic-mclag"`
	PeerIp	*string	`path:"peer_ip" module:"sonic-mclag"`
	PeerLink	*string	`path:"peer_link" module:"sonic-mclag"`
	SessionTimeout	*uint16	`path:"session_timeout" module:"sonic-mclag"`
	SourceIp	*string	`path:"source_ip" module:"sonic-mclag"`
}

// IsYANGGoStruct ensures that SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST struct, which is a YANG list entry.
func (t *SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.DomainId == nil {
		return nil, fmt.Errorf("nil value for key DomainId")
	}

	return map[string]interface{}{
		"domain_id": *t.DomainId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST.
func (*SonicMclag_SonicMclag_MCLAG_DOMAIN_MCLAG_DOMAIN_LIST) ΛBelongingModule() string {
	return "sonic-mclag"
}


// SonicMclag_SonicMclag_MCLAG_INTERFACE represents the /sonic-mclag/sonic-mclag/MCLAG_INTERFACE YANG schema element.
type SonicMclag_SonicMclag_MCLAG_INTERFACE struct {
	MCLAG_INTERFACE_LIST	map[SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST_Key]*SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST	`path:"MCLAG_INTERFACE_LIST" module:"sonic-mclag"`
}

// IsYANGGoStruct ensures that SonicMclag_SonicMclag_MCLAG_INTERFACE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMclag_SonicMclag_MCLAG_INTERFACE) IsYANGGoStruct() {}

// SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST_Key represents the key for list MCLAG_INTERFACE_LIST of element /sonic-mclag/sonic-mclag/MCLAG_INTERFACE.
type SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST_Key struct {
	DomainId	uint16	`path:"domain_id"`
	IfName	string	`path:"if_name"`
}

// IsYANGGoKeyStruct ensures that SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST_Key key struct.
func (t SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"domain_id": t.DomainId,
		"if_name": t.IfName,
	}, nil
}

// NewMCLAG_INTERFACE_LIST creates a new entry in the MCLAG_INTERFACE_LIST list of the
// SonicMclag_SonicMclag_MCLAG_INTERFACE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicMclag_SonicMclag_MCLAG_INTERFACE) NewMCLAG_INTERFACE_LIST(DomainId uint16, IfName string) (*SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MCLAG_INTERFACE_LIST == nil {
		t.MCLAG_INTERFACE_LIST = make(map[SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST_Key]*SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST)
	}

	key := SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST_Key{
		DomainId: DomainId,
		IfName: IfName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MCLAG_INTERFACE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MCLAG_INTERFACE_LIST", key)
	}

	t.MCLAG_INTERFACE_LIST[key] = &SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST{
		DomainId: &DomainId,
		IfName: &IfName,
	}

	return t.MCLAG_INTERFACE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag_MCLAG_INTERFACE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMclag_SonicMclag_MCLAG_INTERFACE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag_MCLAG_INTERFACE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMclag_SonicMclag_MCLAG_INTERFACE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMclag_SonicMclag_MCLAG_INTERFACE.
func (*SonicMclag_SonicMclag_MCLAG_INTERFACE) ΛBelongingModule() string {
	return "sonic-mclag"
}


// SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST represents the /sonic-mclag/sonic-mclag/MCLAG_INTERFACE/MCLAG_INTERFACE_LIST YANG schema element.
type SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST struct {
	DomainId	*uint16	`path:"domain_id" module:"sonic-mclag"`
	IfName	*string	`path:"if_name" module:"sonic-mclag"`
	IfType	*string	`path:"if_type" module:"sonic-mclag"`
}

// IsYANGGoStruct ensures that SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST struct, which is a YANG list entry.
func (t *SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.DomainId == nil {
		return nil, fmt.Errorf("nil value for key DomainId")
	}

	if t.IfName == nil {
		return nil, fmt.Errorf("nil value for key IfName")
	}

	return map[string]interface{}{
		"domain_id": *t.DomainId,
		"if_name": *t.IfName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST.
func (*SonicMclag_SonicMclag_MCLAG_INTERFACE_MCLAG_INTERFACE_LIST) ΛBelongingModule() string {
	return "sonic-mclag"
}


// SonicMclag_SonicMclag_MCLAG_UNIQUE_IP represents the /sonic-mclag/sonic-mclag/MCLAG_UNIQUE_IP YANG schema element.
type SonicMclag_SonicMclag_MCLAG_UNIQUE_IP struct {
	MCLAG_UNIQUE_IP_LIST	map[string]*SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST	`path:"MCLAG_UNIQUE_IP_LIST" module:"sonic-mclag"`
}

// IsYANGGoStruct ensures that SonicMclag_SonicMclag_MCLAG_UNIQUE_IP implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMclag_SonicMclag_MCLAG_UNIQUE_IP) IsYANGGoStruct() {}

// NewMCLAG_UNIQUE_IP_LIST creates a new entry in the MCLAG_UNIQUE_IP_LIST list of the
// SonicMclag_SonicMclag_MCLAG_UNIQUE_IP struct. The keys of the list are populated from the input
// arguments.
func (t *SonicMclag_SonicMclag_MCLAG_UNIQUE_IP) NewMCLAG_UNIQUE_IP_LIST(IfName string) (*SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MCLAG_UNIQUE_IP_LIST == nil {
		t.MCLAG_UNIQUE_IP_LIST = make(map[string]*SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST)
	}

	key := IfName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MCLAG_UNIQUE_IP_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MCLAG_UNIQUE_IP_LIST", key)
	}

	t.MCLAG_UNIQUE_IP_LIST[key] = &SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST{
		IfName: &IfName,
	}

	return t.MCLAG_UNIQUE_IP_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag_MCLAG_UNIQUE_IP) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMclag_SonicMclag_MCLAG_UNIQUE_IP"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag_MCLAG_UNIQUE_IP) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMclag_SonicMclag_MCLAG_UNIQUE_IP) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMclag_SonicMclag_MCLAG_UNIQUE_IP.
func (*SonicMclag_SonicMclag_MCLAG_UNIQUE_IP) ΛBelongingModule() string {
	return "sonic-mclag"
}


// SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST represents the /sonic-mclag/sonic-mclag/MCLAG_UNIQUE_IP/MCLAG_UNIQUE_IP_LIST YANG schema element.
type SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST struct {
	IfName	*string	`path:"if_name" module:"sonic-mclag"`
	UniqueIp	E_SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp	`path:"unique_ip" module:"sonic-mclag"`
}

// IsYANGGoStruct ensures that SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST struct, which is a YANG list entry.
func (t *SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IfName == nil {
		return nil, fmt.Errorf("nil value for key IfName")
	}

	return map[string]interface{}{
		"if_name": *t.IfName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST.
func (*SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST) ΛBelongingModule() string {
	return "sonic-mclag"
}


// SonicMgmtInterface_SonicMgmtInterface represents the /sonic-mgmt_interface/sonic-mgmt_interface YANG schema element.
type SonicMgmtInterface_SonicMgmtInterface struct {
	MGMT_INTERFACE	*SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE	`path:"MGMT_INTERFACE" module:"sonic-mgmt_interface"`
}

// IsYANGGoStruct ensures that SonicMgmtInterface_SonicMgmtInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMgmtInterface_SonicMgmtInterface) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtInterface_SonicMgmtInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMgmtInterface_SonicMgmtInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtInterface_SonicMgmtInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMgmtInterface_SonicMgmtInterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMgmtInterface_SonicMgmtInterface.
func (*SonicMgmtInterface_SonicMgmtInterface) ΛBelongingModule() string {
	return "sonic-mgmt_interface"
}


// SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE represents the /sonic-mgmt_interface/sonic-mgmt_interface/MGMT_INTERFACE YANG schema element.
type SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE struct {
	MGMT_INTERFACE_LIST	map[SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST_Key]*SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST	`path:"MGMT_INTERFACE_LIST" module:"sonic-mgmt_interface"`
}

// IsYANGGoStruct ensures that SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE) IsYANGGoStruct() {}

// SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST_Key represents the key for list MGMT_INTERFACE_LIST of element /sonic-mgmt_interface/sonic-mgmt_interface/MGMT_INTERFACE.
type SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST_Key struct {
	Name	string	`path:"name"`
	IpPrefix	string	`path:"ip_prefix"`
}

// IsYANGGoKeyStruct ensures that SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST_Key key struct.
func (t SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
		"ip_prefix": t.IpPrefix,
	}, nil
}

// NewMGMT_INTERFACE_LIST creates a new entry in the MGMT_INTERFACE_LIST list of the
// SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE) NewMGMT_INTERFACE_LIST(Name string, IpPrefix string) (*SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MGMT_INTERFACE_LIST == nil {
		t.MGMT_INTERFACE_LIST = make(map[SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST_Key]*SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST)
	}

	key := SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST_Key{
		Name: Name,
		IpPrefix: IpPrefix,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MGMT_INTERFACE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MGMT_INTERFACE_LIST", key)
	}

	t.MGMT_INTERFACE_LIST[key] = &SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST{
		Name: &Name,
		IpPrefix: &IpPrefix,
	}

	return t.MGMT_INTERFACE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE.
func (*SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE) ΛBelongingModule() string {
	return "sonic-mgmt_interface"
}


// SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST represents the /sonic-mgmt_interface/sonic-mgmt_interface/MGMT_INTERFACE/MGMT_INTERFACE_LIST YANG schema element.
type SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST struct {
	ForcedMgmtRoutes	[]string	`path:"forced_mgmt_routes" module:"sonic-mgmt_interface"`
	Gwaddr	*string	`path:"gwaddr" module:"sonic-mgmt_interface"`
	IpPrefix	*string	`path:"ip_prefix" module:"sonic-mgmt_interface"`
	Name	*string	`path:"name" module:"sonic-mgmt_interface"`
}

// IsYANGGoStruct ensures that SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST struct, which is a YANG list entry.
func (t *SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"ip_prefix": *t.IpPrefix,
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST.
func (*SonicMgmtInterface_SonicMgmtInterface_MGMT_INTERFACE_MGMT_INTERFACE_LIST) ΛBelongingModule() string {
	return "sonic-mgmt_interface"
}


// SonicMgmtPort_SonicMgmtPort represents the /sonic-mgmt_port/sonic-mgmt_port YANG schema element.
type SonicMgmtPort_SonicMgmtPort struct {
	MGMT_PORT	*SonicMgmtPort_SonicMgmtPort_MGMT_PORT	`path:"MGMT_PORT" module:"sonic-mgmt_port"`
}

// IsYANGGoStruct ensures that SonicMgmtPort_SonicMgmtPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMgmtPort_SonicMgmtPort) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtPort_SonicMgmtPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMgmtPort_SonicMgmtPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtPort_SonicMgmtPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMgmtPort_SonicMgmtPort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMgmtPort_SonicMgmtPort.
func (*SonicMgmtPort_SonicMgmtPort) ΛBelongingModule() string {
	return "sonic-mgmt_port"
}


// SonicMgmtPort_SonicMgmtPort_MGMT_PORT represents the /sonic-mgmt_port/sonic-mgmt_port/MGMT_PORT YANG schema element.
type SonicMgmtPort_SonicMgmtPort_MGMT_PORT struct {
	MGMT_PORT_LIST	map[string]*SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST	`path:"MGMT_PORT_LIST" module:"sonic-mgmt_port"`
}

// IsYANGGoStruct ensures that SonicMgmtPort_SonicMgmtPort_MGMT_PORT implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMgmtPort_SonicMgmtPort_MGMT_PORT) IsYANGGoStruct() {}

// NewMGMT_PORT_LIST creates a new entry in the MGMT_PORT_LIST list of the
// SonicMgmtPort_SonicMgmtPort_MGMT_PORT struct. The keys of the list are populated from the input
// arguments.
func (t *SonicMgmtPort_SonicMgmtPort_MGMT_PORT) NewMGMT_PORT_LIST(Name string) (*SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MGMT_PORT_LIST == nil {
		t.MGMT_PORT_LIST = make(map[string]*SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MGMT_PORT_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MGMT_PORT_LIST", key)
	}

	t.MGMT_PORT_LIST[key] = &SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST{
		Name: &Name,
	}

	return t.MGMT_PORT_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtPort_SonicMgmtPort_MGMT_PORT) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMgmtPort_SonicMgmtPort_MGMT_PORT"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtPort_SonicMgmtPort_MGMT_PORT) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMgmtPort_SonicMgmtPort_MGMT_PORT) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMgmtPort_SonicMgmtPort_MGMT_PORT.
func (*SonicMgmtPort_SonicMgmtPort_MGMT_PORT) ΛBelongingModule() string {
	return "sonic-mgmt_port"
}


// SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST represents the /sonic-mgmt_port/sonic-mgmt_port/MGMT_PORT/MGMT_PORT_LIST YANG schema element.
type SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST struct {
	AdminStatus	E_SonicTypes_AdminStatus	`path:"admin_status" module:"sonic-mgmt_port"`
	Alias	*string	`path:"alias" module:"sonic-mgmt_port"`
	Autoneg	*string	`path:"autoneg" module:"sonic-mgmt_port"`
	Description	*string	`path:"description" module:"sonic-mgmt_port"`
	Mtu	*uint16	`path:"mtu" module:"sonic-mgmt_port"`
	Name	*string	`path:"name" module:"sonic-mgmt_port"`
	Speed	*uint16	`path:"speed" module:"sonic-mgmt_port"`
}

// IsYANGGoStruct ensures that SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST struct, which is a YANG list entry.
func (t *SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST.
func (*SonicMgmtPort_SonicMgmtPort_MGMT_PORT_MGMT_PORT_LIST) ΛBelongingModule() string {
	return "sonic-mgmt_port"
}


// SonicMgmtVrf_SonicMgmtVrf represents the /sonic-mgmt_vrf/sonic-mgmt_vrf YANG schema element.
type SonicMgmtVrf_SonicMgmtVrf struct {
	MGMT_VRF_CONFIG	*SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG	`path:"MGMT_VRF_CONFIG" module:"sonic-mgmt_vrf"`
}

// IsYANGGoStruct ensures that SonicMgmtVrf_SonicMgmtVrf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMgmtVrf_SonicMgmtVrf) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtVrf_SonicMgmtVrf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMgmtVrf_SonicMgmtVrf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtVrf_SonicMgmtVrf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMgmtVrf_SonicMgmtVrf) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMgmtVrf_SonicMgmtVrf.
func (*SonicMgmtVrf_SonicMgmtVrf) ΛBelongingModule() string {
	return "sonic-mgmt_vrf"
}


// SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG represents the /sonic-mgmt_vrf/sonic-mgmt_vrf/MGMT_VRF_CONFIG YANG schema element.
type SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG struct {
	VrfGlobal	*SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG_VrfGlobal	`path:"vrf_global" module:"sonic-mgmt_vrf"`
}

// IsYANGGoStruct ensures that SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG.
func (*SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG) ΛBelongingModule() string {
	return "sonic-mgmt_vrf"
}


// SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG_VrfGlobal represents the /sonic-mgmt_vrf/sonic-mgmt_vrf/MGMT_VRF_CONFIG/vrf_global YANG schema element.
type SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG_VrfGlobal struct {
	MgmtVrfEnabled	*bool	`path:"mgmtVrfEnabled" module:"sonic-mgmt_vrf"`
}

// IsYANGGoStruct ensures that SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG_VrfGlobal implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG_VrfGlobal) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG_VrfGlobal) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG_VrfGlobal"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG_VrfGlobal) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG_VrfGlobal) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG_VrfGlobal.
func (*SonicMgmtVrf_SonicMgmtVrf_MGMT_VRF_CONFIG_VrfGlobal) ΛBelongingModule() string {
	return "sonic-mgmt_vrf"
}


// SonicMuxCable_SonicMuxCable represents the /sonic-mux-cable/sonic-mux-cable YANG schema element.
type SonicMuxCable_SonicMuxCable struct {
	MUX_CABLE	*SonicMuxCable_SonicMuxCable_MUX_CABLE	`path:"MUX_CABLE" module:"sonic-mux-cable"`
}

// IsYANGGoStruct ensures that SonicMuxCable_SonicMuxCable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMuxCable_SonicMuxCable) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMuxCable_SonicMuxCable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMuxCable_SonicMuxCable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMuxCable_SonicMuxCable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMuxCable_SonicMuxCable) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMuxCable_SonicMuxCable.
func (*SonicMuxCable_SonicMuxCable) ΛBelongingModule() string {
	return "sonic-mux-cable"
}


// SonicMuxCable_SonicMuxCable_MUX_CABLE represents the /sonic-mux-cable/sonic-mux-cable/MUX_CABLE YANG schema element.
type SonicMuxCable_SonicMuxCable_MUX_CABLE struct {
	MUX_CABLE_LIST	map[string]*SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST	`path:"MUX_CABLE_LIST" module:"sonic-mux-cable"`
}

// IsYANGGoStruct ensures that SonicMuxCable_SonicMuxCable_MUX_CABLE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMuxCable_SonicMuxCable_MUX_CABLE) IsYANGGoStruct() {}

// NewMUX_CABLE_LIST creates a new entry in the MUX_CABLE_LIST list of the
// SonicMuxCable_SonicMuxCable_MUX_CABLE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicMuxCable_SonicMuxCable_MUX_CABLE) NewMUX_CABLE_LIST(Ifname string) (*SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MUX_CABLE_LIST == nil {
		t.MUX_CABLE_LIST = make(map[string]*SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST)
	}

	key := Ifname

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MUX_CABLE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MUX_CABLE_LIST", key)
	}

	t.MUX_CABLE_LIST[key] = &SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST{
		Ifname: &Ifname,
	}

	return t.MUX_CABLE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMuxCable_SonicMuxCable_MUX_CABLE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMuxCable_SonicMuxCable_MUX_CABLE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMuxCable_SonicMuxCable_MUX_CABLE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMuxCable_SonicMuxCable_MUX_CABLE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMuxCable_SonicMuxCable_MUX_CABLE.
func (*SonicMuxCable_SonicMuxCable_MUX_CABLE) ΛBelongingModule() string {
	return "sonic-mux-cable"
}


// SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST represents the /sonic-mux-cable/sonic-mux-cable/MUX_CABLE/MUX_CABLE_LIST YANG schema element.
type SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST struct {
	CableType	E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType	`path:"cable_type" module:"sonic-mux-cable"`
	Ifname	*string	`path:"ifname" module:"sonic-mux-cable"`
	ServerIpv4	*string	`path:"server_ipv4" module:"sonic-mux-cable"`
	ServerIpv6	*string	`path:"server_ipv6" module:"sonic-mux-cable"`
	SocIpv4	*string	`path:"soc_ipv4" module:"sonic-mux-cable"`
	SocIpv6	*string	`path:"soc_ipv6" module:"sonic-mux-cable"`
	State	E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State	`path:"state" module:"sonic-mux-cable"`
}

// IsYANGGoStruct ensures that SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST struct, which is a YANG list entry.
func (t *SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ifname == nil {
		return nil, fmt.Errorf("nil value for key Ifname")
	}

	return map[string]interface{}{
		"ifname": *t.Ifname,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST.
func (*SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST) ΛBelongingModule() string {
	return "sonic-mux-cable"
}


// SonicNat_SonicNat represents the /sonic-nat/sonic-nat YANG schema element.
type SonicNat_SonicNat struct {
	NAT_BINDINGS	*SonicNat_SonicNat_NAT_BINDINGS	`path:"NAT_BINDINGS" module:"sonic-nat"`
	NAT_GLOBAL	*SonicNat_SonicNat_NAT_GLOBAL	`path:"NAT_GLOBAL" module:"sonic-nat"`
	NAT_POOL	*SonicNat_SonicNat_NAT_POOL	`path:"NAT_POOL" module:"sonic-nat"`
	STATIC_NAPT	*SonicNat_SonicNat_STATIC_NAPT	`path:"STATIC_NAPT" module:"sonic-nat"`
	STATIC_NAT	*SonicNat_SonicNat_STATIC_NAT	`path:"STATIC_NAT" module:"sonic-nat"`
}

// IsYANGGoStruct ensures that SonicNat_SonicNat implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNat_SonicNat) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNat_SonicNat"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNat_SonicNat) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNat_SonicNat.
func (*SonicNat_SonicNat) ΛBelongingModule() string {
	return "sonic-nat"
}


// SonicNat_SonicNat_NAT_BINDINGS represents the /sonic-nat/sonic-nat/NAT_BINDINGS YANG schema element.
type SonicNat_SonicNat_NAT_BINDINGS struct {
	NAT_BINDINGS_LIST	map[string]*SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST	`path:"NAT_BINDINGS_LIST" module:"sonic-nat"`
}

// IsYANGGoStruct ensures that SonicNat_SonicNat_NAT_BINDINGS implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNat_SonicNat_NAT_BINDINGS) IsYANGGoStruct() {}

// NewNAT_BINDINGS_LIST creates a new entry in the NAT_BINDINGS_LIST list of the
// SonicNat_SonicNat_NAT_BINDINGS struct. The keys of the list are populated from the input
// arguments.
func (t *SonicNat_SonicNat_NAT_BINDINGS) NewNAT_BINDINGS_LIST(Name string) (*SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NAT_BINDINGS_LIST == nil {
		t.NAT_BINDINGS_LIST = make(map[string]*SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NAT_BINDINGS_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NAT_BINDINGS_LIST", key)
	}

	t.NAT_BINDINGS_LIST[key] = &SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST{
		Name: &Name,
	}

	return t.NAT_BINDINGS_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_NAT_BINDINGS) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNat_SonicNat_NAT_BINDINGS"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_NAT_BINDINGS) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNat_SonicNat_NAT_BINDINGS) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNat_SonicNat_NAT_BINDINGS.
func (*SonicNat_SonicNat_NAT_BINDINGS) ΛBelongingModule() string {
	return "sonic-nat"
}


// SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST represents the /sonic-nat/sonic-nat/NAT_BINDINGS/NAT_BINDINGS_LIST YANG schema element.
type SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST struct {
	Name	*string	`path:"name" module:"sonic-nat"`
	NatPool	*string	`path:"nat_pool" module:"sonic-nat"`
	NatType	E_SonicNat_NatType	`path:"nat_type" module:"sonic-nat"`
	TwiceNatId	*uint16	`path:"twice_nat_id" module:"sonic-nat"`
}

// IsYANGGoStruct ensures that SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST struct, which is a YANG list entry.
func (t *SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST.
func (*SonicNat_SonicNat_NAT_BINDINGS_NAT_BINDINGS_LIST) ΛBelongingModule() string {
	return "sonic-nat"
}


// SonicNat_SonicNat_NAT_GLOBAL represents the /sonic-nat/sonic-nat/NAT_GLOBAL YANG schema element.
type SonicNat_SonicNat_NAT_GLOBAL struct {
	Values	*SonicNat_SonicNat_NAT_GLOBAL_Values	`path:"Values" module:"sonic-nat"`
}

// IsYANGGoStruct ensures that SonicNat_SonicNat_NAT_GLOBAL implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNat_SonicNat_NAT_GLOBAL) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_NAT_GLOBAL) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNat_SonicNat_NAT_GLOBAL"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_NAT_GLOBAL) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNat_SonicNat_NAT_GLOBAL) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNat_SonicNat_NAT_GLOBAL.
func (*SonicNat_SonicNat_NAT_GLOBAL) ΛBelongingModule() string {
	return "sonic-nat"
}


// SonicNat_SonicNat_NAT_GLOBAL_Values represents the /sonic-nat/sonic-nat/NAT_GLOBAL/Values YANG schema element.
type SonicNat_SonicNat_NAT_GLOBAL_Values struct {
	AdminMode	E_SonicTypes_AdminMode	`path:"admin_mode" module:"sonic-nat"`
	NatTcpTimeout	*uint32	`path:"nat_tcp_timeout" module:"sonic-nat"`
	NatTimeout	*uint32	`path:"nat_timeout" module:"sonic-nat"`
	NatUdpTimeout	*uint16	`path:"nat_udp_timeout" module:"sonic-nat"`
}

// IsYANGGoStruct ensures that SonicNat_SonicNat_NAT_GLOBAL_Values implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNat_SonicNat_NAT_GLOBAL_Values) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_NAT_GLOBAL_Values) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNat_SonicNat_NAT_GLOBAL_Values"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_NAT_GLOBAL_Values) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNat_SonicNat_NAT_GLOBAL_Values) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNat_SonicNat_NAT_GLOBAL_Values.
func (*SonicNat_SonicNat_NAT_GLOBAL_Values) ΛBelongingModule() string {
	return "sonic-nat"
}


// SonicNat_SonicNat_NAT_POOL represents the /sonic-nat/sonic-nat/NAT_POOL YANG schema element.
type SonicNat_SonicNat_NAT_POOL struct {
	NAT_POOL_LIST	map[string]*SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST	`path:"NAT_POOL_LIST" module:"sonic-nat"`
}

// IsYANGGoStruct ensures that SonicNat_SonicNat_NAT_POOL implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNat_SonicNat_NAT_POOL) IsYANGGoStruct() {}

// NewNAT_POOL_LIST creates a new entry in the NAT_POOL_LIST list of the
// SonicNat_SonicNat_NAT_POOL struct. The keys of the list are populated from the input
// arguments.
func (t *SonicNat_SonicNat_NAT_POOL) NewNAT_POOL_LIST(Name string) (*SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NAT_POOL_LIST == nil {
		t.NAT_POOL_LIST = make(map[string]*SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NAT_POOL_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NAT_POOL_LIST", key)
	}

	t.NAT_POOL_LIST[key] = &SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST{
		Name: &Name,
	}

	return t.NAT_POOL_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_NAT_POOL) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNat_SonicNat_NAT_POOL"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_NAT_POOL) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNat_SonicNat_NAT_POOL) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNat_SonicNat_NAT_POOL.
func (*SonicNat_SonicNat_NAT_POOL) ΛBelongingModule() string {
	return "sonic-nat"
}


// SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST represents the /sonic-nat/sonic-nat/NAT_POOL/NAT_POOL_LIST YANG schema element.
type SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST struct {
	Name	*string	`path:"name" module:"sonic-nat"`
	NatIp	*string	`path:"nat_ip" module:"sonic-nat"`
	NatPort	*string	`path:"nat_port" module:"sonic-nat"`
}

// IsYANGGoStruct ensures that SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST struct, which is a YANG list entry.
func (t *SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST.
func (*SonicNat_SonicNat_NAT_POOL_NAT_POOL_LIST) ΛBelongingModule() string {
	return "sonic-nat"
}


// SonicNat_SonicNat_STATIC_NAPT represents the /sonic-nat/sonic-nat/STATIC_NAPT YANG schema element.
type SonicNat_SonicNat_STATIC_NAPT struct {
	STATIC_NAPT_LIST	map[SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST_Key]*SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST	`path:"STATIC_NAPT_LIST" module:"sonic-nat"`
}

// IsYANGGoStruct ensures that SonicNat_SonicNat_STATIC_NAPT implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNat_SonicNat_STATIC_NAPT) IsYANGGoStruct() {}

// SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST_Key represents the key for list STATIC_NAPT_LIST of element /sonic-nat/sonic-nat/STATIC_NAPT.
type SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST_Key struct {
	GlobalIp	string	`path:"global_ip"`
	IpProtocol	E_SonicTypes_IpProtocolType	`path:"ip_protocol"`
	GlobalL4Port	uint16	`path:"global_l4_port"`
}

// IsYANGGoKeyStruct ensures that SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST_Key key struct.
func (t SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"global_ip": t.GlobalIp,
		"ip_protocol": t.IpProtocol,
		"global_l4_port": t.GlobalL4Port,
	}, nil
}

// NewSTATIC_NAPT_LIST creates a new entry in the STATIC_NAPT_LIST list of the
// SonicNat_SonicNat_STATIC_NAPT struct. The keys of the list are populated from the input
// arguments.
func (t *SonicNat_SonicNat_STATIC_NAPT) NewSTATIC_NAPT_LIST(GlobalIp string, IpProtocol E_SonicTypes_IpProtocolType, GlobalL4Port uint16) (*SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.STATIC_NAPT_LIST == nil {
		t.STATIC_NAPT_LIST = make(map[SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST_Key]*SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST)
	}

	key := SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST_Key{
		GlobalIp: GlobalIp,
		IpProtocol: IpProtocol,
		GlobalL4Port: GlobalL4Port,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.STATIC_NAPT_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list STATIC_NAPT_LIST", key)
	}

	t.STATIC_NAPT_LIST[key] = &SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST{
		GlobalIp: &GlobalIp,
		IpProtocol: IpProtocol,
		GlobalL4Port: &GlobalL4Port,
	}

	return t.STATIC_NAPT_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_STATIC_NAPT) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNat_SonicNat_STATIC_NAPT"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_STATIC_NAPT) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNat_SonicNat_STATIC_NAPT) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNat_SonicNat_STATIC_NAPT.
func (*SonicNat_SonicNat_STATIC_NAPT) ΛBelongingModule() string {
	return "sonic-nat"
}


// SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST represents the /sonic-nat/sonic-nat/STATIC_NAPT/STATIC_NAPT_LIST YANG schema element.
type SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST struct {
	GlobalIp	*string	`path:"global_ip" module:"sonic-nat"`
	GlobalL4Port	*uint16	`path:"global_l4_port" module:"sonic-nat"`
	IpProtocol	E_SonicTypes_IpProtocolType	`path:"ip_protocol" module:"sonic-nat"`
	LocalIp	*string	`path:"local_ip" module:"sonic-nat"`
	LocalPort	*uint16	`path:"local_port" module:"sonic-nat"`
	NatType	E_SonicNat_NatType	`path:"nat_type" module:"sonic-nat"`
	TwiceNatId	*uint16	`path:"twice_nat_id" module:"sonic-nat"`
}

// IsYANGGoStruct ensures that SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST struct, which is a YANG list entry.
func (t *SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.GlobalIp == nil {
		return nil, fmt.Errorf("nil value for key GlobalIp")
	}

	if t.GlobalL4Port == nil {
		return nil, fmt.Errorf("nil value for key GlobalL4Port")
	}


	return map[string]interface{}{
		"global_ip": *t.GlobalIp,
		"global_l4_port": *t.GlobalL4Port,
		"ip_protocol": t.IpProtocol,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST.
func (*SonicNat_SonicNat_STATIC_NAPT_STATIC_NAPT_LIST) ΛBelongingModule() string {
	return "sonic-nat"
}


// SonicNat_SonicNat_STATIC_NAT represents the /sonic-nat/sonic-nat/STATIC_NAT YANG schema element.
type SonicNat_SonicNat_STATIC_NAT struct {
	STATIC_NAT_LIST	map[string]*SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST	`path:"STATIC_NAT_LIST" module:"sonic-nat"`
}

// IsYANGGoStruct ensures that SonicNat_SonicNat_STATIC_NAT implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNat_SonicNat_STATIC_NAT) IsYANGGoStruct() {}

// NewSTATIC_NAT_LIST creates a new entry in the STATIC_NAT_LIST list of the
// SonicNat_SonicNat_STATIC_NAT struct. The keys of the list are populated from the input
// arguments.
func (t *SonicNat_SonicNat_STATIC_NAT) NewSTATIC_NAT_LIST(GlobalIp string) (*SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.STATIC_NAT_LIST == nil {
		t.STATIC_NAT_LIST = make(map[string]*SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST)
	}

	key := GlobalIp

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.STATIC_NAT_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list STATIC_NAT_LIST", key)
	}

	t.STATIC_NAT_LIST[key] = &SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST{
		GlobalIp: &GlobalIp,
	}

	return t.STATIC_NAT_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_STATIC_NAT) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNat_SonicNat_STATIC_NAT"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_STATIC_NAT) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNat_SonicNat_STATIC_NAT) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNat_SonicNat_STATIC_NAT.
func (*SonicNat_SonicNat_STATIC_NAT) ΛBelongingModule() string {
	return "sonic-nat"
}


// SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST represents the /sonic-nat/sonic-nat/STATIC_NAT/STATIC_NAT_LIST YANG schema element.
type SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST struct {
	GlobalIp	*string	`path:"global_ip" module:"sonic-nat"`
	LocalIp	*string	`path:"local_ip" module:"sonic-nat"`
	NatType	E_SonicNat_NatType	`path:"nat_type" module:"sonic-nat"`
	TwiceNatId	*uint16	`path:"twice_nat_id" module:"sonic-nat"`
}

// IsYANGGoStruct ensures that SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST struct, which is a YANG list entry.
func (t *SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.GlobalIp == nil {
		return nil, fmt.Errorf("nil value for key GlobalIp")
	}

	return map[string]interface{}{
		"global_ip": *t.GlobalIp,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST.
func (*SonicNat_SonicNat_STATIC_NAT_STATIC_NAT_LIST) ΛBelongingModule() string {
	return "sonic-nat"
}


// SonicNtp_SonicNtp represents the /sonic-ntp/sonic-ntp YANG schema element.
type SonicNtp_SonicNtp struct {
	NTP	*SonicNtp_SonicNtp_NTP	`path:"NTP" module:"sonic-ntp"`
	NTP_SERVER	*SonicNtp_SonicNtp_NTP_SERVER	`path:"NTP_SERVER" module:"sonic-ntp"`
}

// IsYANGGoStruct ensures that SonicNtp_SonicNtp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNtp_SonicNtp) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNtp_SonicNtp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNtp_SonicNtp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNtp_SonicNtp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNtp_SonicNtp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNtp_SonicNtp.
func (*SonicNtp_SonicNtp) ΛBelongingModule() string {
	return "sonic-ntp"
}


// SonicNtp_SonicNtp_NTP represents the /sonic-ntp/sonic-ntp/NTP YANG schema element.
type SonicNtp_SonicNtp_NTP struct {
	Global	*SonicNtp_SonicNtp_NTP_Global	`path:"global" module:"sonic-ntp"`
}

// IsYANGGoStruct ensures that SonicNtp_SonicNtp_NTP implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNtp_SonicNtp_NTP) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNtp_SonicNtp_NTP) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNtp_SonicNtp_NTP"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNtp_SonicNtp_NTP) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNtp_SonicNtp_NTP) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNtp_SonicNtp_NTP.
func (*SonicNtp_SonicNtp_NTP) ΛBelongingModule() string {
	return "sonic-ntp"
}


// SonicNtp_SonicNtp_NTP_Global represents the /sonic-ntp/sonic-ntp/NTP/global YANG schema element.
type SonicNtp_SonicNtp_NTP_Global struct {
	SrcIntf	[]string	`path:"src_intf" module:"sonic-ntp"`
	Vrf	*string	`path:"vrf" module:"sonic-ntp"`
}

// IsYANGGoStruct ensures that SonicNtp_SonicNtp_NTP_Global implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNtp_SonicNtp_NTP_Global) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNtp_SonicNtp_NTP_Global) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNtp_SonicNtp_NTP_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNtp_SonicNtp_NTP_Global) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNtp_SonicNtp_NTP_Global) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNtp_SonicNtp_NTP_Global.
func (*SonicNtp_SonicNtp_NTP_Global) ΛBelongingModule() string {
	return "sonic-ntp"
}


// SonicNtp_SonicNtp_NTP_SERVER represents the /sonic-ntp/sonic-ntp/NTP_SERVER YANG schema element.
type SonicNtp_SonicNtp_NTP_SERVER struct {
	NTP_SERVER_LIST	map[string]*SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST	`path:"NTP_SERVER_LIST" module:"sonic-ntp"`
}

// IsYANGGoStruct ensures that SonicNtp_SonicNtp_NTP_SERVER implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNtp_SonicNtp_NTP_SERVER) IsYANGGoStruct() {}

// NewNTP_SERVER_LIST creates a new entry in the NTP_SERVER_LIST list of the
// SonicNtp_SonicNtp_NTP_SERVER struct. The keys of the list are populated from the input
// arguments.
func (t *SonicNtp_SonicNtp_NTP_SERVER) NewNTP_SERVER_LIST(ServerAddress string) (*SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NTP_SERVER_LIST == nil {
		t.NTP_SERVER_LIST = make(map[string]*SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST)
	}

	key := ServerAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NTP_SERVER_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NTP_SERVER_LIST", key)
	}

	t.NTP_SERVER_LIST[key] = &SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST{
		ServerAddress: &ServerAddress,
	}

	return t.NTP_SERVER_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNtp_SonicNtp_NTP_SERVER) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNtp_SonicNtp_NTP_SERVER"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNtp_SonicNtp_NTP_SERVER) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNtp_SonicNtp_NTP_SERVER) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNtp_SonicNtp_NTP_SERVER.
func (*SonicNtp_SonicNtp_NTP_SERVER) ΛBelongingModule() string {
	return "sonic-ntp"
}


// SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST represents the /sonic-ntp/sonic-ntp/NTP_SERVER/NTP_SERVER_LIST YANG schema element.
type SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST struct {
	ServerAddress	*string	`path:"server_address" module:"sonic-ntp"`
}

// IsYANGGoStruct ensures that SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST struct, which is a YANG list entry.
func (t *SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ServerAddress == nil {
		return nil, fmt.Errorf("nil value for key ServerAddress")
	}

	return map[string]interface{}{
		"server_address": *t.ServerAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST.
func (*SonicNtp_SonicNtp_NTP_SERVER_NTP_SERVER_LIST) ΛBelongingModule() string {
	return "sonic-ntp"
}


// SonicNvgreTunnel_SonicNvgreTunnel represents the /sonic-nvgre-tunnel/sonic-nvgre-tunnel YANG schema element.
type SonicNvgreTunnel_SonicNvgreTunnel struct {
	NVGRE_TUNNEL	*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL	`path:"NVGRE_TUNNEL" module:"sonic-nvgre-tunnel"`
	NVGRE_TUNNEL_MAP	*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP	`path:"NVGRE_TUNNEL_MAP" module:"sonic-nvgre-tunnel"`
}

// IsYANGGoStruct ensures that SonicNvgreTunnel_SonicNvgreTunnel implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNvgreTunnel_SonicNvgreTunnel) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNvgreTunnel_SonicNvgreTunnel) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNvgreTunnel_SonicNvgreTunnel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNvgreTunnel_SonicNvgreTunnel) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNvgreTunnel_SonicNvgreTunnel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNvgreTunnel_SonicNvgreTunnel.
func (*SonicNvgreTunnel_SonicNvgreTunnel) ΛBelongingModule() string {
	return "sonic-nvgre-tunnel"
}


// SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL represents the /sonic-nvgre-tunnel/sonic-nvgre-tunnel/NVGRE_TUNNEL YANG schema element.
type SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL struct {
	NVGRE_TUNNEL_LIST	map[string]*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST	`path:"NVGRE_TUNNEL_LIST" module:"sonic-nvgre-tunnel"`
}

// IsYANGGoStruct ensures that SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL) IsYANGGoStruct() {}

// NewNVGRE_TUNNEL_LIST creates a new entry in the NVGRE_TUNNEL_LIST list of the
// SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL struct. The keys of the list are populated from the input
// arguments.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL) NewNVGRE_TUNNEL_LIST(TunnelName string) (*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NVGRE_TUNNEL_LIST == nil {
		t.NVGRE_TUNNEL_LIST = make(map[string]*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST)
	}

	key := TunnelName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NVGRE_TUNNEL_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NVGRE_TUNNEL_LIST", key)
	}

	t.NVGRE_TUNNEL_LIST[key] = &SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST{
		TunnelName: &TunnelName,
	}

	return t.NVGRE_TUNNEL_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL.
func (*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL) ΛBelongingModule() string {
	return "sonic-nvgre-tunnel"
}


// SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP represents the /sonic-nvgre-tunnel/sonic-nvgre-tunnel/NVGRE_TUNNEL_MAP YANG schema element.
type SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP struct {
	NVGRE_TUNNEL_MAP_LIST	map[SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST_Key]*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST	`path:"NVGRE_TUNNEL_MAP_LIST" module:"sonic-nvgre-tunnel"`
}

// IsYANGGoStruct ensures that SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP) IsYANGGoStruct() {}

// SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST_Key represents the key for list NVGRE_TUNNEL_MAP_LIST of element /sonic-nvgre-tunnel/sonic-nvgre-tunnel/NVGRE_TUNNEL_MAP.
type SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST_Key struct {
	TunnelName	string	`path:"tunnel_name"`
	TunnelMapName	string	`path:"tunnel_map_name"`
}

// IsYANGGoKeyStruct ensures that SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST_Key key struct.
func (t SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"tunnel_name": t.TunnelName,
		"tunnel_map_name": t.TunnelMapName,
	}, nil
}

// NewNVGRE_TUNNEL_MAP_LIST creates a new entry in the NVGRE_TUNNEL_MAP_LIST list of the
// SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP struct. The keys of the list are populated from the input
// arguments.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP) NewNVGRE_TUNNEL_MAP_LIST(TunnelName string, TunnelMapName string) (*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NVGRE_TUNNEL_MAP_LIST == nil {
		t.NVGRE_TUNNEL_MAP_LIST = make(map[SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST_Key]*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST)
	}

	key := SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST_Key{
		TunnelName: TunnelName,
		TunnelMapName: TunnelMapName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NVGRE_TUNNEL_MAP_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NVGRE_TUNNEL_MAP_LIST", key)
	}

	t.NVGRE_TUNNEL_MAP_LIST[key] = &SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST{
		TunnelName: &TunnelName,
		TunnelMapName: &TunnelMapName,
	}

	return t.NVGRE_TUNNEL_MAP_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP.
func (*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP) ΛBelongingModule() string {
	return "sonic-nvgre-tunnel"
}


// SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST represents the /sonic-nvgre-tunnel/sonic-nvgre-tunnel/NVGRE_TUNNEL_MAP/NVGRE_TUNNEL_MAP_LIST YANG schema element.
type SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST struct {
	TunnelMapName	*string	`path:"tunnel_map_name" module:"sonic-nvgre-tunnel"`
	TunnelName	*string	`path:"tunnel_name" module:"sonic-nvgre-tunnel"`
	VlanId	*uint16	`path:"vlan_id" module:"sonic-nvgre-tunnel"`
	Vsid	*uint32	`path:"vsid" module:"sonic-nvgre-tunnel"`
}

// IsYANGGoStruct ensures that SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST struct, which is a YANG list entry.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.TunnelMapName == nil {
		return nil, fmt.Errorf("nil value for key TunnelMapName")
	}

	if t.TunnelName == nil {
		return nil, fmt.Errorf("nil value for key TunnelName")
	}

	return map[string]interface{}{
		"tunnel_map_name": *t.TunnelMapName,
		"tunnel_name": *t.TunnelName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST.
func (*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_MAP_NVGRE_TUNNEL_MAP_LIST) ΛBelongingModule() string {
	return "sonic-nvgre-tunnel"
}


// SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST represents the /sonic-nvgre-tunnel/sonic-nvgre-tunnel/NVGRE_TUNNEL/NVGRE_TUNNEL_LIST YANG schema element.
type SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST struct {
	SrcIp	*string	`path:"src_ip" module:"sonic-nvgre-tunnel"`
	TunnelName	*string	`path:"tunnel_name" module:"sonic-nvgre-tunnel"`
}

// IsYANGGoStruct ensures that SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST struct, which is a YANG list entry.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.TunnelName == nil {
		return nil, fmt.Errorf("nil value for key TunnelName")
	}

	return map[string]interface{}{
		"tunnel_name": *t.TunnelName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST.
func (*SonicNvgreTunnel_SonicNvgreTunnel_NVGRE_TUNNEL_NVGRE_TUNNEL_LIST) ΛBelongingModule() string {
	return "sonic-nvgre-tunnel"
}


// SonicPasswh_SonicPasswh represents the /sonic-passwh/sonic-passwh YANG schema element.
type SonicPasswh_SonicPasswh struct {
	PASSW_HARDENING	*SonicPasswh_SonicPasswh_PASSW_HARDENING	`path:"PASSW_HARDENING" module:"sonic-passwh"`
}

// IsYANGGoStruct ensures that SonicPasswh_SonicPasswh implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPasswh_SonicPasswh) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPasswh_SonicPasswh) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPasswh_SonicPasswh"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPasswh_SonicPasswh) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPasswh_SonicPasswh) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPasswh_SonicPasswh.
func (*SonicPasswh_SonicPasswh) ΛBelongingModule() string {
	return "sonic-passwh"
}


// SonicPasswh_SonicPasswh_PASSW_HARDENING represents the /sonic-passwh/sonic-passwh/PASSW_HARDENING YANG schema element.
type SonicPasswh_SonicPasswh_PASSW_HARDENING struct {
	POLICIES	*SonicPasswh_SonicPasswh_PASSW_HARDENING_POLICIES	`path:"POLICIES" module:"sonic-passwh"`
}

// IsYANGGoStruct ensures that SonicPasswh_SonicPasswh_PASSW_HARDENING implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPasswh_SonicPasswh_PASSW_HARDENING) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPasswh_SonicPasswh_PASSW_HARDENING) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPasswh_SonicPasswh_PASSW_HARDENING"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPasswh_SonicPasswh_PASSW_HARDENING) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPasswh_SonicPasswh_PASSW_HARDENING) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPasswh_SonicPasswh_PASSW_HARDENING.
func (*SonicPasswh_SonicPasswh_PASSW_HARDENING) ΛBelongingModule() string {
	return "sonic-passwh"
}


// SonicPasswh_SonicPasswh_PASSW_HARDENING_POLICIES represents the /sonic-passwh/sonic-passwh/PASSW_HARDENING/POLICIES YANG schema element.
type SonicPasswh_SonicPasswh_PASSW_HARDENING_POLICIES struct {
	DigitsClass	*bool	`path:"digits_class" module:"sonic-passwh"`
	Expiration	*uint16	`path:"expiration" module:"sonic-passwh"`
	ExpirationWarning	*uint8	`path:"expiration_warning" module:"sonic-passwh"`
	HistoryCnt	*uint8	`path:"history_cnt" module:"sonic-passwh"`
	LenMin	*uint8	`path:"len_min" module:"sonic-passwh"`
	LowerClass	*bool	`path:"lower_class" module:"sonic-passwh"`
	RejectUserPasswMatch	*bool	`path:"reject_user_passw_match" module:"sonic-passwh"`
	SpecialClass	*bool	`path:"special_class" module:"sonic-passwh"`
	State	E_SonicPasswh_FeatureState	`path:"state" module:"sonic-passwh"`
	UpperClass	*bool	`path:"upper_class" module:"sonic-passwh"`
}

// IsYANGGoStruct ensures that SonicPasswh_SonicPasswh_PASSW_HARDENING_POLICIES implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPasswh_SonicPasswh_PASSW_HARDENING_POLICIES) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPasswh_SonicPasswh_PASSW_HARDENING_POLICIES) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPasswh_SonicPasswh_PASSW_HARDENING_POLICIES"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPasswh_SonicPasswh_PASSW_HARDENING_POLICIES) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPasswh_SonicPasswh_PASSW_HARDENING_POLICIES) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPasswh_SonicPasswh_PASSW_HARDENING_POLICIES.
func (*SonicPasswh_SonicPasswh_PASSW_HARDENING_POLICIES) ΛBelongingModule() string {
	return "sonic-passwh"
}


// SonicPbh_SonicPbh represents the /sonic-pbh/sonic-pbh YANG schema element.
type SonicPbh_SonicPbh struct {
	PBH_HASH	*SonicPbh_SonicPbh_PBH_HASH	`path:"PBH_HASH" module:"sonic-pbh"`
	PBH_HASH_FIELD	*SonicPbh_SonicPbh_PBH_HASH_FIELD	`path:"PBH_HASH_FIELD" module:"sonic-pbh"`
	PBH_RULE	*SonicPbh_SonicPbh_PBH_RULE	`path:"PBH_RULE" module:"sonic-pbh"`
	PBH_TABLE	*SonicPbh_SonicPbh_PBH_TABLE	`path:"PBH_TABLE" module:"sonic-pbh"`
}

// IsYANGGoStruct ensures that SonicPbh_SonicPbh implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPbh_SonicPbh) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPbh_SonicPbh"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPbh_SonicPbh) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPbh_SonicPbh.
func (*SonicPbh_SonicPbh) ΛBelongingModule() string {
	return "sonic-pbh"
}


// SonicPbh_SonicPbh_PBH_HASH represents the /sonic-pbh/sonic-pbh/PBH_HASH YANG schema element.
type SonicPbh_SonicPbh_PBH_HASH struct {
	PBH_HASH_LIST	map[string]*SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST	`path:"PBH_HASH_LIST" module:"sonic-pbh"`
}

// IsYANGGoStruct ensures that SonicPbh_SonicPbh_PBH_HASH implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPbh_SonicPbh_PBH_HASH) IsYANGGoStruct() {}

// NewPBH_HASH_LIST creates a new entry in the PBH_HASH_LIST list of the
// SonicPbh_SonicPbh_PBH_HASH struct. The keys of the list are populated from the input
// arguments.
func (t *SonicPbh_SonicPbh_PBH_HASH) NewPBH_HASH_LIST(HashName string) (*SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PBH_HASH_LIST == nil {
		t.PBH_HASH_LIST = make(map[string]*SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST)
	}

	key := HashName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PBH_HASH_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PBH_HASH_LIST", key)
	}

	t.PBH_HASH_LIST[key] = &SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST{
		HashName: &HashName,
	}

	return t.PBH_HASH_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_HASH) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPbh_SonicPbh_PBH_HASH"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_HASH) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPbh_SonicPbh_PBH_HASH) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPbh_SonicPbh_PBH_HASH.
func (*SonicPbh_SonicPbh_PBH_HASH) ΛBelongingModule() string {
	return "sonic-pbh"
}


// SonicPbh_SonicPbh_PBH_HASH_FIELD represents the /sonic-pbh/sonic-pbh/PBH_HASH_FIELD YANG schema element.
type SonicPbh_SonicPbh_PBH_HASH_FIELD struct {
	PBH_HASH_FIELD_LIST	map[string]*SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST	`path:"PBH_HASH_FIELD_LIST" module:"sonic-pbh"`
}

// IsYANGGoStruct ensures that SonicPbh_SonicPbh_PBH_HASH_FIELD implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPbh_SonicPbh_PBH_HASH_FIELD) IsYANGGoStruct() {}

// NewPBH_HASH_FIELD_LIST creates a new entry in the PBH_HASH_FIELD_LIST list of the
// SonicPbh_SonicPbh_PBH_HASH_FIELD struct. The keys of the list are populated from the input
// arguments.
func (t *SonicPbh_SonicPbh_PBH_HASH_FIELD) NewPBH_HASH_FIELD_LIST(HashFieldName string) (*SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PBH_HASH_FIELD_LIST == nil {
		t.PBH_HASH_FIELD_LIST = make(map[string]*SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST)
	}

	key := HashFieldName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PBH_HASH_FIELD_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PBH_HASH_FIELD_LIST", key)
	}

	t.PBH_HASH_FIELD_LIST[key] = &SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST{
		HashFieldName: &HashFieldName,
	}

	return t.PBH_HASH_FIELD_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_HASH_FIELD) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPbh_SonicPbh_PBH_HASH_FIELD"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_HASH_FIELD) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPbh_SonicPbh_PBH_HASH_FIELD) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPbh_SonicPbh_PBH_HASH_FIELD.
func (*SonicPbh_SonicPbh_PBH_HASH_FIELD) ΛBelongingModule() string {
	return "sonic-pbh"
}


// SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST represents the /sonic-pbh/sonic-pbh/PBH_HASH_FIELD/PBH_HASH_FIELD_LIST YANG schema element.
type SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST struct {
	HashField	E_SonicPbh_HashField	`path:"hash_field" module:"sonic-pbh"`
	HashFieldName	*string	`path:"hash_field_name" module:"sonic-pbh"`
	IpMask	*string	`path:"ip_mask" module:"sonic-pbh"`
	SequenceId	*uint32	`path:"sequence_id" module:"sonic-pbh"`
}

// IsYANGGoStruct ensures that SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST struct, which is a YANG list entry.
func (t *SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.HashFieldName == nil {
		return nil, fmt.Errorf("nil value for key HashFieldName")
	}

	return map[string]interface{}{
		"hash_field_name": *t.HashFieldName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST.
func (*SonicPbh_SonicPbh_PBH_HASH_FIELD_PBH_HASH_FIELD_LIST) ΛBelongingModule() string {
	return "sonic-pbh"
}


// SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST represents the /sonic-pbh/sonic-pbh/PBH_HASH/PBH_HASH_LIST YANG schema element.
type SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST struct {
	HashFieldList	[]string	`path:"hash_field_list" module:"sonic-pbh"`
	HashName	*string	`path:"hash_name" module:"sonic-pbh"`
}

// IsYANGGoStruct ensures that SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST struct, which is a YANG list entry.
func (t *SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.HashName == nil {
		return nil, fmt.Errorf("nil value for key HashName")
	}

	return map[string]interface{}{
		"hash_name": *t.HashName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST.
func (*SonicPbh_SonicPbh_PBH_HASH_PBH_HASH_LIST) ΛBelongingModule() string {
	return "sonic-pbh"
}


// SonicPbh_SonicPbh_PBH_RULE represents the /sonic-pbh/sonic-pbh/PBH_RULE YANG schema element.
type SonicPbh_SonicPbh_PBH_RULE struct {
	PBH_RULE_LIST	map[SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST_Key]*SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST	`path:"PBH_RULE_LIST" module:"sonic-pbh"`
}

// IsYANGGoStruct ensures that SonicPbh_SonicPbh_PBH_RULE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPbh_SonicPbh_PBH_RULE) IsYANGGoStruct() {}

// SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST_Key represents the key for list PBH_RULE_LIST of element /sonic-pbh/sonic-pbh/PBH_RULE.
type SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST_Key struct {
	TableName	string	`path:"table_name"`
	RuleName	string	`path:"rule_name"`
}

// IsYANGGoKeyStruct ensures that SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST_Key key struct.
func (t SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"table_name": t.TableName,
		"rule_name": t.RuleName,
	}, nil
}

// NewPBH_RULE_LIST creates a new entry in the PBH_RULE_LIST list of the
// SonicPbh_SonicPbh_PBH_RULE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicPbh_SonicPbh_PBH_RULE) NewPBH_RULE_LIST(TableName string, RuleName string) (*SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PBH_RULE_LIST == nil {
		t.PBH_RULE_LIST = make(map[SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST_Key]*SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST)
	}

	key := SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST_Key{
		TableName: TableName,
		RuleName: RuleName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PBH_RULE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PBH_RULE_LIST", key)
	}

	t.PBH_RULE_LIST[key] = &SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST{
		TableName: &TableName,
		RuleName: &RuleName,
	}

	return t.PBH_RULE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_RULE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPbh_SonicPbh_PBH_RULE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_RULE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPbh_SonicPbh_PBH_RULE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPbh_SonicPbh_PBH_RULE.
func (*SonicPbh_SonicPbh_PBH_RULE) ΛBelongingModule() string {
	return "sonic-pbh"
}


// SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST represents the /sonic-pbh/sonic-pbh/PBH_RULE/PBH_RULE_LIST YANG schema element.
type SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST struct {
	EtherType	*string	`path:"ether_type" module:"sonic-pbh"`
	FlowCounter	E_SonicPbh_FlowCounter	`path:"flow_counter" module:"sonic-pbh"`
	GreKey	*string	`path:"gre_key" module:"sonic-pbh"`
	Hash	*string	`path:"hash" module:"sonic-pbh"`
	InnerEtherType	*string	`path:"inner_ether_type" module:"sonic-pbh"`
	IpProtocol	*string	`path:"ip_protocol" module:"sonic-pbh"`
	Ipv6NextHeader	*string	`path:"ipv6_next_header" module:"sonic-pbh"`
	L4DstPort	*string	`path:"l4_dst_port" module:"sonic-pbh"`
	PacketAction	E_SonicPbh_PacketAction	`path:"packet_action" module:"sonic-pbh"`
	Priority	*uint32	`path:"priority" module:"sonic-pbh"`
	RuleName	*string	`path:"rule_name" module:"sonic-pbh"`
	TableName	*string	`path:"table_name" module:"sonic-pbh"`
}

// IsYANGGoStruct ensures that SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST struct, which is a YANG list entry.
func (t *SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.RuleName == nil {
		return nil, fmt.Errorf("nil value for key RuleName")
	}

	if t.TableName == nil {
		return nil, fmt.Errorf("nil value for key TableName")
	}

	return map[string]interface{}{
		"rule_name": *t.RuleName,
		"table_name": *t.TableName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST.
func (*SonicPbh_SonicPbh_PBH_RULE_PBH_RULE_LIST) ΛBelongingModule() string {
	return "sonic-pbh"
}


// SonicPbh_SonicPbh_PBH_TABLE represents the /sonic-pbh/sonic-pbh/PBH_TABLE YANG schema element.
type SonicPbh_SonicPbh_PBH_TABLE struct {
	PBH_TABLE_LIST	map[string]*SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST	`path:"PBH_TABLE_LIST" module:"sonic-pbh"`
}

// IsYANGGoStruct ensures that SonicPbh_SonicPbh_PBH_TABLE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPbh_SonicPbh_PBH_TABLE) IsYANGGoStruct() {}

// NewPBH_TABLE_LIST creates a new entry in the PBH_TABLE_LIST list of the
// SonicPbh_SonicPbh_PBH_TABLE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicPbh_SonicPbh_PBH_TABLE) NewPBH_TABLE_LIST(TableName string) (*SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PBH_TABLE_LIST == nil {
		t.PBH_TABLE_LIST = make(map[string]*SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST)
	}

	key := TableName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PBH_TABLE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PBH_TABLE_LIST", key)
	}

	t.PBH_TABLE_LIST[key] = &SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST{
		TableName: &TableName,
	}

	return t.PBH_TABLE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_TABLE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPbh_SonicPbh_PBH_TABLE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_TABLE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPbh_SonicPbh_PBH_TABLE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPbh_SonicPbh_PBH_TABLE.
func (*SonicPbh_SonicPbh_PBH_TABLE) ΛBelongingModule() string {
	return "sonic-pbh"
}


// SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST represents the /sonic-pbh/sonic-pbh/PBH_TABLE/PBH_TABLE_LIST YANG schema element.
type SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST struct {
	Description	*string	`path:"description" module:"sonic-pbh"`
	InterfaceList	[]string	`path:"interface_list" module:"sonic-pbh"`
	TableName	*string	`path:"table_name" module:"sonic-pbh"`
}

// IsYANGGoStruct ensures that SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST struct, which is a YANG list entry.
func (t *SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.TableName == nil {
		return nil, fmt.Errorf("nil value for key TableName")
	}

	return map[string]interface{}{
		"table_name": *t.TableName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST.
func (*SonicPbh_SonicPbh_PBH_TABLE_PBH_TABLE_LIST) ΛBelongingModule() string {
	return "sonic-pbh"
}


// SonicPeerSwitch_SonicPeerSwitch represents the /sonic-peer-switch/sonic-peer-switch YANG schema element.
type SonicPeerSwitch_SonicPeerSwitch struct {
	PEER_SWITCH	*SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH	`path:"PEER_SWITCH" module:"sonic-peer-switch"`
}

// IsYANGGoStruct ensures that SonicPeerSwitch_SonicPeerSwitch implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPeerSwitch_SonicPeerSwitch) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPeerSwitch_SonicPeerSwitch) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPeerSwitch_SonicPeerSwitch"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPeerSwitch_SonicPeerSwitch) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPeerSwitch_SonicPeerSwitch) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPeerSwitch_SonicPeerSwitch.
func (*SonicPeerSwitch_SonicPeerSwitch) ΛBelongingModule() string {
	return "sonic-peer-switch"
}


// SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH represents the /sonic-peer-switch/sonic-peer-switch/PEER_SWITCH YANG schema element.
type SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH struct {
	PEER_SWITCH_LIST	map[string]*SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST	`path:"PEER_SWITCH_LIST" module:"sonic-peer-switch"`
}

// IsYANGGoStruct ensures that SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH) IsYANGGoStruct() {}

// NewPEER_SWITCH_LIST creates a new entry in the PEER_SWITCH_LIST list of the
// SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH struct. The keys of the list are populated from the input
// arguments.
func (t *SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH) NewPEER_SWITCH_LIST(PeerSwitch string) (*SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PEER_SWITCH_LIST == nil {
		t.PEER_SWITCH_LIST = make(map[string]*SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST)
	}

	key := PeerSwitch

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PEER_SWITCH_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PEER_SWITCH_LIST", key)
	}

	t.PEER_SWITCH_LIST[key] = &SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST{
		PeerSwitch: &PeerSwitch,
	}

	return t.PEER_SWITCH_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH.
func (*SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH) ΛBelongingModule() string {
	return "sonic-peer-switch"
}


// SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST represents the /sonic-peer-switch/sonic-peer-switch/PEER_SWITCH/PEER_SWITCH_LIST YANG schema element.
type SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST struct {
	AddressIpv4	*string	`path:"address_ipv4" module:"sonic-peer-switch"`
	PeerSwitch	*string	`path:"peer_switch" module:"sonic-peer-switch"`
}

// IsYANGGoStruct ensures that SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST struct, which is a YANG list entry.
func (t *SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PeerSwitch == nil {
		return nil, fmt.Errorf("nil value for key PeerSwitch")
	}

	return map[string]interface{}{
		"peer_switch": *t.PeerSwitch,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST.
func (*SonicPeerSwitch_SonicPeerSwitch_PEER_SWITCH_PEER_SWITCH_LIST) ΛBelongingModule() string {
	return "sonic-peer-switch"
}


// SonicPort_SonicPort represents the /sonic-port/sonic-port YANG schema element.
type SonicPort_SonicPort struct {
	PORT	*SonicPort_SonicPort_PORT	`path:"PORT" module:"sonic-port"`
}

// IsYANGGoStruct ensures that SonicPort_SonicPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPort_SonicPort) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPort_SonicPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPort_SonicPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPort_SonicPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPort_SonicPort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPort_SonicPort.
func (*SonicPort_SonicPort) ΛBelongingModule() string {
	return "sonic-port"
}


// SonicPort_SonicPort_PORT represents the /sonic-port/sonic-port/PORT YANG schema element.
type SonicPort_SonicPort_PORT struct {
	PORT_LIST	map[string]*SonicPort_SonicPort_PORT_PORT_LIST	`path:"PORT_LIST" module:"sonic-port"`
}

// IsYANGGoStruct ensures that SonicPort_SonicPort_PORT implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPort_SonicPort_PORT) IsYANGGoStruct() {}

// NewPORT_LIST creates a new entry in the PORT_LIST list of the
// SonicPort_SonicPort_PORT struct. The keys of the list are populated from the input
// arguments.
func (t *SonicPort_SonicPort_PORT) NewPORT_LIST(Name string) (*SonicPort_SonicPort_PORT_PORT_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PORT_LIST == nil {
		t.PORT_LIST = make(map[string]*SonicPort_SonicPort_PORT_PORT_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PORT_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PORT_LIST", key)
	}

	t.PORT_LIST[key] = &SonicPort_SonicPort_PORT_PORT_LIST{
		Name: &Name,
	}

	return t.PORT_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPort_SonicPort_PORT) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPort_SonicPort_PORT"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPort_SonicPort_PORT) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPort_SonicPort_PORT) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPort_SonicPort_PORT.
func (*SonicPort_SonicPort_PORT) ΛBelongingModule() string {
	return "sonic-port"
}


// SonicPort_SonicPort_PORT_PORT_LIST represents the /sonic-port/sonic-port/PORT/PORT_LIST YANG schema element.
type SonicPort_SonicPort_PORT_PORT_LIST struct {
	AdminStatus	E_SonicTypes_AdminStatus	`path:"admin_status" module:"sonic-port"`
	AdvInterfaceTypes	[]SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union	`path:"adv_interface_types" module:"sonic-port"`
	AdvSpeeds	[]SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union	`path:"adv_speeds" module:"sonic-port"`
	Alias	*string	`path:"alias" module:"sonic-port"`
	AsicPortName	*string	`path:"asic_port_name" module:"sonic-port"`
	Autoneg	*string	`path:"autoneg" module:"sonic-port"`
	Description	*string	`path:"description" module:"sonic-port"`
	Fec	*string	`path:"fec" module:"sonic-port"`
	Index	*uint16	`path:"index" module:"sonic-port"`
	InterfaceType	E_SonicTypes_InterfaceType	`path:"interface_type" module:"sonic-port"`
	Lanes	*string	`path:"lanes" module:"sonic-port"`
	LaserFreq	*int32	`path:"laser_freq" module:"sonic-port"`
	LinkTraining	*string	`path:"link_training" module:"sonic-port"`
	Macsec	*string	`path:"macsec" module:"sonic-port"`
	Mtu	*uint16	`path:"mtu" module:"sonic-port"`
	MuxCable	*bool	`path:"mux_cable" module:"sonic-port"`
	Name	*string	`path:"name" module:"sonic-port"`
	PfcAsym	*string	`path:"pfc_asym" module:"sonic-port"`
	Role	*string	`path:"role" module:"sonic-port"`
	Speed	*uint32	`path:"speed" module:"sonic-port"`
	Tpid	*string	`path:"tpid" module:"sonic-port"`
	TxPower	*float64	`path:"tx_power" module:"sonic-port"`
}

// IsYANGGoStruct ensures that SonicPort_SonicPort_PORT_PORT_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPort_SonicPort_PORT_PORT_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicPort_SonicPort_PORT_PORT_LIST struct, which is a YANG list entry.
func (t *SonicPort_SonicPort_PORT_PORT_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPort_SonicPort_PORT_PORT_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPort_SonicPort_PORT_PORT_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPort_SonicPort_PORT_PORT_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPort_SonicPort_PORT_PORT_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPort_SonicPort_PORT_PORT_LIST.
func (*SonicPort_SonicPort_PORT_PORT_LIST) ΛBelongingModule() string {
	return "sonic-port"
}

// SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union is an interface that is implemented by valid types for the union
// for the leaf /sonic-port/sonic-port/PORT/PORT_LIST/adv_interface_types within the YANG schema.
type SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union interface {
	Is_SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union()
}

// SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union_E_SonicTypes_InterfaceType is used when /sonic-port/sonic-port/PORT/PORT_LIST/adv_interface_types
// is to be set to a E_SonicTypes_InterfaceType value.
type SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union_E_SonicTypes_InterfaceType struct {
	E_SonicTypes_InterfaceType	E_SonicTypes_InterfaceType
}

// Is_SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union ensures that SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union_E_SonicTypes_InterfaceType
// implements the SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union interface.
func (*SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union_E_SonicTypes_InterfaceType) Is_SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union() {}

// SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union_String is used when /sonic-port/sonic-port/PORT/PORT_LIST/adv_interface_types
// is to be set to a string value.
type SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union_String struct {
	String	string
}

// Is_SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union ensures that SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union_String
// implements the SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union interface.
func (*SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union_String) Is_SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union() {}

// To_SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union takes an input interface{} and attempts to convert it to a struct
// which implements the SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *SonicPort_SonicPort_PORT_PORT_LIST) To_SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union(i interface{}) (SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union, error) {
	switch v := i.(type) {
	case E_SonicTypes_InterfaceType:
		return &SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union_E_SonicTypes_InterfaceType{v}, nil
	case string:
		return &SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union_String{v}, nil
	default:
		return nil, fmt.Errorf("cannot convert %v to SonicPort_SonicPort_PORT_PORT_LIST_AdvInterfaceTypes_Union, unknown union type, got: %T, want any of [E_SonicTypes_InterfaceType, string]", i, i)
	}
}

// SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union is an interface that is implemented by valid types for the union
// for the leaf /sonic-port/sonic-port/PORT/PORT_LIST/adv_speeds within the YANG schema.
type SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union interface {
	Is_SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union()
}

// SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union_String is used when /sonic-port/sonic-port/PORT/PORT_LIST/adv_speeds
// is to be set to a string value.
type SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union_String struct {
	String	string
}

// Is_SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union ensures that SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union_String
// implements the SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union interface.
func (*SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union_String) Is_SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union() {}

// SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union_Uint32 is used when /sonic-port/sonic-port/PORT/PORT_LIST/adv_speeds
// is to be set to a uint32 value.
type SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union_Uint32 struct {
	Uint32	uint32
}

// Is_SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union ensures that SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union_Uint32
// implements the SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union interface.
func (*SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union_Uint32) Is_SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union() {}

// To_SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union takes an input interface{} and attempts to convert it to a struct
// which implements the SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *SonicPort_SonicPort_PORT_PORT_LIST) To_SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union(i interface{}) (SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union, error) {
	switch v := i.(type) {
	case string:
		return &SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union_String{v}, nil
	case uint32:
		return &SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union_Uint32{v}, nil
	default:
		return nil, fmt.Errorf("cannot convert %v to SonicPort_SonicPort_PORT_PORT_LIST_AdvSpeeds_Union, unknown union type, got: %T, want any of [string, uint32]", i, i)
	}
}


// SonicPortchannel_SonicPortchannel represents the /sonic-portchannel/sonic-portchannel YANG schema element.
type SonicPortchannel_SonicPortchannel struct {
	PORTCHANNEL	*SonicPortchannel_SonicPortchannel_PORTCHANNEL	`path:"PORTCHANNEL" module:"sonic-portchannel"`
	PORTCHANNEL_INTERFACE	*SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE	`path:"PORTCHANNEL_INTERFACE" module:"sonic-portchannel"`
	PORTCHANNEL_MEMBER	*SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER	`path:"PORTCHANNEL_MEMBER" module:"sonic-portchannel"`
}

// IsYANGGoStruct ensures that SonicPortchannel_SonicPortchannel implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPortchannel_SonicPortchannel) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPortchannel_SonicPortchannel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPortchannel_SonicPortchannel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPortchannel_SonicPortchannel.
func (*SonicPortchannel_SonicPortchannel) ΛBelongingModule() string {
	return "sonic-portchannel"
}


// SonicPortchannel_SonicPortchannel_PORTCHANNEL represents the /sonic-portchannel/sonic-portchannel/PORTCHANNEL YANG schema element.
type SonicPortchannel_SonicPortchannel_PORTCHANNEL struct {
	PORTCHANNEL_LIST	map[string]*SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST	`path:"PORTCHANNEL_LIST" module:"sonic-portchannel"`
}

// IsYANGGoStruct ensures that SonicPortchannel_SonicPortchannel_PORTCHANNEL implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL) IsYANGGoStruct() {}

// NewPORTCHANNEL_LIST creates a new entry in the PORTCHANNEL_LIST list of the
// SonicPortchannel_SonicPortchannel_PORTCHANNEL struct. The keys of the list are populated from the input
// arguments.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL) NewPORTCHANNEL_LIST(Name string) (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PORTCHANNEL_LIST == nil {
		t.PORTCHANNEL_LIST = make(map[string]*SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PORTCHANNEL_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PORTCHANNEL_LIST", key)
	}

	t.PORTCHANNEL_LIST[key] = &SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST{
		Name: &Name,
	}

	return t.PORTCHANNEL_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPortchannel_SonicPortchannel_PORTCHANNEL"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPortchannel_SonicPortchannel_PORTCHANNEL.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL) ΛBelongingModule() string {
	return "sonic-portchannel"
}


// SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE represents the /sonic-portchannel/sonic-portchannel/PORTCHANNEL_INTERFACE YANG schema element.
type SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE struct {
	PORTCHANNEL_INTERFACE_IPPREFIX_LIST	map[SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST_Key]*SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST	`path:"PORTCHANNEL_INTERFACE_IPPREFIX_LIST" module:"sonic-portchannel"`
	PORTCHANNEL_INTERFACE_LIST	map[string]*SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST	`path:"PORTCHANNEL_INTERFACE_LIST" module:"sonic-portchannel"`
}

// IsYANGGoStruct ensures that SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE) IsYANGGoStruct() {}

// SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST_Key represents the key for list PORTCHANNEL_INTERFACE_IPPREFIX_LIST of element /sonic-portchannel/sonic-portchannel/PORTCHANNEL_INTERFACE.
type SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST_Key struct {
	Name	string	`path:"name"`
	IpPrefix	string	`path:"ip_prefix"`
}

// IsYANGGoKeyStruct ensures that SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST_Key key struct.
func (t SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
		"ip_prefix": t.IpPrefix,
	}, nil
}

// NewPORTCHANNEL_INTERFACE_IPPREFIX_LIST creates a new entry in the PORTCHANNEL_INTERFACE_IPPREFIX_LIST list of the
// SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE) NewPORTCHANNEL_INTERFACE_IPPREFIX_LIST(Name string, IpPrefix string) (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PORTCHANNEL_INTERFACE_IPPREFIX_LIST == nil {
		t.PORTCHANNEL_INTERFACE_IPPREFIX_LIST = make(map[SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST_Key]*SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST)
	}

	key := SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST_Key{
		Name: Name,
		IpPrefix: IpPrefix,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PORTCHANNEL_INTERFACE_IPPREFIX_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PORTCHANNEL_INTERFACE_IPPREFIX_LIST", key)
	}

	t.PORTCHANNEL_INTERFACE_IPPREFIX_LIST[key] = &SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST{
		Name: &Name,
		IpPrefix: &IpPrefix,
	}

	return t.PORTCHANNEL_INTERFACE_IPPREFIX_LIST[key], nil
}

// NewPORTCHANNEL_INTERFACE_LIST creates a new entry in the PORTCHANNEL_INTERFACE_LIST list of the
// SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE) NewPORTCHANNEL_INTERFACE_LIST(Name string) (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PORTCHANNEL_INTERFACE_LIST == nil {
		t.PORTCHANNEL_INTERFACE_LIST = make(map[string]*SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PORTCHANNEL_INTERFACE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PORTCHANNEL_INTERFACE_LIST", key)
	}

	t.PORTCHANNEL_INTERFACE_LIST[key] = &SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST{
		Name: &Name,
	}

	return t.PORTCHANNEL_INTERFACE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE) ΛBelongingModule() string {
	return "sonic-portchannel"
}


// SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST represents the /sonic-portchannel/sonic-portchannel/PORTCHANNEL_INTERFACE/PORTCHANNEL_INTERFACE_IPPREFIX_LIST YANG schema element.
type SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST struct {
	IpPrefix	*string	`path:"ip_prefix" module:"sonic-portchannel"`
	Name	*string	`path:"name" module:"sonic-portchannel"`
}

// IsYANGGoStruct ensures that SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST struct, which is a YANG list entry.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"ip_prefix": *t.IpPrefix,
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_IPPREFIX_LIST) ΛBelongingModule() string {
	return "sonic-portchannel"
}


// SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST represents the /sonic-portchannel/sonic-portchannel/PORTCHANNEL_INTERFACE/PORTCHANNEL_INTERFACE_LIST YANG schema element.
type SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST struct {
	LoopbackAction	*string	`path:"loopback_action" module:"sonic-portchannel"`
	Mpls	E_SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls	`path:"mpls" module:"sonic-portchannel"`
	Name	*string	`path:"name" module:"sonic-portchannel"`
	NatZone	*uint8	`path:"nat_zone" module:"sonic-portchannel"`
	VrfName	*string	`path:"vrf_name" module:"sonic-portchannel"`
}

// IsYANGGoStruct ensures that SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST struct, which is a YANG list entry.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST) ΛBelongingModule() string {
	return "sonic-portchannel"
}


// SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER represents the /sonic-portchannel/sonic-portchannel/PORTCHANNEL_MEMBER YANG schema element.
type SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER struct {
	PORTCHANNEL_MEMBER_LIST	map[SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST_Key]*SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST	`path:"PORTCHANNEL_MEMBER_LIST" module:"sonic-portchannel"`
}

// IsYANGGoStruct ensures that SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER) IsYANGGoStruct() {}

// SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST_Key represents the key for list PORTCHANNEL_MEMBER_LIST of element /sonic-portchannel/sonic-portchannel/PORTCHANNEL_MEMBER.
type SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST_Key struct {
	Name	string	`path:"name"`
	Port	string	`path:"port"`
}

// IsYANGGoKeyStruct ensures that SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST_Key key struct.
func (t SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
		"port": t.Port,
	}, nil
}

// NewPORTCHANNEL_MEMBER_LIST creates a new entry in the PORTCHANNEL_MEMBER_LIST list of the
// SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER struct. The keys of the list are populated from the input
// arguments.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER) NewPORTCHANNEL_MEMBER_LIST(Name string, Port string) (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PORTCHANNEL_MEMBER_LIST == nil {
		t.PORTCHANNEL_MEMBER_LIST = make(map[SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST_Key]*SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST)
	}

	key := SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST_Key{
		Name: Name,
		Port: Port,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PORTCHANNEL_MEMBER_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PORTCHANNEL_MEMBER_LIST", key)
	}

	t.PORTCHANNEL_MEMBER_LIST[key] = &SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST{
		Name: &Name,
		Port: &Port,
	}

	return t.PORTCHANNEL_MEMBER_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER) ΛBelongingModule() string {
	return "sonic-portchannel"
}


// SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST represents the /sonic-portchannel/sonic-portchannel/PORTCHANNEL_MEMBER/PORTCHANNEL_MEMBER_LIST YANG schema element.
type SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST struct {
	Name	*string	`path:"name" module:"sonic-portchannel"`
	Port	*string	`path:"port" module:"sonic-portchannel"`
}

// IsYANGGoStruct ensures that SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST struct, which is a YANG list entry.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	if t.Port == nil {
		return nil, fmt.Errorf("nil value for key Port")
	}

	return map[string]interface{}{
		"name": *t.Name,
		"port": *t.Port,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_MEMBER_PORTCHANNEL_MEMBER_LIST) ΛBelongingModule() string {
	return "sonic-portchannel"
}


// SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST represents the /sonic-portchannel/sonic-portchannel/PORTCHANNEL/PORTCHANNEL_LIST YANG schema element.
type SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST struct {
	AdminStatus	E_SonicTypes_AdminStatus	`path:"admin_status" module:"sonic-portchannel"`
	Description	*string	`path:"description" module:"sonic-portchannel"`
	LacpKey	SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union	`path:"lacp_key" module:"sonic-portchannel"`
	Members	[]string	`path:"members" module:"sonic-portchannel"`
	MinLinks	*uint16	`path:"min_links" module:"sonic-portchannel"`
	Mtu	*uint16	`path:"mtu" module:"sonic-portchannel"`
	Name	*string	`path:"name" module:"sonic-portchannel"`
	Tpid	*string	`path:"tpid" module:"sonic-portchannel"`
}

// IsYANGGoStruct ensures that SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST struct, which is a YANG list entry.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST) ΛBelongingModule() string {
	return "sonic-portchannel"
}

// SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union is an interface that is implemented by valid types for the union
// for the leaf /sonic-portchannel/sonic-portchannel/PORTCHANNEL/PORTCHANNEL_LIST/lacp_key within the YANG schema.
type SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union interface {
	Is_SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union()
}

// SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union_String is used when /sonic-portchannel/sonic-portchannel/PORTCHANNEL/PORTCHANNEL_LIST/lacp_key
// is to be set to a string value.
type SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union_String struct {
	String	string
}

// Is_SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union ensures that SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union_String
// implements the SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union interface.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union_String) Is_SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union() {}

// SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union_Uint16 is used when /sonic-portchannel/sonic-portchannel/PORTCHANNEL/PORTCHANNEL_LIST/lacp_key
// is to be set to a uint16 value.
type SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union_Uint16 struct {
	Uint16	uint16
}

// Is_SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union ensures that SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union_Uint16
// implements the SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union interface.
func (*SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union_Uint16) Is_SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union() {}

// To_SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union takes an input interface{} and attempts to convert it to a struct
// which implements the SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST) To_SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union(i interface{}) (SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union, error) {
	switch v := i.(type) {
	case string:
		return &SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union_String{v}, nil
	case uint16:
		return &SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union_Uint16{v}, nil
	default:
		return nil, fmt.Errorf("cannot convert %v to SonicPortchannel_SonicPortchannel_PORTCHANNEL_PORTCHANNEL_LIST_LacpKey_Union, unknown union type, got: %T, want any of [string, uint16]", i, i)
	}
}


// SonicRestapi_SonicRestapi represents the /sonic-restapi/sonic-restapi YANG schema element.
type SonicRestapi_SonicRestapi struct {
	RESTAPI	*SonicRestapi_SonicRestapi_RESTAPI	`path:"RESTAPI" module:"sonic-restapi"`
}

// IsYANGGoStruct ensures that SonicRestapi_SonicRestapi implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRestapi_SonicRestapi) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRestapi_SonicRestapi) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRestapi_SonicRestapi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRestapi_SonicRestapi) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRestapi_SonicRestapi) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRestapi_SonicRestapi.
func (*SonicRestapi_SonicRestapi) ΛBelongingModule() string {
	return "sonic-restapi"
}


// SonicRestapi_SonicRestapi_RESTAPI represents the /sonic-restapi/sonic-restapi/RESTAPI YANG schema element.
type SonicRestapi_SonicRestapi_RESTAPI struct {
	Certs	*SonicRestapi_SonicRestapi_RESTAPI_Certs	`path:"certs" module:"sonic-restapi"`
	Config	*SonicRestapi_SonicRestapi_RESTAPI_Config	`path:"config" module:"sonic-restapi"`
}

// IsYANGGoStruct ensures that SonicRestapi_SonicRestapi_RESTAPI implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRestapi_SonicRestapi_RESTAPI) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRestapi_SonicRestapi_RESTAPI) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRestapi_SonicRestapi_RESTAPI"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRestapi_SonicRestapi_RESTAPI) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRestapi_SonicRestapi_RESTAPI) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRestapi_SonicRestapi_RESTAPI.
func (*SonicRestapi_SonicRestapi_RESTAPI) ΛBelongingModule() string {
	return "sonic-restapi"
}


// SonicRestapi_SonicRestapi_RESTAPI_Certs represents the /sonic-restapi/sonic-restapi/RESTAPI/certs YANG schema element.
type SonicRestapi_SonicRestapi_RESTAPI_Certs struct {
	CaCrt	*string	`path:"ca_crt" module:"sonic-restapi"`
	ClientCrtCname	*string	`path:"client_crt_cname" module:"sonic-restapi"`
	ServerCrt	*string	`path:"server_crt" module:"sonic-restapi"`
	ServerKey	*string	`path:"server_key" module:"sonic-restapi"`
}

// IsYANGGoStruct ensures that SonicRestapi_SonicRestapi_RESTAPI_Certs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRestapi_SonicRestapi_RESTAPI_Certs) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRestapi_SonicRestapi_RESTAPI_Certs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRestapi_SonicRestapi_RESTAPI_Certs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRestapi_SonicRestapi_RESTAPI_Certs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRestapi_SonicRestapi_RESTAPI_Certs) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRestapi_SonicRestapi_RESTAPI_Certs.
func (*SonicRestapi_SonicRestapi_RESTAPI_Certs) ΛBelongingModule() string {
	return "sonic-restapi"
}


// SonicRestapi_SonicRestapi_RESTAPI_Config represents the /sonic-restapi/sonic-restapi/RESTAPI/config YANG schema element.
type SonicRestapi_SonicRestapi_RESTAPI_Config struct {
	AllowInsecure	*bool	`path:"allow_insecure" module:"sonic-restapi"`
	ClientAuth	*bool	`path:"client_auth" module:"sonic-restapi"`
	LogLevel	*string	`path:"log_level" module:"sonic-restapi"`
}

// IsYANGGoStruct ensures that SonicRestapi_SonicRestapi_RESTAPI_Config implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRestapi_SonicRestapi_RESTAPI_Config) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRestapi_SonicRestapi_RESTAPI_Config) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRestapi_SonicRestapi_RESTAPI_Config"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRestapi_SonicRestapi_RESTAPI_Config) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRestapi_SonicRestapi_RESTAPI_Config) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRestapi_SonicRestapi_RESTAPI_Config.
func (*SonicRestapi_SonicRestapi_RESTAPI_Config) ΛBelongingModule() string {
	return "sonic-restapi"
}


// SonicRouteCommon_SonicRouteCommon represents the /sonic-route-common/sonic-route-common YANG schema element.
type SonicRouteCommon_SonicRouteCommon struct {
	ROUTE_REDISTRIBUTE	*SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE	`path:"ROUTE_REDISTRIBUTE" module:"sonic-route-common"`
}

// IsYANGGoStruct ensures that SonicRouteCommon_SonicRouteCommon implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRouteCommon_SonicRouteCommon) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteCommon_SonicRouteCommon) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRouteCommon_SonicRouteCommon"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteCommon_SonicRouteCommon) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRouteCommon_SonicRouteCommon) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRouteCommon_SonicRouteCommon.
func (*SonicRouteCommon_SonicRouteCommon) ΛBelongingModule() string {
	return "sonic-route-common"
}


// SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE represents the /sonic-route-common/sonic-route-common/ROUTE_REDISTRIBUTE YANG schema element.
type SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE struct {
	ROUTE_REDISTRIBUTE_LIST	map[SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST_Key]*SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST	`path:"ROUTE_REDISTRIBUTE_LIST" module:"sonic-route-common"`
}

// IsYANGGoStruct ensures that SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE) IsYANGGoStruct() {}

// SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST_Key represents the key for list ROUTE_REDISTRIBUTE_LIST of element /sonic-route-common/sonic-route-common/ROUTE_REDISTRIBUTE.
type SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST_Key struct {
	VrfName	string	`path:"vrf_name"`
	SrcProtocol	string	`path:"src_protocol"`
	DstProtocol	string	`path:"dst_protocol"`
	AddrFamily	string	`path:"addr_family"`
}

// IsYANGGoKeyStruct ensures that SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST_Key key struct.
func (t SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"vrf_name": t.VrfName,
		"src_protocol": t.SrcProtocol,
		"dst_protocol": t.DstProtocol,
		"addr_family": t.AddrFamily,
	}, nil
}

// NewROUTE_REDISTRIBUTE_LIST creates a new entry in the ROUTE_REDISTRIBUTE_LIST list of the
// SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE) NewROUTE_REDISTRIBUTE_LIST(VrfName string, SrcProtocol string, DstProtocol string, AddrFamily string) (*SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ROUTE_REDISTRIBUTE_LIST == nil {
		t.ROUTE_REDISTRIBUTE_LIST = make(map[SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST_Key]*SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST)
	}

	key := SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST_Key{
		VrfName: VrfName,
		SrcProtocol: SrcProtocol,
		DstProtocol: DstProtocol,
		AddrFamily: AddrFamily,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ROUTE_REDISTRIBUTE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ROUTE_REDISTRIBUTE_LIST", key)
	}

	t.ROUTE_REDISTRIBUTE_LIST[key] = &SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST{
		VrfName: &VrfName,
		SrcProtocol: &SrcProtocol,
		DstProtocol: &DstProtocol,
		AddrFamily: &AddrFamily,
	}

	return t.ROUTE_REDISTRIBUTE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE.
func (*SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE) ΛBelongingModule() string {
	return "sonic-route-common"
}


// SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST represents the /sonic-route-common/sonic-route-common/ROUTE_REDISTRIBUTE/ROUTE_REDISTRIBUTE_LIST YANG schema element.
type SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST struct {
	AddrFamily	*string	`path:"addr_family" module:"sonic-route-common"`
	DstProtocol	*string	`path:"dst_protocol" module:"sonic-route-common"`
	Metric	*uint32	`path:"metric" module:"sonic-route-common"`
	RouteMap	[]string	`path:"route_map" module:"sonic-route-common"`
	SrcProtocol	*string	`path:"src_protocol" module:"sonic-route-common"`
	VrfName	*string	`path:"vrf_name" module:"sonic-route-common"`
}

// IsYANGGoStruct ensures that SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST struct, which is a YANG list entry.
func (t *SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.AddrFamily == nil {
		return nil, fmt.Errorf("nil value for key AddrFamily")
	}

	if t.DstProtocol == nil {
		return nil, fmt.Errorf("nil value for key DstProtocol")
	}

	if t.SrcProtocol == nil {
		return nil, fmt.Errorf("nil value for key SrcProtocol")
	}

	if t.VrfName == nil {
		return nil, fmt.Errorf("nil value for key VrfName")
	}

	return map[string]interface{}{
		"addr_family": *t.AddrFamily,
		"dst_protocol": *t.DstProtocol,
		"src_protocol": *t.SrcProtocol,
		"vrf_name": *t.VrfName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST.
func (*SonicRouteCommon_SonicRouteCommon_ROUTE_REDISTRIBUTE_ROUTE_REDISTRIBUTE_LIST) ΛBelongingModule() string {
	return "sonic-route-common"
}


// SonicRouteMap_SonicRouteMap represents the /sonic-route-map/sonic-route-map YANG schema element.
type SonicRouteMap_SonicRouteMap struct {
	ROUTE_MAP	*SonicRouteMap_SonicRouteMap_ROUTE_MAP	`path:"ROUTE_MAP" module:"sonic-route-map"`
	ROUTE_MAP_SET	*SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET	`path:"ROUTE_MAP_SET" module:"sonic-route-map"`
}

// IsYANGGoStruct ensures that SonicRouteMap_SonicRouteMap implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRouteMap_SonicRouteMap) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteMap_SonicRouteMap) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRouteMap_SonicRouteMap"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteMap_SonicRouteMap) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRouteMap_SonicRouteMap) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRouteMap_SonicRouteMap.
func (*SonicRouteMap_SonicRouteMap) ΛBelongingModule() string {
	return "sonic-route-map"
}


// SonicRouteMap_SonicRouteMap_ROUTE_MAP represents the /sonic-route-map/sonic-route-map/ROUTE_MAP YANG schema element.
type SonicRouteMap_SonicRouteMap_ROUTE_MAP struct {
	ROUTE_MAP_LIST	map[SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST_Key]*SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST	`path:"ROUTE_MAP_LIST" module:"sonic-route-map"`
}

// IsYANGGoStruct ensures that SonicRouteMap_SonicRouteMap_ROUTE_MAP implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRouteMap_SonicRouteMap_ROUTE_MAP) IsYANGGoStruct() {}

// SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST_Key represents the key for list ROUTE_MAP_LIST of element /sonic-route-map/sonic-route-map/ROUTE_MAP.
type SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST_Key struct {
	Name	string	`path:"name"`
	StmtName	uint16	`path:"stmt_name"`
}

// IsYANGGoKeyStruct ensures that SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST_Key key struct.
func (t SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
		"stmt_name": t.StmtName,
	}, nil
}

// NewROUTE_MAP_LIST creates a new entry in the ROUTE_MAP_LIST list of the
// SonicRouteMap_SonicRouteMap_ROUTE_MAP struct. The keys of the list are populated from the input
// arguments.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP) NewROUTE_MAP_LIST(Name string, StmtName uint16) (*SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ROUTE_MAP_LIST == nil {
		t.ROUTE_MAP_LIST = make(map[SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST_Key]*SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST)
	}

	key := SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST_Key{
		Name: Name,
		StmtName: StmtName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ROUTE_MAP_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ROUTE_MAP_LIST", key)
	}

	t.ROUTE_MAP_LIST[key] = &SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST{
		Name: &Name,
		StmtName: &StmtName,
	}

	return t.ROUTE_MAP_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRouteMap_SonicRouteMap_ROUTE_MAP"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRouteMap_SonicRouteMap_ROUTE_MAP.
func (*SonicRouteMap_SonicRouteMap_ROUTE_MAP) ΛBelongingModule() string {
	return "sonic-route-map"
}


// SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST represents the /sonic-route-map/sonic-route-map/ROUTE_MAP/ROUTE_MAP_LIST YANG schema element.
type SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST struct {
	CallRouteMap	*string	`path:"call_route_map" module:"sonic-route-map"`
	MatchAsPath	*string	`path:"match_as_path" module:"sonic-route-map"`
	MatchCommunity	*string	`path:"match_community" module:"sonic-route-map"`
	MatchExtCommunity	*string	`path:"match_ext_community" module:"sonic-route-map"`
	MatchInterface	*string	`path:"match_interface" module:"sonic-route-map"`
	MatchIpv6PrefixSet	*string	`path:"match_ipv6_prefix_set" module:"sonic-route-map"`
	MatchLocalPref	*uint32	`path:"match_local_pref" module:"sonic-route-map"`
	MatchMed	*uint32	`path:"match_med" module:"sonic-route-map"`
	MatchNeighbor	[]string	`path:"match_neighbor" module:"sonic-route-map"`
	MatchNextHopSet	*string	`path:"match_next_hop_set" module:"sonic-route-map"`
	MatchOrigin	*string	`path:"match_origin" module:"sonic-route-map"`
	MatchPrefixSet	*string	`path:"match_prefix_set" module:"sonic-route-map"`
	MatchProtocol	*string	`path:"match_protocol" module:"sonic-route-map"`
	MatchSrcVrf	*string	`path:"match_src_vrf" module:"sonic-route-map"`
	MatchTag	[]uint32	`path:"match_tag" module:"sonic-route-map"`
	Name	*string	`path:"name" module:"sonic-route-map"`
	RouteOperation	E_SonicRoutingPolicySets_RoutingPolicyActionType	`path:"route_operation" module:"sonic-route-map"`
	SetAsn	*uint32	`path:"set_asn" module:"sonic-route-map"`
	SetAsnList	*string	`path:"set_asn_list" module:"sonic-route-map"`
	SetCommunityInline	[]string	`path:"set_community_inline" module:"sonic-route-map"`
	SetCommunityRef	*string	`path:"set_community_ref" module:"sonic-route-map"`
	SetExtCommunityInline	[]string	`path:"set_ext_community_inline" module:"sonic-route-map"`
	SetExtCommunityRef	*string	`path:"set_ext_community_ref" module:"sonic-route-map"`
	SetIpv6NextHopGlobal	*string	`path:"set_ipv6_next_hop_global" module:"sonic-route-map"`
	SetIpv6NextHopPreferGlobal	*bool	`path:"set_ipv6_next_hop_prefer_global" module:"sonic-route-map"`
	SetLocalPref	*uint32	`path:"set_local_pref" module:"sonic-route-map"`
	SetMed	*uint32	`path:"set_med" module:"sonic-route-map"`
	SetMetric	*uint32	`path:"set_metric" module:"sonic-route-map"`
	SetMetricAction	E_SonicRouteMap_MetricActionType	`path:"set_metric_action" module:"sonic-route-map"`
	SetNextHop	*string	`path:"set_next_hop" module:"sonic-route-map"`
	SetOrigin	*string	`path:"set_origin" module:"sonic-route-map"`
	SetRepeatAsn	*uint8	`path:"set_repeat_asn" module:"sonic-route-map"`
	SetTag	*uint32	`path:"set_tag" module:"sonic-route-map"`
	StmtName	*uint16	`path:"stmt_name" module:"sonic-route-map"`
}

// IsYANGGoStruct ensures that SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST struct, which is a YANG list entry.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	if t.StmtName == nil {
		return nil, fmt.Errorf("nil value for key StmtName")
	}

	return map[string]interface{}{
		"name": *t.Name,
		"stmt_name": *t.StmtName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST.
func (*SonicRouteMap_SonicRouteMap_ROUTE_MAP_ROUTE_MAP_LIST) ΛBelongingModule() string {
	return "sonic-route-map"
}


// SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET represents the /sonic-route-map/sonic-route-map/ROUTE_MAP_SET YANG schema element.
type SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET struct {
	ROUTE_MAP_SET_LIST	map[string]*SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST	`path:"ROUTE_MAP_SET_LIST" module:"sonic-route-map"`
}

// IsYANGGoStruct ensures that SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET) IsYANGGoStruct() {}

// NewROUTE_MAP_SET_LIST creates a new entry in the ROUTE_MAP_SET_LIST list of the
// SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET struct. The keys of the list are populated from the input
// arguments.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET) NewROUTE_MAP_SET_LIST(Name string) (*SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ROUTE_MAP_SET_LIST == nil {
		t.ROUTE_MAP_SET_LIST = make(map[string]*SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ROUTE_MAP_SET_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ROUTE_MAP_SET_LIST", key)
	}

	t.ROUTE_MAP_SET_LIST[key] = &SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST{
		Name: &Name,
	}

	return t.ROUTE_MAP_SET_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET.
func (*SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET) ΛBelongingModule() string {
	return "sonic-route-map"
}


// SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST represents the /sonic-route-map/sonic-route-map/ROUTE_MAP_SET/ROUTE_MAP_SET_LIST YANG schema element.
type SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST struct {
	Name	*string	`path:"name" module:"sonic-route-map"`
}

// IsYANGGoStruct ensures that SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST struct, which is a YANG list entry.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST.
func (*SonicRouteMap_SonicRouteMap_ROUTE_MAP_SET_ROUTE_MAP_SET_LIST) ΛBelongingModule() string {
	return "sonic-route-map"
}


// SonicRoutingPolicySets_SonicRoutingPolicySets represents the /sonic-routing-policy-sets/sonic-routing-policy-sets YANG schema element.
type SonicRoutingPolicySets_SonicRoutingPolicySets struct {
	AS_PATH_SET	*SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET	`path:"AS_PATH_SET" module:"sonic-routing-policy-sets"`
	COMMUNITY_SET	*SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET	`path:"COMMUNITY_SET" module:"sonic-routing-policy-sets"`
	EXTENDED_COMMUNITY_SET	*SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET	`path:"EXTENDED_COMMUNITY_SET" module:"sonic-routing-policy-sets"`
	PREFIX	*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX	`path:"PREFIX" module:"sonic-routing-policy-sets"`
	PREFIX_SET	*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET	`path:"PREFIX_SET" module:"sonic-routing-policy-sets"`
}

// IsYANGGoStruct ensures that SonicRoutingPolicySets_SonicRoutingPolicySets implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRoutingPolicySets_SonicRoutingPolicySets"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRoutingPolicySets_SonicRoutingPolicySets.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets) ΛBelongingModule() string {
	return "sonic-routing-policy-sets"
}


// SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET represents the /sonic-routing-policy-sets/sonic-routing-policy-sets/AS_PATH_SET YANG schema element.
type SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET struct {
	AS_PATH_SET_LIST	map[string]*SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST	`path:"AS_PATH_SET_LIST" module:"sonic-routing-policy-sets"`
}

// IsYANGGoStruct ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET) IsYANGGoStruct() {}

// NewAS_PATH_SET_LIST creates a new entry in the AS_PATH_SET_LIST list of the
// SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET struct. The keys of the list are populated from the input
// arguments.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET) NewAS_PATH_SET_LIST(Name string) (*SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AS_PATH_SET_LIST == nil {
		t.AS_PATH_SET_LIST = make(map[string]*SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AS_PATH_SET_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AS_PATH_SET_LIST", key)
	}

	t.AS_PATH_SET_LIST[key] = &SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST{
		Name: &Name,
	}

	return t.AS_PATH_SET_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET) ΛBelongingModule() string {
	return "sonic-routing-policy-sets"
}


// SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST represents the /sonic-routing-policy-sets/sonic-routing-policy-sets/AS_PATH_SET/AS_PATH_SET_LIST YANG schema element.
type SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST struct {
	Action	E_SonicRoutingPolicySets_RoutingPolicyActionType	`path:"action" module:"sonic-routing-policy-sets"`
	AsPathSetMember	[]string	`path:"as_path_set_member" module:"sonic-routing-policy-sets"`
	Name	*string	`path:"name" module:"sonic-routing-policy-sets"`
}

// IsYANGGoStruct ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST struct, which is a YANG list entry.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_AS_PATH_SET_AS_PATH_SET_LIST) ΛBelongingModule() string {
	return "sonic-routing-policy-sets"
}


// SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET represents the /sonic-routing-policy-sets/sonic-routing-policy-sets/COMMUNITY_SET YANG schema element.
type SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET struct {
	COMMUNITY_SET_LIST	map[string]*SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST	`path:"COMMUNITY_SET_LIST" module:"sonic-routing-policy-sets"`
}

// IsYANGGoStruct ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET) IsYANGGoStruct() {}

// NewCOMMUNITY_SET_LIST creates a new entry in the COMMUNITY_SET_LIST list of the
// SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET struct. The keys of the list are populated from the input
// arguments.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET) NewCOMMUNITY_SET_LIST(Name string) (*SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.COMMUNITY_SET_LIST == nil {
		t.COMMUNITY_SET_LIST = make(map[string]*SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.COMMUNITY_SET_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list COMMUNITY_SET_LIST", key)
	}

	t.COMMUNITY_SET_LIST[key] = &SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST{
		Name: &Name,
	}

	return t.COMMUNITY_SET_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET) ΛBelongingModule() string {
	return "sonic-routing-policy-sets"
}


// SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST represents the /sonic-routing-policy-sets/sonic-routing-policy-sets/COMMUNITY_SET/COMMUNITY_SET_LIST YANG schema element.
type SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST struct {
	Action	E_SonicRoutingPolicySets_RoutingPolicyActionType	`path:"action" module:"sonic-routing-policy-sets"`
	CommunityMember	[]string	`path:"community_member" module:"sonic-routing-policy-sets"`
	MatchAction	E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction	`path:"match_action" module:"sonic-routing-policy-sets"`
	Name	*string	`path:"name" module:"sonic-routing-policy-sets"`
	SetType	E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType	`path:"set_type" module:"sonic-routing-policy-sets"`
}

// IsYANGGoStruct ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST struct, which is a YANG list entry.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST) ΛBelongingModule() string {
	return "sonic-routing-policy-sets"
}


// SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET represents the /sonic-routing-policy-sets/sonic-routing-policy-sets/EXTENDED_COMMUNITY_SET YANG schema element.
type SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET struct {
	EXTENDED_COMMUNITY_SET_LIST	map[string]*SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST	`path:"EXTENDED_COMMUNITY_SET_LIST" module:"sonic-routing-policy-sets"`
}

// IsYANGGoStruct ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET) IsYANGGoStruct() {}

// NewEXTENDED_COMMUNITY_SET_LIST creates a new entry in the EXTENDED_COMMUNITY_SET_LIST list of the
// SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET struct. The keys of the list are populated from the input
// arguments.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET) NewEXTENDED_COMMUNITY_SET_LIST(Name string) (*SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EXTENDED_COMMUNITY_SET_LIST == nil {
		t.EXTENDED_COMMUNITY_SET_LIST = make(map[string]*SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EXTENDED_COMMUNITY_SET_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EXTENDED_COMMUNITY_SET_LIST", key)
	}

	t.EXTENDED_COMMUNITY_SET_LIST[key] = &SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST{
		Name: &Name,
	}

	return t.EXTENDED_COMMUNITY_SET_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET) ΛBelongingModule() string {
	return "sonic-routing-policy-sets"
}


// SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST represents the /sonic-routing-policy-sets/sonic-routing-policy-sets/EXTENDED_COMMUNITY_SET/EXTENDED_COMMUNITY_SET_LIST YANG schema element.
type SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST struct {
	Action	E_SonicRoutingPolicySets_RoutingPolicyActionType	`path:"action" module:"sonic-routing-policy-sets"`
	CommunityMember	[]string	`path:"community_member" module:"sonic-routing-policy-sets"`
	MatchAction	E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction	`path:"match_action" module:"sonic-routing-policy-sets"`
	Name	*string	`path:"name" module:"sonic-routing-policy-sets"`
	SetType	E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType	`path:"set_type" module:"sonic-routing-policy-sets"`
}

// IsYANGGoStruct ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST struct, which is a YANG list entry.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST) ΛBelongingModule() string {
	return "sonic-routing-policy-sets"
}


// SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX represents the /sonic-routing-policy-sets/sonic-routing-policy-sets/PREFIX YANG schema element.
type SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX struct {
	PREFIX_LIST	map[SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST_Key]*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST	`path:"PREFIX_LIST" module:"sonic-routing-policy-sets"`
}

// IsYANGGoStruct ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX) IsYANGGoStruct() {}

// SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST_Key represents the key for list PREFIX_LIST of element /sonic-routing-policy-sets/sonic-routing-policy-sets/PREFIX.
type SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST_Key struct {
	Name	string	`path:"name"`
	SequenceNumber	uint32	`path:"sequence_number"`
	IpPrefix	string	`path:"ip_prefix"`
	MasklengthRange	string	`path:"masklength_range"`
}

// IsYANGGoKeyStruct ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST_Key key struct.
func (t SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
		"sequence_number": t.SequenceNumber,
		"ip_prefix": t.IpPrefix,
		"masklength_range": t.MasklengthRange,
	}, nil
}

// NewPREFIX_LIST creates a new entry in the PREFIX_LIST list of the
// SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX struct. The keys of the list are populated from the input
// arguments.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX) NewPREFIX_LIST(Name string, SequenceNumber uint32, IpPrefix string, MasklengthRange string) (*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PREFIX_LIST == nil {
		t.PREFIX_LIST = make(map[SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST_Key]*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST)
	}

	key := SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST_Key{
		Name: Name,
		SequenceNumber: SequenceNumber,
		IpPrefix: IpPrefix,
		MasklengthRange: MasklengthRange,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PREFIX_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PREFIX_LIST", key)
	}

	t.PREFIX_LIST[key] = &SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST{
		Name: &Name,
		SequenceNumber: &SequenceNumber,
		IpPrefix: &IpPrefix,
		MasklengthRange: &MasklengthRange,
	}

	return t.PREFIX_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX) ΛBelongingModule() string {
	return "sonic-routing-policy-sets"
}


// SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST represents the /sonic-routing-policy-sets/sonic-routing-policy-sets/PREFIX/PREFIX_LIST YANG schema element.
type SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST struct {
	Action	E_SonicRoutingPolicySets_RoutingPolicyActionType	`path:"action" module:"sonic-routing-policy-sets"`
	IpPrefix	*string	`path:"ip_prefix" module:"sonic-routing-policy-sets"`
	MasklengthRange	*string	`path:"masklength_range" module:"sonic-routing-policy-sets"`
	Name	*string	`path:"name" module:"sonic-routing-policy-sets"`
	SequenceNumber	*uint32	`path:"sequence_number" module:"sonic-routing-policy-sets"`
}

// IsYANGGoStruct ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST struct, which is a YANG list entry.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	if t.MasklengthRange == nil {
		return nil, fmt.Errorf("nil value for key MasklengthRange")
	}

	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	if t.SequenceNumber == nil {
		return nil, fmt.Errorf("nil value for key SequenceNumber")
	}

	return map[string]interface{}{
		"ip_prefix": *t.IpPrefix,
		"masklength_range": *t.MasklengthRange,
		"name": *t.Name,
		"sequence_number": *t.SequenceNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_PREFIX_LIST) ΛBelongingModule() string {
	return "sonic-routing-policy-sets"
}


// SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET represents the /sonic-routing-policy-sets/sonic-routing-policy-sets/PREFIX_SET YANG schema element.
type SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET struct {
	PREFIX_SET_LIST	map[string]*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST	`path:"PREFIX_SET_LIST" module:"sonic-routing-policy-sets"`
}

// IsYANGGoStruct ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET) IsYANGGoStruct() {}

// NewPREFIX_SET_LIST creates a new entry in the PREFIX_SET_LIST list of the
// SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET struct. The keys of the list are populated from the input
// arguments.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET) NewPREFIX_SET_LIST(Name string) (*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PREFIX_SET_LIST == nil {
		t.PREFIX_SET_LIST = make(map[string]*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PREFIX_SET_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PREFIX_SET_LIST", key)
	}

	t.PREFIX_SET_LIST[key] = &SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST{
		Name: &Name,
	}

	return t.PREFIX_SET_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET) ΛBelongingModule() string {
	return "sonic-routing-policy-sets"
}


// SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST represents the /sonic-routing-policy-sets/sonic-routing-policy-sets/PREFIX_SET/PREFIX_SET_LIST YANG schema element.
type SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST struct {
	Mode	E_SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode	`path:"mode" module:"sonic-routing-policy-sets"`
	Name	*string	`path:"name" module:"sonic-routing-policy-sets"`
}

// IsYANGGoStruct ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST struct, which is a YANG list entry.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST.
func (*SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST) ΛBelongingModule() string {
	return "sonic-routing-policy-sets"
}


// SonicScheduler_SonicScheduler represents the /sonic-scheduler/sonic-scheduler YANG schema element.
type SonicScheduler_SonicScheduler struct {
	SCHEDULER	*SonicScheduler_SonicScheduler_SCHEDULER	`path:"SCHEDULER" module:"sonic-scheduler"`
}

// IsYANGGoStruct ensures that SonicScheduler_SonicScheduler implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicScheduler_SonicScheduler) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicScheduler_SonicScheduler) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicScheduler_SonicScheduler"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicScheduler_SonicScheduler) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicScheduler_SonicScheduler) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicScheduler_SonicScheduler.
func (*SonicScheduler_SonicScheduler) ΛBelongingModule() string {
	return "sonic-scheduler"
}


// SonicScheduler_SonicScheduler_SCHEDULER represents the /sonic-scheduler/sonic-scheduler/SCHEDULER YANG schema element.
type SonicScheduler_SonicScheduler_SCHEDULER struct {
	SCHEDULER_LIST	map[string]*SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST	`path:"SCHEDULER_LIST" module:"sonic-scheduler"`
}

// IsYANGGoStruct ensures that SonicScheduler_SonicScheduler_SCHEDULER implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicScheduler_SonicScheduler_SCHEDULER) IsYANGGoStruct() {}

// NewSCHEDULER_LIST creates a new entry in the SCHEDULER_LIST list of the
// SonicScheduler_SonicScheduler_SCHEDULER struct. The keys of the list are populated from the input
// arguments.
func (t *SonicScheduler_SonicScheduler_SCHEDULER) NewSCHEDULER_LIST(Name string) (*SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SCHEDULER_LIST == nil {
		t.SCHEDULER_LIST = make(map[string]*SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SCHEDULER_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SCHEDULER_LIST", key)
	}

	t.SCHEDULER_LIST[key] = &SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST{
		Name: &Name,
	}

	return t.SCHEDULER_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicScheduler_SonicScheduler_SCHEDULER) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicScheduler_SonicScheduler_SCHEDULER"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicScheduler_SonicScheduler_SCHEDULER) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicScheduler_SonicScheduler_SCHEDULER) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicScheduler_SonicScheduler_SCHEDULER.
func (*SonicScheduler_SonicScheduler_SCHEDULER) ΛBelongingModule() string {
	return "sonic-scheduler"
}


// SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST represents the /sonic-scheduler/sonic-scheduler/SCHEDULER/SCHEDULER_LIST YANG schema element.
type SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST struct {
	Cbs	*uint32	`path:"cbs" module:"sonic-scheduler"`
	Cir	*uint64	`path:"cir" module:"sonic-scheduler"`
	MeterType	E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType	`path:"meter_type" module:"sonic-scheduler"`
	Name	*string	`path:"name" module:"sonic-scheduler"`
	Pbs	*uint32	`path:"pbs" module:"sonic-scheduler"`
	Pir	*uint64	`path:"pir" module:"sonic-scheduler"`
	Priority	*uint8	`path:"priority" module:"sonic-scheduler"`
	Type	E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type	`path:"type" module:"sonic-scheduler"`
	Weight	*uint8	`path:"weight" module:"sonic-scheduler"`
}

// IsYANGGoStruct ensures that SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST struct, which is a YANG list entry.
func (t *SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST.
func (*SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST) ΛBelongingModule() string {
	return "sonic-scheduler"
}


// SonicSflow_SonicSflow represents the /sonic-sflow/sonic-sflow YANG schema element.
type SonicSflow_SonicSflow struct {
	SFLOW	*SonicSflow_SonicSflow_SFLOW	`path:"SFLOW" module:"sonic-sflow"`
	SFLOW_COLLECTOR	*SonicSflow_SonicSflow_SFLOW_COLLECTOR	`path:"SFLOW_COLLECTOR" module:"sonic-sflow"`
	SFLOW_SESSION	*SonicSflow_SonicSflow_SFLOW_SESSION	`path:"SFLOW_SESSION" module:"sonic-sflow"`
}

// IsYANGGoStruct ensures that SonicSflow_SonicSflow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicSflow_SonicSflow) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicSflow_SonicSflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicSflow_SonicSflow) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicSflow_SonicSflow.
func (*SonicSflow_SonicSflow) ΛBelongingModule() string {
	return "sonic-sflow"
}


// SonicSflow_SonicSflow_SFLOW represents the /sonic-sflow/sonic-sflow/SFLOW YANG schema element.
type SonicSflow_SonicSflow_SFLOW struct {
	Global	*SonicSflow_SonicSflow_SFLOW_Global	`path:"global" module:"sonic-sflow"`
}

// IsYANGGoStruct ensures that SonicSflow_SonicSflow_SFLOW implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicSflow_SonicSflow_SFLOW) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow_SFLOW) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicSflow_SonicSflow_SFLOW"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow_SFLOW) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicSflow_SonicSflow_SFLOW) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicSflow_SonicSflow_SFLOW.
func (*SonicSflow_SonicSflow_SFLOW) ΛBelongingModule() string {
	return "sonic-sflow"
}


// SonicSflow_SonicSflow_SFLOW_COLLECTOR represents the /sonic-sflow/sonic-sflow/SFLOW_COLLECTOR YANG schema element.
type SonicSflow_SonicSflow_SFLOW_COLLECTOR struct {
	SFLOW_COLLECTOR_LIST	map[string]*SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST	`path:"SFLOW_COLLECTOR_LIST" module:"sonic-sflow"`
}

// IsYANGGoStruct ensures that SonicSflow_SonicSflow_SFLOW_COLLECTOR implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicSflow_SonicSflow_SFLOW_COLLECTOR) IsYANGGoStruct() {}

// NewSFLOW_COLLECTOR_LIST creates a new entry in the SFLOW_COLLECTOR_LIST list of the
// SonicSflow_SonicSflow_SFLOW_COLLECTOR struct. The keys of the list are populated from the input
// arguments.
func (t *SonicSflow_SonicSflow_SFLOW_COLLECTOR) NewSFLOW_COLLECTOR_LIST(Name string) (*SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SFLOW_COLLECTOR_LIST == nil {
		t.SFLOW_COLLECTOR_LIST = make(map[string]*SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SFLOW_COLLECTOR_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SFLOW_COLLECTOR_LIST", key)
	}

	t.SFLOW_COLLECTOR_LIST[key] = &SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST{
		Name: &Name,
	}

	return t.SFLOW_COLLECTOR_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow_SFLOW_COLLECTOR) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicSflow_SonicSflow_SFLOW_COLLECTOR"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow_SFLOW_COLLECTOR) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicSflow_SonicSflow_SFLOW_COLLECTOR) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicSflow_SonicSflow_SFLOW_COLLECTOR.
func (*SonicSflow_SonicSflow_SFLOW_COLLECTOR) ΛBelongingModule() string {
	return "sonic-sflow"
}


// SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST represents the /sonic-sflow/sonic-sflow/SFLOW_COLLECTOR/SFLOW_COLLECTOR_LIST YANG schema element.
type SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST struct {
	CollectorIp	*string	`path:"collector_ip" module:"sonic-sflow"`
	CollectorPort	*uint16	`path:"collector_port" module:"sonic-sflow"`
	CollectorVrf	*string	`path:"collector_vrf" module:"sonic-sflow"`
	Name	*string	`path:"name" module:"sonic-sflow"`
}

// IsYANGGoStruct ensures that SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST struct, which is a YANG list entry.
func (t *SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST.
func (*SonicSflow_SonicSflow_SFLOW_COLLECTOR_SFLOW_COLLECTOR_LIST) ΛBelongingModule() string {
	return "sonic-sflow"
}


// SonicSflow_SonicSflow_SFLOW_Global represents the /sonic-sflow/sonic-sflow/SFLOW/global YANG schema element.
type SonicSflow_SonicSflow_SFLOW_Global struct {
	AdminState	E_SonicTypes_AdminStatus	`path:"admin_state" module:"sonic-sflow"`
	AgentId	*string	`path:"agent_id" module:"sonic-sflow"`
	PollingInterval	*uint16	`path:"polling_interval" module:"sonic-sflow"`
}

// IsYANGGoStruct ensures that SonicSflow_SonicSflow_SFLOW_Global implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicSflow_SonicSflow_SFLOW_Global) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow_SFLOW_Global) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicSflow_SonicSflow_SFLOW_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow_SFLOW_Global) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicSflow_SonicSflow_SFLOW_Global) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicSflow_SonicSflow_SFLOW_Global.
func (*SonicSflow_SonicSflow_SFLOW_Global) ΛBelongingModule() string {
	return "sonic-sflow"
}


// SonicSflow_SonicSflow_SFLOW_SESSION represents the /sonic-sflow/sonic-sflow/SFLOW_SESSION YANG schema element.
type SonicSflow_SonicSflow_SFLOW_SESSION struct {
	SFLOW_SESSION_LIST	map[string]*SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST	`path:"SFLOW_SESSION_LIST" module:"sonic-sflow"`
}

// IsYANGGoStruct ensures that SonicSflow_SonicSflow_SFLOW_SESSION implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicSflow_SonicSflow_SFLOW_SESSION) IsYANGGoStruct() {}

// NewSFLOW_SESSION_LIST creates a new entry in the SFLOW_SESSION_LIST list of the
// SonicSflow_SonicSflow_SFLOW_SESSION struct. The keys of the list are populated from the input
// arguments.
func (t *SonicSflow_SonicSflow_SFLOW_SESSION) NewSFLOW_SESSION_LIST(Port string) (*SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SFLOW_SESSION_LIST == nil {
		t.SFLOW_SESSION_LIST = make(map[string]*SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST)
	}

	key := Port

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SFLOW_SESSION_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SFLOW_SESSION_LIST", key)
	}

	t.SFLOW_SESSION_LIST[key] = &SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST{
		Port: &Port,
	}

	return t.SFLOW_SESSION_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow_SFLOW_SESSION) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicSflow_SonicSflow_SFLOW_SESSION"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow_SFLOW_SESSION) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicSflow_SonicSflow_SFLOW_SESSION) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicSflow_SonicSflow_SFLOW_SESSION.
func (*SonicSflow_SonicSflow_SFLOW_SESSION) ΛBelongingModule() string {
	return "sonic-sflow"
}


// SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST represents the /sonic-sflow/sonic-sflow/SFLOW_SESSION/SFLOW_SESSION_LIST YANG schema element.
type SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST struct {
	AdminState	E_SonicTypes_AdminStatus	`path:"admin_state" module:"sonic-sflow"`
	Port	*string	`path:"port" module:"sonic-sflow"`
	SampleRate	*uint32	`path:"sample_rate" module:"sonic-sflow"`
}

// IsYANGGoStruct ensures that SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST struct, which is a YANG list entry.
func (t *SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Port == nil {
		return nil, fmt.Errorf("nil value for key Port")
	}

	return map[string]interface{}{
		"port": *t.Port,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST.
func (*SonicSflow_SonicSflow_SFLOW_SESSION_SFLOW_SESSION_LIST) ΛBelongingModule() string {
	return "sonic-sflow"
}


// SonicSnmp_SonicSnmp represents the /sonic-snmp/sonic-snmp YANG schema element.
type SonicSnmp_SonicSnmp struct {
	SNMP	*SonicSnmp_SonicSnmp_SNMP	`path:"SNMP" module:"sonic-snmp"`
	SNMP_COMMUNITY	*SonicSnmp_SonicSnmp_SNMP_COMMUNITY	`path:"SNMP_COMMUNITY" module:"sonic-snmp"`
}

// IsYANGGoStruct ensures that SonicSnmp_SonicSnmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicSnmp_SonicSnmp) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSnmp_SonicSnmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicSnmp_SonicSnmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSnmp_SonicSnmp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicSnmp_SonicSnmp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicSnmp_SonicSnmp.
func (*SonicSnmp_SonicSnmp) ΛBelongingModule() string {
	return "sonic-snmp"
}


// SonicSnmp_SonicSnmp_SNMP represents the /sonic-snmp/sonic-snmp/SNMP YANG schema element.
type SonicSnmp_SonicSnmp_SNMP struct {
	CONTACT	*SonicSnmp_SonicSnmp_SNMP_CONTACT	`path:"CONTACT" module:"sonic-snmp"`
	LOCATION	*SonicSnmp_SonicSnmp_SNMP_LOCATION	`path:"LOCATION" module:"sonic-snmp"`
}

// IsYANGGoStruct ensures that SonicSnmp_SonicSnmp_SNMP implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicSnmp_SonicSnmp_SNMP) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSnmp_SonicSnmp_SNMP) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicSnmp_SonicSnmp_SNMP"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSnmp_SonicSnmp_SNMP) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicSnmp_SonicSnmp_SNMP) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicSnmp_SonicSnmp_SNMP.
func (*SonicSnmp_SonicSnmp_SNMP) ΛBelongingModule() string {
	return "sonic-snmp"
}


// SonicSnmp_SonicSnmp_SNMP_COMMUNITY represents the /sonic-snmp/sonic-snmp/SNMP_COMMUNITY YANG schema element.
type SonicSnmp_SonicSnmp_SNMP_COMMUNITY struct {
	SNMP_COMMUNITY_LIST	map[string]*SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST	`path:"SNMP_COMMUNITY_LIST" module:"sonic-snmp"`
}

// IsYANGGoStruct ensures that SonicSnmp_SonicSnmp_SNMP_COMMUNITY implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicSnmp_SonicSnmp_SNMP_COMMUNITY) IsYANGGoStruct() {}

// NewSNMP_COMMUNITY_LIST creates a new entry in the SNMP_COMMUNITY_LIST list of the
// SonicSnmp_SonicSnmp_SNMP_COMMUNITY struct. The keys of the list are populated from the input
// arguments.
func (t *SonicSnmp_SonicSnmp_SNMP_COMMUNITY) NewSNMP_COMMUNITY_LIST(Name string) (*SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SNMP_COMMUNITY_LIST == nil {
		t.SNMP_COMMUNITY_LIST = make(map[string]*SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SNMP_COMMUNITY_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SNMP_COMMUNITY_LIST", key)
	}

	t.SNMP_COMMUNITY_LIST[key] = &SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST{
		Name: &Name,
	}

	return t.SNMP_COMMUNITY_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSnmp_SonicSnmp_SNMP_COMMUNITY) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicSnmp_SonicSnmp_SNMP_COMMUNITY"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSnmp_SonicSnmp_SNMP_COMMUNITY) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicSnmp_SonicSnmp_SNMP_COMMUNITY) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicSnmp_SonicSnmp_SNMP_COMMUNITY.
func (*SonicSnmp_SonicSnmp_SNMP_COMMUNITY) ΛBelongingModule() string {
	return "sonic-snmp"
}


// SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST represents the /sonic-snmp/sonic-snmp/SNMP_COMMUNITY/SNMP_COMMUNITY_LIST YANG schema element.
type SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST struct {
	TYPE	E_SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE	`path:"TYPE" module:"sonic-snmp"`
	Name	*string	`path:"name" module:"sonic-snmp"`
}

// IsYANGGoStruct ensures that SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST struct, which is a YANG list entry.
func (t *SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST.
func (*SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST) ΛBelongingModule() string {
	return "sonic-snmp"
}


// SonicSnmp_SonicSnmp_SNMP_CONTACT represents the /sonic-snmp/sonic-snmp/SNMP/CONTACT YANG schema element.
type SonicSnmp_SonicSnmp_SNMP_CONTACT struct {
	Contact	*string	`path:"Contact" module:"sonic-snmp"`
}

// IsYANGGoStruct ensures that SonicSnmp_SonicSnmp_SNMP_CONTACT implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicSnmp_SonicSnmp_SNMP_CONTACT) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSnmp_SonicSnmp_SNMP_CONTACT) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicSnmp_SonicSnmp_SNMP_CONTACT"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSnmp_SonicSnmp_SNMP_CONTACT) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicSnmp_SonicSnmp_SNMP_CONTACT) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicSnmp_SonicSnmp_SNMP_CONTACT.
func (*SonicSnmp_SonicSnmp_SNMP_CONTACT) ΛBelongingModule() string {
	return "sonic-snmp"
}


// SonicSnmp_SonicSnmp_SNMP_LOCATION represents the /sonic-snmp/sonic-snmp/SNMP/LOCATION YANG schema element.
type SonicSnmp_SonicSnmp_SNMP_LOCATION struct {
	Location	*string	`path:"Location" module:"sonic-snmp"`
}

// IsYANGGoStruct ensures that SonicSnmp_SonicSnmp_SNMP_LOCATION implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicSnmp_SonicSnmp_SNMP_LOCATION) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSnmp_SonicSnmp_SNMP_LOCATION) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicSnmp_SonicSnmp_SNMP_LOCATION"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicSnmp_SonicSnmp_SNMP_LOCATION) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicSnmp_SonicSnmp_SNMP_LOCATION) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicSnmp_SonicSnmp_SNMP_LOCATION.
func (*SonicSnmp_SonicSnmp_SNMP_LOCATION) ΛBelongingModule() string {
	return "sonic-snmp"
}


// SonicStaticRoute_SonicStaticRoute represents the /sonic-static-route/sonic-static-route YANG schema element.
type SonicStaticRoute_SonicStaticRoute struct {
	STATIC_ROUTE	*SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE	`path:"STATIC_ROUTE" module:"sonic-static-route"`
}

// IsYANGGoStruct ensures that SonicStaticRoute_SonicStaticRoute implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicStaticRoute_SonicStaticRoute) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStaticRoute_SonicStaticRoute) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicStaticRoute_SonicStaticRoute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStaticRoute_SonicStaticRoute) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicStaticRoute_SonicStaticRoute) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicStaticRoute_SonicStaticRoute.
func (*SonicStaticRoute_SonicStaticRoute) ΛBelongingModule() string {
	return "sonic-static-route"
}


// SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE represents the /sonic-static-route/sonic-static-route/STATIC_ROUTE YANG schema element.
type SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE struct {
	STATIC_ROUTE_LIST	map[SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST_Key]*SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST	`path:"STATIC_ROUTE_LIST" module:"sonic-static-route"`
	STATIC_ROUTE_TEMPLATE_LIST	map[string]*SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST	`path:"STATIC_ROUTE_TEMPLATE_LIST" module:"sonic-static-route"`
}

// IsYANGGoStruct ensures that SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE) IsYANGGoStruct() {}

// SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST_Key represents the key for list STATIC_ROUTE_LIST of element /sonic-static-route/sonic-static-route/STATIC_ROUTE.
type SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST_Key struct {
	VrfName	string	`path:"vrf_name"`
	Prefix	string	`path:"prefix"`
}

// IsYANGGoKeyStruct ensures that SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST_Key key struct.
func (t SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"vrf_name": t.VrfName,
		"prefix": t.Prefix,
	}, nil
}

// NewSTATIC_ROUTE_LIST creates a new entry in the STATIC_ROUTE_LIST list of the
// SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE) NewSTATIC_ROUTE_LIST(VrfName string, Prefix string) (*SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.STATIC_ROUTE_LIST == nil {
		t.STATIC_ROUTE_LIST = make(map[SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST_Key]*SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST)
	}

	key := SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST_Key{
		VrfName: VrfName,
		Prefix: Prefix,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.STATIC_ROUTE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list STATIC_ROUTE_LIST", key)
	}

	t.STATIC_ROUTE_LIST[key] = &SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST{
		VrfName: &VrfName,
		Prefix: &Prefix,
	}

	return t.STATIC_ROUTE_LIST[key], nil
}

// NewSTATIC_ROUTE_TEMPLATE_LIST creates a new entry in the STATIC_ROUTE_TEMPLATE_LIST list of the
// SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE) NewSTATIC_ROUTE_TEMPLATE_LIST(Prefix string) (*SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.STATIC_ROUTE_TEMPLATE_LIST == nil {
		t.STATIC_ROUTE_TEMPLATE_LIST = make(map[string]*SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.STATIC_ROUTE_TEMPLATE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list STATIC_ROUTE_TEMPLATE_LIST", key)
	}

	t.STATIC_ROUTE_TEMPLATE_LIST[key] = &SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST{
		Prefix: &Prefix,
	}

	return t.STATIC_ROUTE_TEMPLATE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE.
func (*SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE) ΛBelongingModule() string {
	return "sonic-static-route"
}


// SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST represents the /sonic-static-route/sonic-static-route/STATIC_ROUTE/STATIC_ROUTE_LIST YANG schema element.
type SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST struct {
	Blackhole	*string	`path:"blackhole" module:"sonic-static-route"`
	Distance	*string	`path:"distance" module:"sonic-static-route"`
	Ifname	*string	`path:"ifname" module:"sonic-static-route"`
	Nexthop	*string	`path:"nexthop" module:"sonic-static-route"`
	NexthopVrf	*string	`path:"nexthop-vrf" module:"sonic-static-route"`
	Prefix	*string	`path:"prefix" module:"sonic-static-route"`
	VrfName	*string	`path:"vrf_name" module:"sonic-static-route"`
}

// IsYANGGoStruct ensures that SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST struct, which is a YANG list entry.
func (t *SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	if t.VrfName == nil {
		return nil, fmt.Errorf("nil value for key VrfName")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
		"vrf_name": *t.VrfName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST.
func (*SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_LIST) ΛBelongingModule() string {
	return "sonic-static-route"
}


// SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST represents the /sonic-static-route/sonic-static-route/STATIC_ROUTE/STATIC_ROUTE_TEMPLATE_LIST YANG schema element.
type SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST struct {
	Advertise	*string	`path:"advertise" module:"sonic-static-route"`
	Ifname	*string	`path:"ifname" module:"sonic-static-route"`
	Nexthop	*string	`path:"nexthop" module:"sonic-static-route"`
	Prefix	*string	`path:"prefix" module:"sonic-static-route"`
}

// IsYANGGoStruct ensures that SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST struct, which is a YANG list entry.
func (t *SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST.
func (*SonicStaticRoute_SonicStaticRoute_STATIC_ROUTE_STATIC_ROUTE_TEMPLATE_LIST) ΛBelongingModule() string {
	return "sonic-static-route"
}


// SonicStormControl_SonicStormControl represents the /sonic-storm-control/sonic-storm-control YANG schema element.
type SonicStormControl_SonicStormControl struct {
	PORT_STORM_CONTROL	*SonicStormControl_SonicStormControl_PORT_STORM_CONTROL	`path:"PORT_STORM_CONTROL" module:"sonic-storm-control"`
}

// IsYANGGoStruct ensures that SonicStormControl_SonicStormControl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicStormControl_SonicStormControl) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStormControl_SonicStormControl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicStormControl_SonicStormControl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStormControl_SonicStormControl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicStormControl_SonicStormControl) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicStormControl_SonicStormControl.
func (*SonicStormControl_SonicStormControl) ΛBelongingModule() string {
	return "sonic-storm-control"
}


// SonicStormControl_SonicStormControl_PORT_STORM_CONTROL represents the /sonic-storm-control/sonic-storm-control/PORT_STORM_CONTROL YANG schema element.
type SonicStormControl_SonicStormControl_PORT_STORM_CONTROL struct {
	PORT_STORM_CONTROL_LIST	map[SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_Key]*SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST	`path:"PORT_STORM_CONTROL_LIST" module:"sonic-storm-control"`
}

// IsYANGGoStruct ensures that SonicStormControl_SonicStormControl_PORT_STORM_CONTROL implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicStormControl_SonicStormControl_PORT_STORM_CONTROL) IsYANGGoStruct() {}

// SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_Key represents the key for list PORT_STORM_CONTROL_LIST of element /sonic-storm-control/sonic-storm-control/PORT_STORM_CONTROL.
type SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_Key struct {
	Ifname	string	`path:"ifname"`
	StormType	E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType	`path:"storm_type"`
}

// IsYANGGoKeyStruct ensures that SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_Key key struct.
func (t SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"ifname": t.Ifname,
		"storm_type": t.StormType,
	}, nil
}

// NewPORT_STORM_CONTROL_LIST creates a new entry in the PORT_STORM_CONTROL_LIST list of the
// SonicStormControl_SonicStormControl_PORT_STORM_CONTROL struct. The keys of the list are populated from the input
// arguments.
func (t *SonicStormControl_SonicStormControl_PORT_STORM_CONTROL) NewPORT_STORM_CONTROL_LIST(Ifname string, StormType E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType) (*SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PORT_STORM_CONTROL_LIST == nil {
		t.PORT_STORM_CONTROL_LIST = make(map[SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_Key]*SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST)
	}

	key := SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_Key{
		Ifname: Ifname,
		StormType: StormType,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PORT_STORM_CONTROL_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PORT_STORM_CONTROL_LIST", key)
	}

	t.PORT_STORM_CONTROL_LIST[key] = &SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST{
		Ifname: &Ifname,
		StormType: StormType,
	}

	return t.PORT_STORM_CONTROL_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStormControl_SonicStormControl_PORT_STORM_CONTROL) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicStormControl_SonicStormControl_PORT_STORM_CONTROL"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStormControl_SonicStormControl_PORT_STORM_CONTROL) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicStormControl_SonicStormControl_PORT_STORM_CONTROL) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicStormControl_SonicStormControl_PORT_STORM_CONTROL.
func (*SonicStormControl_SonicStormControl_PORT_STORM_CONTROL) ΛBelongingModule() string {
	return "sonic-storm-control"
}


// SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST represents the /sonic-storm-control/sonic-storm-control/PORT_STORM_CONTROL/PORT_STORM_CONTROL_LIST YANG schema element.
type SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST struct {
	Ifname	*string	`path:"ifname" module:"sonic-storm-control"`
	Kbps	*uint64	`path:"kbps" module:"sonic-storm-control"`
	StormType	E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType	`path:"storm_type" module:"sonic-storm-control"`
}

// IsYANGGoStruct ensures that SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST struct, which is a YANG list entry.
func (t *SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ifname == nil {
		return nil, fmt.Errorf("nil value for key Ifname")
	}


	return map[string]interface{}{
		"ifname": *t.Ifname,
		"storm_type": t.StormType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST.
func (*SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST) ΛBelongingModule() string {
	return "sonic-storm-control"
}


// SonicTelemetry_SonicTelemetry represents the /sonic-telemetry/sonic-telemetry YANG schema element.
type SonicTelemetry_SonicTelemetry struct {
	TELEMETRY	*SonicTelemetry_SonicTelemetry_TELEMETRY	`path:"TELEMETRY" module:"sonic-telemetry"`
}

// IsYANGGoStruct ensures that SonicTelemetry_SonicTelemetry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicTelemetry_SonicTelemetry) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicTelemetry_SonicTelemetry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicTelemetry_SonicTelemetry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicTelemetry_SonicTelemetry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicTelemetry_SonicTelemetry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicTelemetry_SonicTelemetry.
func (*SonicTelemetry_SonicTelemetry) ΛBelongingModule() string {
	return "sonic-telemetry"
}


// SonicTelemetry_SonicTelemetry_TELEMETRY represents the /sonic-telemetry/sonic-telemetry/TELEMETRY YANG schema element.
type SonicTelemetry_SonicTelemetry_TELEMETRY struct {
	Certs	*SonicTelemetry_SonicTelemetry_TELEMETRY_Certs	`path:"certs" module:"sonic-telemetry"`
	Gnmi	*SonicTelemetry_SonicTelemetry_TELEMETRY_Gnmi	`path:"gnmi" module:"sonic-telemetry"`
}

// IsYANGGoStruct ensures that SonicTelemetry_SonicTelemetry_TELEMETRY implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicTelemetry_SonicTelemetry_TELEMETRY) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicTelemetry_SonicTelemetry_TELEMETRY) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicTelemetry_SonicTelemetry_TELEMETRY"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicTelemetry_SonicTelemetry_TELEMETRY) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicTelemetry_SonicTelemetry_TELEMETRY) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicTelemetry_SonicTelemetry_TELEMETRY.
func (*SonicTelemetry_SonicTelemetry_TELEMETRY) ΛBelongingModule() string {
	return "sonic-telemetry"
}


// SonicTelemetry_SonicTelemetry_TELEMETRY_Certs represents the /sonic-telemetry/sonic-telemetry/TELEMETRY/certs YANG schema element.
type SonicTelemetry_SonicTelemetry_TELEMETRY_Certs struct {
	CaCrt	*string	`path:"ca_crt" module:"sonic-telemetry"`
	ServerCrt	*string	`path:"server_crt" module:"sonic-telemetry"`
	ServerKey	*string	`path:"server_key" module:"sonic-telemetry"`
}

// IsYANGGoStruct ensures that SonicTelemetry_SonicTelemetry_TELEMETRY_Certs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicTelemetry_SonicTelemetry_TELEMETRY_Certs) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicTelemetry_SonicTelemetry_TELEMETRY_Certs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicTelemetry_SonicTelemetry_TELEMETRY_Certs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicTelemetry_SonicTelemetry_TELEMETRY_Certs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicTelemetry_SonicTelemetry_TELEMETRY_Certs) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicTelemetry_SonicTelemetry_TELEMETRY_Certs.
func (*SonicTelemetry_SonicTelemetry_TELEMETRY_Certs) ΛBelongingModule() string {
	return "sonic-telemetry"
}


// SonicTelemetry_SonicTelemetry_TELEMETRY_Gnmi represents the /sonic-telemetry/sonic-telemetry/TELEMETRY/gnmi YANG schema element.
type SonicTelemetry_SonicTelemetry_TELEMETRY_Gnmi struct {
	ClientAuth	*bool	`path:"client_auth" module:"sonic-telemetry"`
	LogLevel	*uint8	`path:"log_level" module:"sonic-telemetry"`
	Port	*uint16	`path:"port" module:"sonic-telemetry"`
}

// IsYANGGoStruct ensures that SonicTelemetry_SonicTelemetry_TELEMETRY_Gnmi implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicTelemetry_SonicTelemetry_TELEMETRY_Gnmi) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicTelemetry_SonicTelemetry_TELEMETRY_Gnmi) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicTelemetry_SonicTelemetry_TELEMETRY_Gnmi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicTelemetry_SonicTelemetry_TELEMETRY_Gnmi) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicTelemetry_SonicTelemetry_TELEMETRY_Gnmi) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicTelemetry_SonicTelemetry_TELEMETRY_Gnmi.
func (*SonicTelemetry_SonicTelemetry_TELEMETRY_Gnmi) ΛBelongingModule() string {
	return "sonic-telemetry"
}


// SonicVersions_SonicVersions represents the /sonic-versions/sonic-versions YANG schema element.
type SonicVersions_SonicVersions struct {
	VERSIONS	*SonicVersions_SonicVersions_VERSIONS	`path:"VERSIONS" module:"sonic-versions"`
}

// IsYANGGoStruct ensures that SonicVersions_SonicVersions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVersions_SonicVersions) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVersions_SonicVersions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVersions_SonicVersions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVersions_SonicVersions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVersions_SonicVersions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVersions_SonicVersions.
func (*SonicVersions_SonicVersions) ΛBelongingModule() string {
	return "sonic-versions"
}


// SonicVersions_SonicVersions_VERSIONS represents the /sonic-versions/sonic-versions/VERSIONS YANG schema element.
type SonicVersions_SonicVersions_VERSIONS struct {
	DATABASE	*SonicVersions_SonicVersions_VERSIONS_DATABASE	`path:"DATABASE" module:"sonic-versions"`
}

// IsYANGGoStruct ensures that SonicVersions_SonicVersions_VERSIONS implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVersions_SonicVersions_VERSIONS) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVersions_SonicVersions_VERSIONS) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVersions_SonicVersions_VERSIONS"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVersions_SonicVersions_VERSIONS) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVersions_SonicVersions_VERSIONS) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVersions_SonicVersions_VERSIONS.
func (*SonicVersions_SonicVersions_VERSIONS) ΛBelongingModule() string {
	return "sonic-versions"
}


// SonicVersions_SonicVersions_VERSIONS_DATABASE represents the /sonic-versions/sonic-versions/VERSIONS/DATABASE YANG schema element.
type SonicVersions_SonicVersions_VERSIONS_DATABASE struct {
	VERSION	*string	`path:"VERSION" module:"sonic-versions"`
}

// IsYANGGoStruct ensures that SonicVersions_SonicVersions_VERSIONS_DATABASE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVersions_SonicVersions_VERSIONS_DATABASE) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVersions_SonicVersions_VERSIONS_DATABASE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVersions_SonicVersions_VERSIONS_DATABASE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVersions_SonicVersions_VERSIONS_DATABASE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVersions_SonicVersions_VERSIONS_DATABASE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVersions_SonicVersions_VERSIONS_DATABASE.
func (*SonicVersions_SonicVersions_VERSIONS_DATABASE) ΛBelongingModule() string {
	return "sonic-versions"
}


// SonicVlanSubInterface_SonicVlanSubInterface represents the /sonic-vlan-sub-interface/sonic-vlan-sub-interface YANG schema element.
type SonicVlanSubInterface_SonicVlanSubInterface struct {
	VLAN_SUB_INTERFACE	*SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE	`path:"VLAN_SUB_INTERFACE" module:"sonic-vlan-sub-interface"`
}

// IsYANGGoStruct ensures that SonicVlanSubInterface_SonicVlanSubInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVlanSubInterface_SonicVlanSubInterface) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlanSubInterface_SonicVlanSubInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVlanSubInterface_SonicVlanSubInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlanSubInterface_SonicVlanSubInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVlanSubInterface_SonicVlanSubInterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVlanSubInterface_SonicVlanSubInterface.
func (*SonicVlanSubInterface_SonicVlanSubInterface) ΛBelongingModule() string {
	return "sonic-vlan-sub-interface"
}


// SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE represents the /sonic-vlan-sub-interface/sonic-vlan-sub-interface/VLAN_SUB_INTERFACE YANG schema element.
type SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE struct {
	VLAN_SUB_INTERFACE_IPPREFIX_LIST	map[SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST_Key]*SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST	`path:"VLAN_SUB_INTERFACE_IPPREFIX_LIST" module:"sonic-vlan-sub-interface"`
	VLAN_SUB_INTERFACE_LIST	map[string]*SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST	`path:"VLAN_SUB_INTERFACE_LIST" module:"sonic-vlan-sub-interface"`
}

// IsYANGGoStruct ensures that SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE) IsYANGGoStruct() {}

// SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST_Key represents the key for list VLAN_SUB_INTERFACE_IPPREFIX_LIST of element /sonic-vlan-sub-interface/sonic-vlan-sub-interface/VLAN_SUB_INTERFACE.
type SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST_Key struct {
	Name	string	`path:"name"`
	IpPrefix	string	`path:"ip-prefix"`
}

// IsYANGGoKeyStruct ensures that SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST_Key key struct.
func (t SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
		"ip-prefix": t.IpPrefix,
	}, nil
}

// NewVLAN_SUB_INTERFACE_IPPREFIX_LIST creates a new entry in the VLAN_SUB_INTERFACE_IPPREFIX_LIST list of the
// SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE) NewVLAN_SUB_INTERFACE_IPPREFIX_LIST(Name string, IpPrefix string) (*SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VLAN_SUB_INTERFACE_IPPREFIX_LIST == nil {
		t.VLAN_SUB_INTERFACE_IPPREFIX_LIST = make(map[SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST_Key]*SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST)
	}

	key := SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST_Key{
		Name: Name,
		IpPrefix: IpPrefix,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VLAN_SUB_INTERFACE_IPPREFIX_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VLAN_SUB_INTERFACE_IPPREFIX_LIST", key)
	}

	t.VLAN_SUB_INTERFACE_IPPREFIX_LIST[key] = &SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST{
		Name: &Name,
		IpPrefix: &IpPrefix,
	}

	return t.VLAN_SUB_INTERFACE_IPPREFIX_LIST[key], nil
}

// NewVLAN_SUB_INTERFACE_LIST creates a new entry in the VLAN_SUB_INTERFACE_LIST list of the
// SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE) NewVLAN_SUB_INTERFACE_LIST(Name string) (*SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VLAN_SUB_INTERFACE_LIST == nil {
		t.VLAN_SUB_INTERFACE_LIST = make(map[string]*SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VLAN_SUB_INTERFACE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VLAN_SUB_INTERFACE_LIST", key)
	}

	t.VLAN_SUB_INTERFACE_LIST[key] = &SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST{
		Name: &Name,
	}

	return t.VLAN_SUB_INTERFACE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE.
func (*SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE) ΛBelongingModule() string {
	return "sonic-vlan-sub-interface"
}


// SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST represents the /sonic-vlan-sub-interface/sonic-vlan-sub-interface/VLAN_SUB_INTERFACE/VLAN_SUB_INTERFACE_IPPREFIX_LIST YANG schema element.
type SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST struct {
	IpPrefix	*string	`path:"ip-prefix" module:"sonic-vlan-sub-interface"`
	Name	*string	`path:"name" module:"sonic-vlan-sub-interface"`
}

// IsYANGGoStruct ensures that SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST struct, which is a YANG list entry.
func (t *SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST.
func (*SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_IPPREFIX_LIST) ΛBelongingModule() string {
	return "sonic-vlan-sub-interface"
}


// SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST represents the /sonic-vlan-sub-interface/sonic-vlan-sub-interface/VLAN_SUB_INTERFACE/VLAN_SUB_INTERFACE_LIST YANG schema element.
type SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST struct {
	AdminStatus	E_SonicTypes_AdminStatus	`path:"admin_status" module:"sonic-vlan-sub-interface"`
	LoopbackAction	*string	`path:"loopback_action" module:"sonic-vlan-sub-interface"`
	Name	*string	`path:"name" module:"sonic-vlan-sub-interface"`
	VrfName	*string	`path:"vrf_name" module:"sonic-vlan-sub-interface"`
}

// IsYANGGoStruct ensures that SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST struct, which is a YANG list entry.
func (t *SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST.
func (*SonicVlanSubInterface_SonicVlanSubInterface_VLAN_SUB_INTERFACE_VLAN_SUB_INTERFACE_LIST) ΛBelongingModule() string {
	return "sonic-vlan-sub-interface"
}


// SonicVlan_SonicVlan represents the /sonic-vlan/sonic-vlan YANG schema element.
type SonicVlan_SonicVlan struct {
	VLAN	*SonicVlan_SonicVlan_VLAN	`path:"VLAN" module:"sonic-vlan"`
	VLAN_INTERFACE	*SonicVlan_SonicVlan_VLAN_INTERFACE	`path:"VLAN_INTERFACE" module:"sonic-vlan"`
	VLAN_MEMBER	*SonicVlan_SonicVlan_VLAN_MEMBER	`path:"VLAN_MEMBER" module:"sonic-vlan"`
}

// IsYANGGoStruct ensures that SonicVlan_SonicVlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVlan_SonicVlan) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVlan_SonicVlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVlan_SonicVlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVlan_SonicVlan.
func (*SonicVlan_SonicVlan) ΛBelongingModule() string {
	return "sonic-vlan"
}


// SonicVlan_SonicVlan_VLAN represents the /sonic-vlan/sonic-vlan/VLAN YANG schema element.
type SonicVlan_SonicVlan_VLAN struct {
	VLAN_LIST	map[string]*SonicVlan_SonicVlan_VLAN_VLAN_LIST	`path:"VLAN_LIST" module:"sonic-vlan"`
}

// IsYANGGoStruct ensures that SonicVlan_SonicVlan_VLAN implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVlan_SonicVlan_VLAN) IsYANGGoStruct() {}

// NewVLAN_LIST creates a new entry in the VLAN_LIST list of the
// SonicVlan_SonicVlan_VLAN struct. The keys of the list are populated from the input
// arguments.
func (t *SonicVlan_SonicVlan_VLAN) NewVLAN_LIST(Name string) (*SonicVlan_SonicVlan_VLAN_VLAN_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VLAN_LIST == nil {
		t.VLAN_LIST = make(map[string]*SonicVlan_SonicVlan_VLAN_VLAN_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VLAN_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VLAN_LIST", key)
	}

	t.VLAN_LIST[key] = &SonicVlan_SonicVlan_VLAN_VLAN_LIST{
		Name: &Name,
	}

	return t.VLAN_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVlan_SonicVlan_VLAN"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVlan_SonicVlan_VLAN) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVlan_SonicVlan_VLAN.
func (*SonicVlan_SonicVlan_VLAN) ΛBelongingModule() string {
	return "sonic-vlan"
}


// SonicVlan_SonicVlan_VLAN_INTERFACE represents the /sonic-vlan/sonic-vlan/VLAN_INTERFACE YANG schema element.
type SonicVlan_SonicVlan_VLAN_INTERFACE struct {
	VLAN_INTERFACE_IPPREFIX_LIST	map[SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Key]*SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST	`path:"VLAN_INTERFACE_IPPREFIX_LIST" module:"sonic-vlan"`
	VLAN_INTERFACE_LIST	map[string]*SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST	`path:"VLAN_INTERFACE_LIST" module:"sonic-vlan"`
}

// IsYANGGoStruct ensures that SonicVlan_SonicVlan_VLAN_INTERFACE implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVlan_SonicVlan_VLAN_INTERFACE) IsYANGGoStruct() {}

// SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Key represents the key for list VLAN_INTERFACE_IPPREFIX_LIST of element /sonic-vlan/sonic-vlan/VLAN_INTERFACE.
type SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Key struct {
	Name	string	`path:"name"`
	IpPrefix	string	`path:"ip-prefix"`
}

// IsYANGGoKeyStruct ensures that SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Key key struct.
func (t SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
		"ip-prefix": t.IpPrefix,
	}, nil
}

// NewVLAN_INTERFACE_IPPREFIX_LIST creates a new entry in the VLAN_INTERFACE_IPPREFIX_LIST list of the
// SonicVlan_SonicVlan_VLAN_INTERFACE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicVlan_SonicVlan_VLAN_INTERFACE) NewVLAN_INTERFACE_IPPREFIX_LIST(Name string, IpPrefix string) (*SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VLAN_INTERFACE_IPPREFIX_LIST == nil {
		t.VLAN_INTERFACE_IPPREFIX_LIST = make(map[SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Key]*SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST)
	}

	key := SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Key{
		Name: Name,
		IpPrefix: IpPrefix,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VLAN_INTERFACE_IPPREFIX_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VLAN_INTERFACE_IPPREFIX_LIST", key)
	}

	t.VLAN_INTERFACE_IPPREFIX_LIST[key] = &SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST{
		Name: &Name,
		IpPrefix: &IpPrefix,
	}

	return t.VLAN_INTERFACE_IPPREFIX_LIST[key], nil
}

// NewVLAN_INTERFACE_LIST creates a new entry in the VLAN_INTERFACE_LIST list of the
// SonicVlan_SonicVlan_VLAN_INTERFACE struct. The keys of the list are populated from the input
// arguments.
func (t *SonicVlan_SonicVlan_VLAN_INTERFACE) NewVLAN_INTERFACE_LIST(Name string) (*SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VLAN_INTERFACE_LIST == nil {
		t.VLAN_INTERFACE_LIST = make(map[string]*SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VLAN_INTERFACE_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VLAN_INTERFACE_LIST", key)
	}

	t.VLAN_INTERFACE_LIST[key] = &SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST{
		Name: &Name,
	}

	return t.VLAN_INTERFACE_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN_INTERFACE) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVlan_SonicVlan_VLAN_INTERFACE"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN_INTERFACE) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVlan_SonicVlan_VLAN_INTERFACE) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVlan_SonicVlan_VLAN_INTERFACE.
func (*SonicVlan_SonicVlan_VLAN_INTERFACE) ΛBelongingModule() string {
	return "sonic-vlan"
}


// SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST represents the /sonic-vlan/sonic-vlan/VLAN_INTERFACE/VLAN_INTERFACE_IPPREFIX_LIST YANG schema element.
type SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST struct {
	Family	E_SonicTypes_IpFamily	`path:"family" module:"sonic-vlan"`
	IpPrefix	*string	`path:"ip-prefix" module:"sonic-vlan"`
	Name	*string	`path:"name" module:"sonic-vlan"`
	Scope	E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope	`path:"scope" module:"sonic-vlan"`
}

// IsYANGGoStruct ensures that SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST struct, which is a YANG list entry.
func (t *SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST.
func (*SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST) ΛBelongingModule() string {
	return "sonic-vlan"
}


// SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST represents the /sonic-vlan/sonic-vlan/VLAN_INTERFACE/VLAN_INTERFACE_LIST YANG schema element.
type SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST struct {
	GratArp	*string	`path:"grat_arp" module:"sonic-vlan"`
	LoopbackAction	*string	`path:"loopback_action" module:"sonic-vlan"`
	Mpls	E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls	`path:"mpls" module:"sonic-vlan"`
	Name	*string	`path:"name" module:"sonic-vlan"`
	NatZone	*uint8	`path:"nat_zone" module:"sonic-vlan"`
	ProxyArp	*string	`path:"proxy_arp" module:"sonic-vlan"`
	VrfName	*string	`path:"vrf_name" module:"sonic-vlan"`
}

// IsYANGGoStruct ensures that SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST struct, which is a YANG list entry.
func (t *SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST.
func (*SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST) ΛBelongingModule() string {
	return "sonic-vlan"
}


// SonicVlan_SonicVlan_VLAN_MEMBER represents the /sonic-vlan/sonic-vlan/VLAN_MEMBER YANG schema element.
type SonicVlan_SonicVlan_VLAN_MEMBER struct {
	VLAN_MEMBER_LIST	map[SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST_Key]*SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST	`path:"VLAN_MEMBER_LIST" module:"sonic-vlan"`
}

// IsYANGGoStruct ensures that SonicVlan_SonicVlan_VLAN_MEMBER implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVlan_SonicVlan_VLAN_MEMBER) IsYANGGoStruct() {}

// SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST_Key represents the key for list VLAN_MEMBER_LIST of element /sonic-vlan/sonic-vlan/VLAN_MEMBER.
type SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST_Key struct {
	Name	string	`path:"name"`
	Port	string	`path:"port"`
}

// IsYANGGoKeyStruct ensures that SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST_Key key struct.
func (t SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
		"port": t.Port,
	}, nil
}

// NewVLAN_MEMBER_LIST creates a new entry in the VLAN_MEMBER_LIST list of the
// SonicVlan_SonicVlan_VLAN_MEMBER struct. The keys of the list are populated from the input
// arguments.
func (t *SonicVlan_SonicVlan_VLAN_MEMBER) NewVLAN_MEMBER_LIST(Name string, Port string) (*SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VLAN_MEMBER_LIST == nil {
		t.VLAN_MEMBER_LIST = make(map[SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST_Key]*SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST)
	}

	key := SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST_Key{
		Name: Name,
		Port: Port,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VLAN_MEMBER_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VLAN_MEMBER_LIST", key)
	}

	t.VLAN_MEMBER_LIST[key] = &SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST{
		Name: &Name,
		Port: &Port,
	}

	return t.VLAN_MEMBER_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN_MEMBER) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVlan_SonicVlan_VLAN_MEMBER"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN_MEMBER) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVlan_SonicVlan_VLAN_MEMBER) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVlan_SonicVlan_VLAN_MEMBER.
func (*SonicVlan_SonicVlan_VLAN_MEMBER) ΛBelongingModule() string {
	return "sonic-vlan"
}


// SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST represents the /sonic-vlan/sonic-vlan/VLAN_MEMBER/VLAN_MEMBER_LIST YANG schema element.
type SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST struct {
	Name	*string	`path:"name" module:"sonic-vlan"`
	Port	*string	`path:"port" module:"sonic-vlan"`
	TaggingMode	E_SonicTypes_VlanTaggingMode	`path:"tagging_mode" module:"sonic-vlan"`
}

// IsYANGGoStruct ensures that SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST struct, which is a YANG list entry.
func (t *SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	if t.Port == nil {
		return nil, fmt.Errorf("nil value for key Port")
	}

	return map[string]interface{}{
		"name": *t.Name,
		"port": *t.Port,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST.
func (*SonicVlan_SonicVlan_VLAN_MEMBER_VLAN_MEMBER_LIST) ΛBelongingModule() string {
	return "sonic-vlan"
}


// SonicVlan_SonicVlan_VLAN_VLAN_LIST represents the /sonic-vlan/sonic-vlan/VLAN/VLAN_LIST YANG schema element.
type SonicVlan_SonicVlan_VLAN_VLAN_LIST struct {
	AdminStatus	E_SonicTypes_AdminStatus	`path:"admin_status" module:"sonic-vlan"`
	Alias	*string	`path:"alias" module:"sonic-vlan"`
	Description	*string	`path:"description" module:"sonic-vlan"`
	DhcpServers	[]string	`path:"dhcp_servers" module:"sonic-vlan"`
	Dhcpv6Servers	[]string	`path:"dhcpv6_servers" module:"sonic-vlan"`
	Mac	*string	`path:"mac" module:"sonic-vlan"`
	Mtu	*uint16	`path:"mtu" module:"sonic-vlan"`
	Name	*string	`path:"name" module:"sonic-vlan"`
	Vlanid	*uint16	`path:"vlanid" module:"sonic-vlan"`
}

// IsYANGGoStruct ensures that SonicVlan_SonicVlan_VLAN_VLAN_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVlan_SonicVlan_VLAN_VLAN_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicVlan_SonicVlan_VLAN_VLAN_LIST struct, which is a YANG list entry.
func (t *SonicVlan_SonicVlan_VLAN_VLAN_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN_VLAN_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVlan_SonicVlan_VLAN_VLAN_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVlan_SonicVlan_VLAN_VLAN_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVlan_SonicVlan_VLAN_VLAN_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVlan_SonicVlan_VLAN_VLAN_LIST.
func (*SonicVlan_SonicVlan_VLAN_VLAN_LIST) ΛBelongingModule() string {
	return "sonic-vlan"
}


// SonicVrf_SonicVrf represents the /sonic-vrf/sonic-vrf YANG schema element.
type SonicVrf_SonicVrf struct {
	VRF	*SonicVrf_SonicVrf_VRF	`path:"VRF" module:"sonic-vrf"`
}

// IsYANGGoStruct ensures that SonicVrf_SonicVrf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVrf_SonicVrf) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVrf_SonicVrf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVrf_SonicVrf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVrf_SonicVrf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVrf_SonicVrf) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVrf_SonicVrf.
func (*SonicVrf_SonicVrf) ΛBelongingModule() string {
	return "sonic-vrf"
}


// SonicVrf_SonicVrf_VRF represents the /sonic-vrf/sonic-vrf/VRF YANG schema element.
type SonicVrf_SonicVrf_VRF struct {
	VRF_LIST	map[string]*SonicVrf_SonicVrf_VRF_VRF_LIST	`path:"VRF_LIST" module:"sonic-vrf"`
}

// IsYANGGoStruct ensures that SonicVrf_SonicVrf_VRF implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVrf_SonicVrf_VRF) IsYANGGoStruct() {}

// NewVRF_LIST creates a new entry in the VRF_LIST list of the
// SonicVrf_SonicVrf_VRF struct. The keys of the list are populated from the input
// arguments.
func (t *SonicVrf_SonicVrf_VRF) NewVRF_LIST(Name string) (*SonicVrf_SonicVrf_VRF_VRF_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VRF_LIST == nil {
		t.VRF_LIST = make(map[string]*SonicVrf_SonicVrf_VRF_VRF_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VRF_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VRF_LIST", key)
	}

	t.VRF_LIST[key] = &SonicVrf_SonicVrf_VRF_VRF_LIST{
		Name: &Name,
	}

	return t.VRF_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVrf_SonicVrf_VRF) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVrf_SonicVrf_VRF"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVrf_SonicVrf_VRF) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVrf_SonicVrf_VRF) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVrf_SonicVrf_VRF.
func (*SonicVrf_SonicVrf_VRF) ΛBelongingModule() string {
	return "sonic-vrf"
}


// SonicVrf_SonicVrf_VRF_VRF_LIST represents the /sonic-vrf/sonic-vrf/VRF/VRF_LIST YANG schema element.
type SonicVrf_SonicVrf_VRF_VRF_LIST struct {
	Fallback	*bool	`path:"fallback" module:"sonic-vrf"`
	Name	*string	`path:"name" module:"sonic-vrf"`
}

// IsYANGGoStruct ensures that SonicVrf_SonicVrf_VRF_VRF_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVrf_SonicVrf_VRF_VRF_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicVrf_SonicVrf_VRF_VRF_LIST struct, which is a YANG list entry.
func (t *SonicVrf_SonicVrf_VRF_VRF_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVrf_SonicVrf_VRF_VRF_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVrf_SonicVrf_VRF_VRF_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVrf_SonicVrf_VRF_VRF_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVrf_SonicVrf_VRF_VRF_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVrf_SonicVrf_VRF_VRF_LIST.
func (*SonicVrf_SonicVrf_VRF_VRF_LIST) ΛBelongingModule() string {
	return "sonic-vrf"
}


// SonicVxlan_SonicVxlan represents the /sonic-vxlan/sonic-vxlan YANG schema element.
type SonicVxlan_SonicVxlan struct {
	VXLAN_EVPN_NVO	*SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO	`path:"VXLAN_EVPN_NVO" module:"sonic-vxlan"`
	VXLAN_TUNNEL	*SonicVxlan_SonicVxlan_VXLAN_TUNNEL	`path:"VXLAN_TUNNEL" module:"sonic-vxlan"`
	VXLAN_TUNNEL_MAP	*SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP	`path:"VXLAN_TUNNEL_MAP" module:"sonic-vxlan"`
}

// IsYANGGoStruct ensures that SonicVxlan_SonicVxlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVxlan_SonicVxlan) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVxlan_SonicVxlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVxlan_SonicVxlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVxlan_SonicVxlan.
func (*SonicVxlan_SonicVxlan) ΛBelongingModule() string {
	return "sonic-vxlan"
}


// SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO represents the /sonic-vxlan/sonic-vxlan/VXLAN_EVPN_NVO YANG schema element.
type SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO struct {
	VXLAN_EVPN_NVO_LIST	map[string]*SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST	`path:"VXLAN_EVPN_NVO_LIST" module:"sonic-vxlan"`
}

// IsYANGGoStruct ensures that SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO) IsYANGGoStruct() {}

// NewVXLAN_EVPN_NVO_LIST creates a new entry in the VXLAN_EVPN_NVO_LIST list of the
// SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO struct. The keys of the list are populated from the input
// arguments.
func (t *SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO) NewVXLAN_EVPN_NVO_LIST(Name string) (*SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VXLAN_EVPN_NVO_LIST == nil {
		t.VXLAN_EVPN_NVO_LIST = make(map[string]*SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VXLAN_EVPN_NVO_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VXLAN_EVPN_NVO_LIST", key)
	}

	t.VXLAN_EVPN_NVO_LIST[key] = &SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST{
		Name: &Name,
	}

	return t.VXLAN_EVPN_NVO_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO.
func (*SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO) ΛBelongingModule() string {
	return "sonic-vxlan"
}


// SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST represents the /sonic-vxlan/sonic-vxlan/VXLAN_EVPN_NVO/VXLAN_EVPN_NVO_LIST YANG schema element.
type SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST struct {
	Name	*string	`path:"name" module:"sonic-vxlan"`
	SourceVtep	*string	`path:"source_vtep" module:"sonic-vxlan"`
}

// IsYANGGoStruct ensures that SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST struct, which is a YANG list entry.
func (t *SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST.
func (*SonicVxlan_SonicVxlan_VXLAN_EVPN_NVO_VXLAN_EVPN_NVO_LIST) ΛBelongingModule() string {
	return "sonic-vxlan"
}


// SonicVxlan_SonicVxlan_VXLAN_TUNNEL represents the /sonic-vxlan/sonic-vxlan/VXLAN_TUNNEL YANG schema element.
type SonicVxlan_SonicVxlan_VXLAN_TUNNEL struct {
	VXLAN_TUNNEL_LIST	map[string]*SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST	`path:"VXLAN_TUNNEL_LIST" module:"sonic-vxlan"`
}

// IsYANGGoStruct ensures that SonicVxlan_SonicVxlan_VXLAN_TUNNEL implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVxlan_SonicVxlan_VXLAN_TUNNEL) IsYANGGoStruct() {}

// NewVXLAN_TUNNEL_LIST creates a new entry in the VXLAN_TUNNEL_LIST list of the
// SonicVxlan_SonicVxlan_VXLAN_TUNNEL struct. The keys of the list are populated from the input
// arguments.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL) NewVXLAN_TUNNEL_LIST(Name string) (*SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VXLAN_TUNNEL_LIST == nil {
		t.VXLAN_TUNNEL_LIST = make(map[string]*SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VXLAN_TUNNEL_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VXLAN_TUNNEL_LIST", key)
	}

	t.VXLAN_TUNNEL_LIST[key] = &SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST{
		Name: &Name,
	}

	return t.VXLAN_TUNNEL_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVxlan_SonicVxlan_VXLAN_TUNNEL"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVxlan_SonicVxlan_VXLAN_TUNNEL.
func (*SonicVxlan_SonicVxlan_VXLAN_TUNNEL) ΛBelongingModule() string {
	return "sonic-vxlan"
}


// SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP represents the /sonic-vxlan/sonic-vxlan/VXLAN_TUNNEL_MAP YANG schema element.
type SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP struct {
	VXLAN_TUNNEL_MAP_LIST	map[SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST_Key]*SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST	`path:"VXLAN_TUNNEL_MAP_LIST" module:"sonic-vxlan"`
}

// IsYANGGoStruct ensures that SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP) IsYANGGoStruct() {}

// SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST_Key represents the key for list VXLAN_TUNNEL_MAP_LIST of element /sonic-vxlan/sonic-vxlan/VXLAN_TUNNEL_MAP.
type SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST_Key struct {
	Name	string	`path:"name"`
	Mapname	string	`path:"mapname"`
}

// IsYANGGoKeyStruct ensures that SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST_Key key struct.
func (t SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
		"mapname": t.Mapname,
	}, nil
}

// NewVXLAN_TUNNEL_MAP_LIST creates a new entry in the VXLAN_TUNNEL_MAP_LIST list of the
// SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP struct. The keys of the list are populated from the input
// arguments.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP) NewVXLAN_TUNNEL_MAP_LIST(Name string, Mapname string) (*SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VXLAN_TUNNEL_MAP_LIST == nil {
		t.VXLAN_TUNNEL_MAP_LIST = make(map[SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST_Key]*SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST)
	}

	key := SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST_Key{
		Name: Name,
		Mapname: Mapname,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VXLAN_TUNNEL_MAP_LIST[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VXLAN_TUNNEL_MAP_LIST", key)
	}

	t.VXLAN_TUNNEL_MAP_LIST[key] = &SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST{
		Name: &Name,
		Mapname: &Mapname,
	}

	return t.VXLAN_TUNNEL_MAP_LIST[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP.
func (*SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP) ΛBelongingModule() string {
	return "sonic-vxlan"
}


// SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST represents the /sonic-vxlan/sonic-vxlan/VXLAN_TUNNEL_MAP/VXLAN_TUNNEL_MAP_LIST YANG schema element.
type SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST struct {
	Mapname	*string	`path:"mapname" module:"sonic-vxlan"`
	Name	*string	`path:"name" module:"sonic-vxlan"`
	Vlan	*string	`path:"vlan" module:"sonic-vxlan"`
	Vni	*uint32	`path:"vni" module:"sonic-vxlan"`
}

// IsYANGGoStruct ensures that SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST struct, which is a YANG list entry.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Mapname == nil {
		return nil, fmt.Errorf("nil value for key Mapname")
	}

	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"mapname": *t.Mapname,
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST.
func (*SonicVxlan_SonicVxlan_VXLAN_TUNNEL_MAP_VXLAN_TUNNEL_MAP_LIST) ΛBelongingModule() string {
	return "sonic-vxlan"
}


// SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST represents the /sonic-vxlan/sonic-vxlan/VXLAN_TUNNEL/VXLAN_TUNNEL_LIST YANG schema element.
type SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST struct {
	Name	*string	`path:"name" module:"sonic-vxlan"`
	SrcIp	*string	`path:"src_ip" module:"sonic-vxlan"`
}

// IsYANGGoStruct ensures that SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST struct, which is a YANG list entry.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST.
func (*SonicVxlan_SonicVxlan_VXLAN_TUNNEL_VXLAN_TUNNEL_LIST) ΛBelongingModule() string {
	return "sonic-vxlan"
}


// E_SonicFlexCounter_FlexStatus is a derived int64 type which is used to represent
// the enumerated node SonicFlexCounter_FlexStatus. An additional value named
// SonicFlexCounter_FlexStatus_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicFlexCounter_FlexStatus int64

// IsYANGGoEnum ensures that SonicFlexCounter_FlexStatus implements the yang.GoEnum
// interface. This ensures that SonicFlexCounter_FlexStatus can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicFlexCounter_FlexStatus) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicFlexCounter_FlexStatus.
func (E_SonicFlexCounter_FlexStatus) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicFlexCounter_FlexStatus.
func (e E_SonicFlexCounter_FlexStatus) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicFlexCounter_FlexStatus")
}

const (
	// SonicFlexCounter_FlexStatus_UNSET corresponds to the value UNSET of SonicFlexCounter_FlexStatus
	SonicFlexCounter_FlexStatus_UNSET E_SonicFlexCounter_FlexStatus = 0
	// SonicFlexCounter_FlexStatus_enable corresponds to the value enable of SonicFlexCounter_FlexStatus
	SonicFlexCounter_FlexStatus_enable E_SonicFlexCounter_FlexStatus = 1
	// SonicFlexCounter_FlexStatus_disable corresponds to the value disable of SonicFlexCounter_FlexStatus
	SonicFlexCounter_FlexStatus_disable E_SonicFlexCounter_FlexStatus = 2
)


// E_SonicHash_HashField is a derived int64 type which is used to represent
// the enumerated node SonicHash_HashField. An additional value named
// SonicHash_HashField_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicHash_HashField int64

// IsYANGGoEnum ensures that SonicHash_HashField implements the yang.GoEnum
// interface. This ensures that SonicHash_HashField can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicHash_HashField) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicHash_HashField.
func (E_SonicHash_HashField) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicHash_HashField.
func (e E_SonicHash_HashField) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicHash_HashField")
}

const (
	// SonicHash_HashField_UNSET corresponds to the value UNSET of SonicHash_HashField
	SonicHash_HashField_UNSET E_SonicHash_HashField = 0
	// SonicHash_HashField_IN_PORT corresponds to the value IN_PORT of SonicHash_HashField
	SonicHash_HashField_IN_PORT E_SonicHash_HashField = 1
	// SonicHash_HashField_DST_MAC corresponds to the value DST_MAC of SonicHash_HashField
	SonicHash_HashField_DST_MAC E_SonicHash_HashField = 2
	// SonicHash_HashField_SRC_MAC corresponds to the value SRC_MAC of SonicHash_HashField
	SonicHash_HashField_SRC_MAC E_SonicHash_HashField = 3
	// SonicHash_HashField_ETHERTYPE corresponds to the value ETHERTYPE of SonicHash_HashField
	SonicHash_HashField_ETHERTYPE E_SonicHash_HashField = 4
	// SonicHash_HashField_VLAN_ID corresponds to the value VLAN_ID of SonicHash_HashField
	SonicHash_HashField_VLAN_ID E_SonicHash_HashField = 5
	// SonicHash_HashField_IP_PROTOCOL corresponds to the value IP_PROTOCOL of SonicHash_HashField
	SonicHash_HashField_IP_PROTOCOL E_SonicHash_HashField = 6
	// SonicHash_HashField_DST_IP corresponds to the value DST_IP of SonicHash_HashField
	SonicHash_HashField_DST_IP E_SonicHash_HashField = 7
	// SonicHash_HashField_SRC_IP corresponds to the value SRC_IP of SonicHash_HashField
	SonicHash_HashField_SRC_IP E_SonicHash_HashField = 8
	// SonicHash_HashField_L4_DST_PORT corresponds to the value L4_DST_PORT of SonicHash_HashField
	SonicHash_HashField_L4_DST_PORT E_SonicHash_HashField = 9
	// SonicHash_HashField_L4_SRC_PORT corresponds to the value L4_SRC_PORT of SonicHash_HashField
	SonicHash_HashField_L4_SRC_PORT E_SonicHash_HashField = 10
	// SonicHash_HashField_INNER_DST_MAC corresponds to the value INNER_DST_MAC of SonicHash_HashField
	SonicHash_HashField_INNER_DST_MAC E_SonicHash_HashField = 11
	// SonicHash_HashField_INNER_SRC_MAC corresponds to the value INNER_SRC_MAC of SonicHash_HashField
	SonicHash_HashField_INNER_SRC_MAC E_SonicHash_HashField = 12
	// SonicHash_HashField_INNER_ETHERTYPE corresponds to the value INNER_ETHERTYPE of SonicHash_HashField
	SonicHash_HashField_INNER_ETHERTYPE E_SonicHash_HashField = 13
	// SonicHash_HashField_INNER_IP_PROTOCOL corresponds to the value INNER_IP_PROTOCOL of SonicHash_HashField
	SonicHash_HashField_INNER_IP_PROTOCOL E_SonicHash_HashField = 14
	// SonicHash_HashField_INNER_DST_IP corresponds to the value INNER_DST_IP of SonicHash_HashField
	SonicHash_HashField_INNER_DST_IP E_SonicHash_HashField = 15
	// SonicHash_HashField_INNER_SRC_IP corresponds to the value INNER_SRC_IP of SonicHash_HashField
	SonicHash_HashField_INNER_SRC_IP E_SonicHash_HashField = 16
	// SonicHash_HashField_INNER_L4_DST_PORT corresponds to the value INNER_L4_DST_PORT of SonicHash_HashField
	SonicHash_HashField_INNER_L4_DST_PORT E_SonicHash_HashField = 17
	// SonicHash_HashField_INNER_L4_SRC_PORT corresponds to the value INNER_L4_SRC_PORT of SonicHash_HashField
	SonicHash_HashField_INNER_L4_SRC_PORT E_SonicHash_HashField = 18
)


// E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope is a derived int64 type which is used to represent
// the enumerated node SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope. An additional value named
// SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope int64

// IsYANGGoEnum ensures that SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope implements the yang.GoEnum
// interface. This ensures that SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope.
func (E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope.
func (e E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope")
}

const (
	// SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope_UNSET corresponds to the value UNSET of SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope
	SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope_UNSET E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope = 0
	// SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope_global corresponds to the value global of SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope
	SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope_global E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope = 1
	// SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope_local corresponds to the value local of SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope
	SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope_local E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope = 2
)


// E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls is a derived int64 type which is used to represent
// the enumerated node SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls. An additional value named
// SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls int64

// IsYANGGoEnum ensures that SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls implements the yang.GoEnum
// interface. This ensures that SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls.
func (E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls.
func (e E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls")
}

const (
	// SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls_UNSET corresponds to the value UNSET of SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls
	SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls_UNSET E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls = 0
	// SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls_enable corresponds to the value enable of SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls
	SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls_enable E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls = 1
	// SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls_disable corresponds to the value disable of SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls
	SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls_disable E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls = 2
)


// E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode is a derived int64 type which is used to represent
// the enumerated node SonicLldp_SonicLldp_LLDP_GLOBAL_Mode. An additional value named
// SonicLldp_SonicLldp_LLDP_GLOBAL_Mode_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode int64

// IsYANGGoEnum ensures that SonicLldp_SonicLldp_LLDP_GLOBAL_Mode implements the yang.GoEnum
// interface. This ensures that SonicLldp_SonicLldp_LLDP_GLOBAL_Mode can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicLldp_SonicLldp_LLDP_GLOBAL_Mode.
func (E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode.
func (e E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode")
}

const (
	// SonicLldp_SonicLldp_LLDP_GLOBAL_Mode_UNSET corresponds to the value UNSET of SonicLldp_SonicLldp_LLDP_GLOBAL_Mode
	SonicLldp_SonicLldp_LLDP_GLOBAL_Mode_UNSET E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode = 0
	// SonicLldp_SonicLldp_LLDP_GLOBAL_Mode_RECEIVE corresponds to the value RECEIVE of SonicLldp_SonicLldp_LLDP_GLOBAL_Mode
	SonicLldp_SonicLldp_LLDP_GLOBAL_Mode_RECEIVE E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode = 1
	// SonicLldp_SonicLldp_LLDP_GLOBAL_Mode_TRANSMIT corresponds to the value TRANSMIT of SonicLldp_SonicLldp_LLDP_GLOBAL_Mode
	SonicLldp_SonicLldp_LLDP_GLOBAL_Mode_TRANSMIT E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode = 2
)


// E_SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope is a derived int64 type which is used to represent
// the enumerated node SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope. An additional value named
// SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope int64

// IsYANGGoEnum ensures that SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope implements the yang.GoEnum
// interface. This ensures that SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope.
func (E_SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope.
func (e E_SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope")
}

const (
	// SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope_UNSET corresponds to the value UNSET of SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope
	SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope_UNSET E_SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope = 0
	// SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope_global corresponds to the value global of SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope
	SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope_global E_SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope = 1
	// SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope_local corresponds to the value local of SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope
	SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope_local E_SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope = 2
)


// E_SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp is a derived int64 type which is used to represent
// the enumerated node SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp. An additional value named
// SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp int64

// IsYANGGoEnum ensures that SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp implements the yang.GoEnum
// interface. This ensures that SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp.
func (E_SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp.
func (e E_SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp")
}

const (
	// SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp_UNSET corresponds to the value UNSET of SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp
	SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp_UNSET E_SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp = 0
	// SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp_enable corresponds to the value enable of SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp
	SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp_enable E_SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp = 1
)


// E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType is a derived int64 type which is used to represent
// the enumerated node SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType. An additional value named
// SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType int64

// IsYANGGoEnum ensures that SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType implements the yang.GoEnum
// interface. This ensures that SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType.
func (E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType.
func (e E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType")
}

const (
	// SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType_UNSET corresponds to the value UNSET of SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType
	SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType_UNSET E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType = 0
	// SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType_active_active corresponds to the value active_active of SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType
	SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType_active_active E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType = 1
	// SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType_active_standby corresponds to the value active_standby of SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType
	SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType_active_standby E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType = 2
)


// E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State is a derived int64 type which is used to represent
// the enumerated node SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State. An additional value named
// SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State int64

// IsYANGGoEnum ensures that SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State implements the yang.GoEnum
// interface. This ensures that SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State.
func (E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State.
func (e E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State")
}

const (
	// SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State_UNSET corresponds to the value UNSET of SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State
	SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State_UNSET E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State = 0
	// SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State_auto corresponds to the value auto of SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State
	SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State_auto E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State = 1
	// SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State_manual corresponds to the value manual of SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State
	SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State_manual E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State = 2
	// SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State_detach corresponds to the value detach of SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State
	SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State_detach E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State = 3
	// SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State_active corresponds to the value active of SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State
	SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State_active E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State = 4
	// SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State_standby corresponds to the value standby of SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State
	SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State_standby E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State = 5
)


// E_SonicNat_NatType is a derived int64 type which is used to represent
// the enumerated node SonicNat_NatType. An additional value named
// SonicNat_NatType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicNat_NatType int64

// IsYANGGoEnum ensures that SonicNat_NatType implements the yang.GoEnum
// interface. This ensures that SonicNat_NatType can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicNat_NatType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicNat_NatType.
func (E_SonicNat_NatType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicNat_NatType.
func (e E_SonicNat_NatType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicNat_NatType")
}

const (
	// SonicNat_NatType_UNSET corresponds to the value UNSET of SonicNat_NatType
	SonicNat_NatType_UNSET E_SonicNat_NatType = 0
	// SonicNat_NatType_snat corresponds to the value snat of SonicNat_NatType
	SonicNat_NatType_snat E_SonicNat_NatType = 1
	// SonicNat_NatType_dnat corresponds to the value dnat of SonicNat_NatType
	SonicNat_NatType_dnat E_SonicNat_NatType = 2
)


// E_SonicPasswh_FeatureState is a derived int64 type which is used to represent
// the enumerated node SonicPasswh_FeatureState. An additional value named
// SonicPasswh_FeatureState_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicPasswh_FeatureState int64

// IsYANGGoEnum ensures that SonicPasswh_FeatureState implements the yang.GoEnum
// interface. This ensures that SonicPasswh_FeatureState can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicPasswh_FeatureState) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicPasswh_FeatureState.
func (E_SonicPasswh_FeatureState) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicPasswh_FeatureState.
func (e E_SonicPasswh_FeatureState) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicPasswh_FeatureState")
}

const (
	// SonicPasswh_FeatureState_UNSET corresponds to the value UNSET of SonicPasswh_FeatureState
	SonicPasswh_FeatureState_UNSET E_SonicPasswh_FeatureState = 0
	// SonicPasswh_FeatureState_enabled corresponds to the value enabled of SonicPasswh_FeatureState
	SonicPasswh_FeatureState_enabled E_SonicPasswh_FeatureState = 1
	// SonicPasswh_FeatureState_disabled corresponds to the value disabled of SonicPasswh_FeatureState
	SonicPasswh_FeatureState_disabled E_SonicPasswh_FeatureState = 2
)


// E_SonicPbh_FlowCounter is a derived int64 type which is used to represent
// the enumerated node SonicPbh_FlowCounter. An additional value named
// SonicPbh_FlowCounter_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicPbh_FlowCounter int64

// IsYANGGoEnum ensures that SonicPbh_FlowCounter implements the yang.GoEnum
// interface. This ensures that SonicPbh_FlowCounter can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicPbh_FlowCounter) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicPbh_FlowCounter.
func (E_SonicPbh_FlowCounter) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicPbh_FlowCounter.
func (e E_SonicPbh_FlowCounter) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicPbh_FlowCounter")
}

const (
	// SonicPbh_FlowCounter_UNSET corresponds to the value UNSET of SonicPbh_FlowCounter
	SonicPbh_FlowCounter_UNSET E_SonicPbh_FlowCounter = 0
	// SonicPbh_FlowCounter_DISABLED corresponds to the value DISABLED of SonicPbh_FlowCounter
	SonicPbh_FlowCounter_DISABLED E_SonicPbh_FlowCounter = 1
	// SonicPbh_FlowCounter_ENABLED corresponds to the value ENABLED of SonicPbh_FlowCounter
	SonicPbh_FlowCounter_ENABLED E_SonicPbh_FlowCounter = 2
)


// E_SonicPbh_HashField is a derived int64 type which is used to represent
// the enumerated node SonicPbh_HashField. An additional value named
// SonicPbh_HashField_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicPbh_HashField int64

// IsYANGGoEnum ensures that SonicPbh_HashField implements the yang.GoEnum
// interface. This ensures that SonicPbh_HashField can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicPbh_HashField) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicPbh_HashField.
func (E_SonicPbh_HashField) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicPbh_HashField.
func (e E_SonicPbh_HashField) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicPbh_HashField")
}

const (
	// SonicPbh_HashField_UNSET corresponds to the value UNSET of SonicPbh_HashField
	SonicPbh_HashField_UNSET E_SonicPbh_HashField = 0
	// SonicPbh_HashField_INNER_IP_PROTOCOL corresponds to the value INNER_IP_PROTOCOL of SonicPbh_HashField
	SonicPbh_HashField_INNER_IP_PROTOCOL E_SonicPbh_HashField = 1
	// SonicPbh_HashField_INNER_L4_DST_PORT corresponds to the value INNER_L4_DST_PORT of SonicPbh_HashField
	SonicPbh_HashField_INNER_L4_DST_PORT E_SonicPbh_HashField = 2
	// SonicPbh_HashField_INNER_L4_SRC_PORT corresponds to the value INNER_L4_SRC_PORT of SonicPbh_HashField
	SonicPbh_HashField_INNER_L4_SRC_PORT E_SonicPbh_HashField = 3
	// SonicPbh_HashField_INNER_DST_IPV4 corresponds to the value INNER_DST_IPV4 of SonicPbh_HashField
	SonicPbh_HashField_INNER_DST_IPV4 E_SonicPbh_HashField = 4
	// SonicPbh_HashField_INNER_SRC_IPV4 corresponds to the value INNER_SRC_IPV4 of SonicPbh_HashField
	SonicPbh_HashField_INNER_SRC_IPV4 E_SonicPbh_HashField = 5
	// SonicPbh_HashField_INNER_DST_IPV6 corresponds to the value INNER_DST_IPV6 of SonicPbh_HashField
	SonicPbh_HashField_INNER_DST_IPV6 E_SonicPbh_HashField = 6
	// SonicPbh_HashField_INNER_SRC_IPV6 corresponds to the value INNER_SRC_IPV6 of SonicPbh_HashField
	SonicPbh_HashField_INNER_SRC_IPV6 E_SonicPbh_HashField = 7
)


// E_SonicPbh_PacketAction is a derived int64 type which is used to represent
// the enumerated node SonicPbh_PacketAction. An additional value named
// SonicPbh_PacketAction_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicPbh_PacketAction int64

// IsYANGGoEnum ensures that SonicPbh_PacketAction implements the yang.GoEnum
// interface. This ensures that SonicPbh_PacketAction can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicPbh_PacketAction) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicPbh_PacketAction.
func (E_SonicPbh_PacketAction) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicPbh_PacketAction.
func (e E_SonicPbh_PacketAction) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicPbh_PacketAction")
}

const (
	// SonicPbh_PacketAction_UNSET corresponds to the value UNSET of SonicPbh_PacketAction
	SonicPbh_PacketAction_UNSET E_SonicPbh_PacketAction = 0
	// SonicPbh_PacketAction_SET_ECMP_HASH corresponds to the value SET_ECMP_HASH of SonicPbh_PacketAction
	SonicPbh_PacketAction_SET_ECMP_HASH E_SonicPbh_PacketAction = 1
	// SonicPbh_PacketAction_SET_LAG_HASH corresponds to the value SET_LAG_HASH of SonicPbh_PacketAction
	SonicPbh_PacketAction_SET_LAG_HASH E_SonicPbh_PacketAction = 2
)


// E_SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls is a derived int64 type which is used to represent
// the enumerated node SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls. An additional value named
// SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls int64

// IsYANGGoEnum ensures that SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls implements the yang.GoEnum
// interface. This ensures that SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls.
func (E_SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls.
func (e E_SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls")
}

const (
	// SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls_UNSET corresponds to the value UNSET of SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls
	SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls_UNSET E_SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls = 0
	// SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls_enable corresponds to the value enable of SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls
	SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls_enable E_SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls = 1
	// SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls_disable corresponds to the value disable of SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls
	SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls_disable E_SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls = 2
)


// E_SonicRouteMap_MetricActionType is a derived int64 type which is used to represent
// the enumerated node SonicRouteMap_MetricActionType. An additional value named
// SonicRouteMap_MetricActionType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicRouteMap_MetricActionType int64

// IsYANGGoEnum ensures that SonicRouteMap_MetricActionType implements the yang.GoEnum
// interface. This ensures that SonicRouteMap_MetricActionType can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicRouteMap_MetricActionType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicRouteMap_MetricActionType.
func (E_SonicRouteMap_MetricActionType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicRouteMap_MetricActionType.
func (e E_SonicRouteMap_MetricActionType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicRouteMap_MetricActionType")
}

const (
	// SonicRouteMap_MetricActionType_UNSET corresponds to the value UNSET of SonicRouteMap_MetricActionType
	SonicRouteMap_MetricActionType_UNSET E_SonicRouteMap_MetricActionType = 0
	// SonicRouteMap_MetricActionType_METRIC_SET_VALUE corresponds to the value METRIC_SET_VALUE of SonicRouteMap_MetricActionType
	SonicRouteMap_MetricActionType_METRIC_SET_VALUE E_SonicRouteMap_MetricActionType = 1
	// SonicRouteMap_MetricActionType_METRIC_ADD_VALUE corresponds to the value METRIC_ADD_VALUE of SonicRouteMap_MetricActionType
	SonicRouteMap_MetricActionType_METRIC_ADD_VALUE E_SonicRouteMap_MetricActionType = 2
	// SonicRouteMap_MetricActionType_METRIC_SUBTRACT_VALUE corresponds to the value METRIC_SUBTRACT_VALUE of SonicRouteMap_MetricActionType
	SonicRouteMap_MetricActionType_METRIC_SUBTRACT_VALUE E_SonicRouteMap_MetricActionType = 3
	// SonicRouteMap_MetricActionType_METRIC_SET_RTT corresponds to the value METRIC_SET_RTT of SonicRouteMap_MetricActionType
	SonicRouteMap_MetricActionType_METRIC_SET_RTT E_SonicRouteMap_MetricActionType = 4
	// SonicRouteMap_MetricActionType_METRIC_ADD_RTT corresponds to the value METRIC_ADD_RTT of SonicRouteMap_MetricActionType
	SonicRouteMap_MetricActionType_METRIC_ADD_RTT E_SonicRouteMap_MetricActionType = 5
	// SonicRouteMap_MetricActionType_METRIC_SUBTRACT_RTT corresponds to the value METRIC_SUBTRACT_RTT of SonicRouteMap_MetricActionType
	SonicRouteMap_MetricActionType_METRIC_SUBTRACT_RTT E_SonicRouteMap_MetricActionType = 6
)


// E_SonicRoutingPolicySets_RoutingPolicyActionType is a derived int64 type which is used to represent
// the enumerated node SonicRoutingPolicySets_RoutingPolicyActionType. An additional value named
// SonicRoutingPolicySets_RoutingPolicyActionType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicRoutingPolicySets_RoutingPolicyActionType int64

// IsYANGGoEnum ensures that SonicRoutingPolicySets_RoutingPolicyActionType implements the yang.GoEnum
// interface. This ensures that SonicRoutingPolicySets_RoutingPolicyActionType can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicRoutingPolicySets_RoutingPolicyActionType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicRoutingPolicySets_RoutingPolicyActionType.
func (E_SonicRoutingPolicySets_RoutingPolicyActionType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicRoutingPolicySets_RoutingPolicyActionType.
func (e E_SonicRoutingPolicySets_RoutingPolicyActionType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicRoutingPolicySets_RoutingPolicyActionType")
}

const (
	// SonicRoutingPolicySets_RoutingPolicyActionType_UNSET corresponds to the value UNSET of SonicRoutingPolicySets_RoutingPolicyActionType
	SonicRoutingPolicySets_RoutingPolicyActionType_UNSET E_SonicRoutingPolicySets_RoutingPolicyActionType = 0
	// SonicRoutingPolicySets_RoutingPolicyActionType_permit corresponds to the value permit of SonicRoutingPolicySets_RoutingPolicyActionType
	SonicRoutingPolicySets_RoutingPolicyActionType_permit E_SonicRoutingPolicySets_RoutingPolicyActionType = 1
	// SonicRoutingPolicySets_RoutingPolicyActionType_deny corresponds to the value deny of SonicRoutingPolicySets_RoutingPolicyActionType
	SonicRoutingPolicySets_RoutingPolicyActionType_deny E_SonicRoutingPolicySets_RoutingPolicyActionType = 2
)


// E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction is a derived int64 type which is used to represent
// the enumerated node SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction. An additional value named
// SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction int64

// IsYANGGoEnum ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction implements the yang.GoEnum
// interface. This ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction.
func (E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction.
func (e E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction")
}

const (
	// SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction_UNSET corresponds to the value UNSET of SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction
	SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction_UNSET E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction = 0
	// SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction_ANY corresponds to the value ANY of SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction
	SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction_ANY E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction = 1
	// SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction_ALL corresponds to the value ALL of SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction
	SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction_ALL E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction = 2
)


// E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType is a derived int64 type which is used to represent
// the enumerated node SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType. An additional value named
// SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType int64

// IsYANGGoEnum ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType implements the yang.GoEnum
// interface. This ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType.
func (E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType.
func (e E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType")
}

const (
	// SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType_UNSET corresponds to the value UNSET of SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType
	SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType_UNSET E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType = 0
	// SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType_STANDARD corresponds to the value STANDARD of SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType
	SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType_STANDARD E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType = 1
	// SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType_EXPANDED corresponds to the value EXPANDED of SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType
	SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType_EXPANDED E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType = 2
)


// E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction is a derived int64 type which is used to represent
// the enumerated node SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction. An additional value named
// SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction int64

// IsYANGGoEnum ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction implements the yang.GoEnum
// interface. This ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction.
func (E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction.
func (e E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction")
}

const (
	// SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction_UNSET corresponds to the value UNSET of SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction
	SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction_UNSET E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction = 0
	// SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction_ANY corresponds to the value ANY of SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction
	SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction_ANY E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction = 1
	// SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction_ALL corresponds to the value ALL of SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction
	SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction_ALL E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction = 2
)


// E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType is a derived int64 type which is used to represent
// the enumerated node SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType. An additional value named
// SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType int64

// IsYANGGoEnum ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType implements the yang.GoEnum
// interface. This ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType.
func (E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType.
func (e E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType")
}

const (
	// SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType_UNSET corresponds to the value UNSET of SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType
	SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType_UNSET E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType = 0
	// SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType_STANDARD corresponds to the value STANDARD of SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType
	SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType_STANDARD E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType = 1
	// SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType_EXPANDED corresponds to the value EXPANDED of SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType
	SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType_EXPANDED E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType = 2
)


// E_SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode is a derived int64 type which is used to represent
// the enumerated node SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode. An additional value named
// SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode int64

// IsYANGGoEnum ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode implements the yang.GoEnum
// interface. This ensures that SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode.
func (E_SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode.
func (e E_SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode")
}

const (
	// SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode_UNSET corresponds to the value UNSET of SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode
	SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode_UNSET E_SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode = 0
	// SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode_IPv4 corresponds to the value IPv4 of SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode
	SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode_IPv4 E_SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode = 1
	// SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode_IPv6 corresponds to the value IPv6 of SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode
	SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode_IPv6 E_SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode = 2
)


// E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType is a derived int64 type which is used to represent
// the enumerated node SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType. An additional value named
// SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType int64

// IsYANGGoEnum ensures that SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType implements the yang.GoEnum
// interface. This ensures that SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType.
func (E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType.
func (e E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType")
}

const (
	// SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType_UNSET corresponds to the value UNSET of SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType
	SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType_UNSET E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType = 0
	// SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType_packets corresponds to the value packets of SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType
	SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType_packets E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType = 1
	// SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType_bytes corresponds to the value bytes of SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType
	SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType_bytes E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType = 2
)


// E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type is a derived int64 type which is used to represent
// the enumerated node SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type. An additional value named
// SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type int64

// IsYANGGoEnum ensures that SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type implements the yang.GoEnum
// interface. This ensures that SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type.
func (E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type.
func (e E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type")
}

const (
	// SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type_UNSET corresponds to the value UNSET of SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type
	SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type_UNSET E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type = 0
	// SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type_DWRR corresponds to the value DWRR of SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type
	SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type_DWRR E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type = 1
	// SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type_WRR corresponds to the value WRR of SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type
	SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type_WRR E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type = 2
	// SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type_STRICT corresponds to the value STRICT of SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type
	SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type_STRICT E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type = 3
)


// E_SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE is a derived int64 type which is used to represent
// the enumerated node SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE. An additional value named
// SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE int64

// IsYANGGoEnum ensures that SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE implements the yang.GoEnum
// interface. This ensures that SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE.
func (E_SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE.
func (e E_SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE")
}

const (
	// SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE_UNSET corresponds to the value UNSET of SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE
	SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE_UNSET E_SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE = 0
	// SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE_RO corresponds to the value RO of SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE
	SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE_RO E_SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE = 1
	// SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE_RW corresponds to the value RW of SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE
	SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE_RW E_SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE = 2
)


// E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType is a derived int64 type which is used to represent
// the enumerated node SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType. An additional value named
// SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType int64

// IsYANGGoEnum ensures that SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType implements the yang.GoEnum
// interface. This ensures that SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType.
func (E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType.
func (e E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType")
}

const (
	// SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType_UNSET corresponds to the value UNSET of SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType
	SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType_UNSET E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType = 0
	// SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType_broadcast corresponds to the value broadcast of SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType
	SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType_broadcast E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType = 1
	// SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType_unknown_unicast corresponds to the value unknown_unicast of SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType
	SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType_unknown_unicast E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType = 2
	// SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType_unknown_multicast corresponds to the value unknown_multicast of SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType
	SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType_unknown_multicast E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType = 3
)


// E_SonicTypes_AdminMode is a derived int64 type which is used to represent
// the enumerated node SonicTypes_AdminMode. An additional value named
// SonicTypes_AdminMode_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicTypes_AdminMode int64

// IsYANGGoEnum ensures that SonicTypes_AdminMode implements the yang.GoEnum
// interface. This ensures that SonicTypes_AdminMode can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicTypes_AdminMode) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicTypes_AdminMode.
func (E_SonicTypes_AdminMode) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicTypes_AdminMode.
func (e E_SonicTypes_AdminMode) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicTypes_AdminMode")
}

const (
	// SonicTypes_AdminMode_UNSET corresponds to the value UNSET of SonicTypes_AdminMode
	SonicTypes_AdminMode_UNSET E_SonicTypes_AdminMode = 0
	// SonicTypes_AdminMode_enabled corresponds to the value enabled of SonicTypes_AdminMode
	SonicTypes_AdminMode_enabled E_SonicTypes_AdminMode = 1
	// SonicTypes_AdminMode_disabled corresponds to the value disabled of SonicTypes_AdminMode
	SonicTypes_AdminMode_disabled E_SonicTypes_AdminMode = 2
)


// E_SonicTypes_AdminStatus is a derived int64 type which is used to represent
// the enumerated node SonicTypes_AdminStatus. An additional value named
// SonicTypes_AdminStatus_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicTypes_AdminStatus int64

// IsYANGGoEnum ensures that SonicTypes_AdminStatus implements the yang.GoEnum
// interface. This ensures that SonicTypes_AdminStatus can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicTypes_AdminStatus) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicTypes_AdminStatus.
func (E_SonicTypes_AdminStatus) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicTypes_AdminStatus.
func (e E_SonicTypes_AdminStatus) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicTypes_AdminStatus")
}

const (
	// SonicTypes_AdminStatus_UNSET corresponds to the value UNSET of SonicTypes_AdminStatus
	SonicTypes_AdminStatus_UNSET E_SonicTypes_AdminStatus = 0
	// SonicTypes_AdminStatus_up corresponds to the value up of SonicTypes_AdminStatus
	SonicTypes_AdminStatus_up E_SonicTypes_AdminStatus = 1
	// SonicTypes_AdminStatus_down corresponds to the value down of SonicTypes_AdminStatus
	SonicTypes_AdminStatus_down E_SonicTypes_AdminStatus = 2
)


// E_SonicTypes_InterfaceType is a derived int64 type which is used to represent
// the enumerated node SonicTypes_InterfaceType. An additional value named
// SonicTypes_InterfaceType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicTypes_InterfaceType int64

// IsYANGGoEnum ensures that SonicTypes_InterfaceType implements the yang.GoEnum
// interface. This ensures that SonicTypes_InterfaceType can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicTypes_InterfaceType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicTypes_InterfaceType.
func (E_SonicTypes_InterfaceType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicTypes_InterfaceType.
func (e E_SonicTypes_InterfaceType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicTypes_InterfaceType")
}

const (
	// SonicTypes_InterfaceType_UNSET corresponds to the value UNSET of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_UNSET E_SonicTypes_InterfaceType = 0
	// SonicTypes_InterfaceType_CR corresponds to the value CR of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_CR E_SonicTypes_InterfaceType = 1
	// SonicTypes_InterfaceType_CR2 corresponds to the value CR2 of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_CR2 E_SonicTypes_InterfaceType = 2
	// SonicTypes_InterfaceType_CR4 corresponds to the value CR4 of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_CR4 E_SonicTypes_InterfaceType = 3
	// SonicTypes_InterfaceType_CR8 corresponds to the value CR8 of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_CR8 E_SonicTypes_InterfaceType = 4
	// SonicTypes_InterfaceType_SR corresponds to the value SR of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_SR E_SonicTypes_InterfaceType = 5
	// SonicTypes_InterfaceType_SR2 corresponds to the value SR2 of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_SR2 E_SonicTypes_InterfaceType = 6
	// SonicTypes_InterfaceType_SR4 corresponds to the value SR4 of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_SR4 E_SonicTypes_InterfaceType = 7
	// SonicTypes_InterfaceType_SR8 corresponds to the value SR8 of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_SR8 E_SonicTypes_InterfaceType = 8
	// SonicTypes_InterfaceType_LR corresponds to the value LR of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_LR E_SonicTypes_InterfaceType = 9
	// SonicTypes_InterfaceType_LR4 corresponds to the value LR4 of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_LR4 E_SonicTypes_InterfaceType = 10
	// SonicTypes_InterfaceType_LR8 corresponds to the value LR8 of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_LR8 E_SonicTypes_InterfaceType = 11
	// SonicTypes_InterfaceType_KR corresponds to the value KR of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_KR E_SonicTypes_InterfaceType = 12
	// SonicTypes_InterfaceType_KR4 corresponds to the value KR4 of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_KR4 E_SonicTypes_InterfaceType = 13
	// SonicTypes_InterfaceType_KR8 corresponds to the value KR8 of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_KR8 E_SonicTypes_InterfaceType = 14
	// SonicTypes_InterfaceType_CAUI corresponds to the value CAUI of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_CAUI E_SonicTypes_InterfaceType = 15
	// SonicTypes_InterfaceType_GMII corresponds to the value GMII of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_GMII E_SonicTypes_InterfaceType = 16
	// SonicTypes_InterfaceType_SFI corresponds to the value SFI of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_SFI E_SonicTypes_InterfaceType = 17
	// SonicTypes_InterfaceType_XLAUI corresponds to the value XLAUI of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_XLAUI E_SonicTypes_InterfaceType = 18
	// SonicTypes_InterfaceType_KR2 corresponds to the value KR2 of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_KR2 E_SonicTypes_InterfaceType = 19
	// SonicTypes_InterfaceType_CAUI4 corresponds to the value CAUI4 of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_CAUI4 E_SonicTypes_InterfaceType = 20
	// SonicTypes_InterfaceType_XAUI corresponds to the value XAUI of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_XAUI E_SonicTypes_InterfaceType = 21
	// SonicTypes_InterfaceType_XFI corresponds to the value XFI of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_XFI E_SonicTypes_InterfaceType = 22
	// SonicTypes_InterfaceType_XGMII corresponds to the value XGMII of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_XGMII E_SonicTypes_InterfaceType = 23
	// SonicTypes_InterfaceType_none corresponds to the value none of SonicTypes_InterfaceType
	SonicTypes_InterfaceType_none E_SonicTypes_InterfaceType = 24
)


// E_SonicTypes_IpFamily is a derived int64 type which is used to represent
// the enumerated node SonicTypes_IpFamily. An additional value named
// SonicTypes_IpFamily_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicTypes_IpFamily int64

// IsYANGGoEnum ensures that SonicTypes_IpFamily implements the yang.GoEnum
// interface. This ensures that SonicTypes_IpFamily can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicTypes_IpFamily) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicTypes_IpFamily.
func (E_SonicTypes_IpFamily) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicTypes_IpFamily.
func (e E_SonicTypes_IpFamily) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicTypes_IpFamily")
}

const (
	// SonicTypes_IpFamily_UNSET corresponds to the value UNSET of SonicTypes_IpFamily
	SonicTypes_IpFamily_UNSET E_SonicTypes_IpFamily = 0
	// SonicTypes_IpFamily_IPv4 corresponds to the value IPv4 of SonicTypes_IpFamily
	SonicTypes_IpFamily_IPv4 E_SonicTypes_IpFamily = 1
	// SonicTypes_IpFamily_IPv6 corresponds to the value IPv6 of SonicTypes_IpFamily
	SonicTypes_IpFamily_IPv6 E_SonicTypes_IpFamily = 2
)


// E_SonicTypes_IpProtocolType is a derived int64 type which is used to represent
// the enumerated node SonicTypes_IpProtocolType. An additional value named
// SonicTypes_IpProtocolType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicTypes_IpProtocolType int64

// IsYANGGoEnum ensures that SonicTypes_IpProtocolType implements the yang.GoEnum
// interface. This ensures that SonicTypes_IpProtocolType can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicTypes_IpProtocolType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicTypes_IpProtocolType.
func (E_SonicTypes_IpProtocolType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicTypes_IpProtocolType.
func (e E_SonicTypes_IpProtocolType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicTypes_IpProtocolType")
}

const (
	// SonicTypes_IpProtocolType_UNSET corresponds to the value UNSET of SonicTypes_IpProtocolType
	SonicTypes_IpProtocolType_UNSET E_SonicTypes_IpProtocolType = 0
	// SonicTypes_IpProtocolType_TCP corresponds to the value TCP of SonicTypes_IpProtocolType
	SonicTypes_IpProtocolType_TCP E_SonicTypes_IpProtocolType = 1
	// SonicTypes_IpProtocolType_UDP corresponds to the value UDP of SonicTypes_IpProtocolType
	SonicTypes_IpProtocolType_UDP E_SonicTypes_IpProtocolType = 2
)


// E_SonicTypes_VlanTaggingMode is a derived int64 type which is used to represent
// the enumerated node SonicTypes_VlanTaggingMode. An additional value named
// SonicTypes_VlanTaggingMode_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicTypes_VlanTaggingMode int64

// IsYANGGoEnum ensures that SonicTypes_VlanTaggingMode implements the yang.GoEnum
// interface. This ensures that SonicTypes_VlanTaggingMode can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicTypes_VlanTaggingMode) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicTypes_VlanTaggingMode.
func (E_SonicTypes_VlanTaggingMode) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicTypes_VlanTaggingMode.
func (e E_SonicTypes_VlanTaggingMode) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicTypes_VlanTaggingMode")
}

const (
	// SonicTypes_VlanTaggingMode_UNSET corresponds to the value UNSET of SonicTypes_VlanTaggingMode
	SonicTypes_VlanTaggingMode_UNSET E_SonicTypes_VlanTaggingMode = 0
	// SonicTypes_VlanTaggingMode_tagged corresponds to the value tagged of SonicTypes_VlanTaggingMode
	SonicTypes_VlanTaggingMode_tagged E_SonicTypes_VlanTaggingMode = 1
	// SonicTypes_VlanTaggingMode_untagged corresponds to the value untagged of SonicTypes_VlanTaggingMode
	SonicTypes_VlanTaggingMode_untagged E_SonicTypes_VlanTaggingMode = 2
	// SonicTypes_VlanTaggingMode_priority_tagged corresponds to the value priority_tagged of SonicTypes_VlanTaggingMode
	SonicTypes_VlanTaggingMode_priority_tagged E_SonicTypes_VlanTaggingMode = 3
)


// E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope is a derived int64 type which is used to represent
// the enumerated node SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope. An additional value named
// SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope int64

// IsYANGGoEnum ensures that SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope implements the yang.GoEnum
// interface. This ensures that SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope.
func (E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope.
func (e E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope")
}

const (
	// SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope_UNSET corresponds to the value UNSET of SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope
	SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope_UNSET E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope = 0
	// SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope_global corresponds to the value global of SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope
	SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope_global E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope = 1
	// SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope_local corresponds to the value local of SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope
	SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope_local E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope = 2
)


// E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls is a derived int64 type which is used to represent
// the enumerated node SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls. An additional value named
// SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls int64

// IsYANGGoEnum ensures that SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls implements the yang.GoEnum
// interface. This ensures that SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls can be identified as a
// mapped type for a YANG enumeration.
func (E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls.
func (E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls.
func (e E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls) String() string {
	return ygot.EnumLogString(e, int64(e), "E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls")
}

const (
	// SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls_UNSET corresponds to the value UNSET of SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls
	SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls_UNSET E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls = 0
	// SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls_enable corresponds to the value enable of SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls
	SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls_enable E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls = 1
	// SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls_disable corresponds to the value disable of SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls
	SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls_disable E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls = 2
)


// ΛEnum is a map, keyed by the name of the type defined for each enum in the
// generated Go code, which provides a mapping between the constant int64 value
// of each value of the enumeration, and the string that is used to represent it
// in the YANG schema. The map is named ΛEnum in order to avoid clash with any
// valid YANG identifier.
var ΛEnum = map[string]map[int64]ygot.EnumDefinition{
	"E_SonicFlexCounter_FlexStatus": {
		1: {Name: "enable"},
		2: {Name: "disable"},
	},
	"E_SonicHash_HashField": {
		1: {Name: "IN_PORT"},
		2: {Name: "DST_MAC"},
		3: {Name: "SRC_MAC"},
		4: {Name: "ETHERTYPE"},
		5: {Name: "VLAN_ID"},
		6: {Name: "IP_PROTOCOL"},
		7: {Name: "DST_IP"},
		8: {Name: "SRC_IP"},
		9: {Name: "L4_DST_PORT"},
		10: {Name: "L4_SRC_PORT"},
		11: {Name: "INNER_DST_MAC"},
		12: {Name: "INNER_SRC_MAC"},
		13: {Name: "INNER_ETHERTYPE"},
		14: {Name: "INNER_IP_PROTOCOL"},
		15: {Name: "INNER_DST_IP"},
		16: {Name: "INNER_SRC_IP"},
		17: {Name: "INNER_L4_DST_PORT"},
		18: {Name: "INNER_L4_SRC_PORT"},
	},
	"E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope": {
		1: {Name: "global"},
		2: {Name: "local"},
	},
	"E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls": {
		1: {Name: "enable"},
		2: {Name: "disable"},
	},
	"E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode": {
		1: {Name: "RECEIVE"},
		2: {Name: "TRANSMIT"},
	},
	"E_SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope": {
		1: {Name: "global"},
		2: {Name: "local"},
	},
	"E_SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp": {
		1: {Name: "enable"},
	},
	"E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType": {
		1: {Name: "active-active"},
		2: {Name: "active-standby"},
	},
	"E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State": {
		1: {Name: "auto"},
		2: {Name: "manual"},
		3: {Name: "detach"},
		4: {Name: "active"},
		5: {Name: "standby"},
	},
	"E_SonicNat_NatType": {
		1: {Name: "snat"},
		2: {Name: "dnat"},
	},
	"E_SonicPasswh_FeatureState": {
		1: {Name: "enabled"},
		2: {Name: "disabled"},
	},
	"E_SonicPbh_FlowCounter": {
		1: {Name: "DISABLED"},
		2: {Name: "ENABLED"},
	},
	"E_SonicPbh_HashField": {
		1: {Name: "INNER_IP_PROTOCOL"},
		2: {Name: "INNER_L4_DST_PORT"},
		3: {Name: "INNER_L4_SRC_PORT"},
		4: {Name: "INNER_DST_IPV4"},
		5: {Name: "INNER_SRC_IPV4"},
		6: {Name: "INNER_DST_IPV6"},
		7: {Name: "INNER_SRC_IPV6"},
	},
	"E_SonicPbh_PacketAction": {
		1: {Name: "SET_ECMP_HASH"},
		2: {Name: "SET_LAG_HASH"},
	},
	"E_SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls": {
		1: {Name: "enable"},
		2: {Name: "disable"},
	},
	"E_SonicRouteMap_MetricActionType": {
		1: {Name: "METRIC_SET_VALUE"},
		2: {Name: "METRIC_ADD_VALUE"},
		3: {Name: "METRIC_SUBTRACT_VALUE"},
		4: {Name: "METRIC_SET_RTT"},
		5: {Name: "METRIC_ADD_RTT"},
		6: {Name: "METRIC_SUBTRACT_RTT"},
	},
	"E_SonicRoutingPolicySets_RoutingPolicyActionType": {
		1: {Name: "permit"},
		2: {Name: "deny"},
	},
	"E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction": {
		1: {Name: "ANY"},
		2: {Name: "ALL"},
	},
	"E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType": {
		1: {Name: "STANDARD"},
		2: {Name: "EXPANDED"},
	},
	"E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction": {
		1: {Name: "ANY"},
		2: {Name: "ALL"},
	},
	"E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType": {
		1: {Name: "STANDARD"},
		2: {Name: "EXPANDED"},
	},
	"E_SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode": {
		1: {Name: "IPv4"},
		2: {Name: "IPv6"},
	},
	"E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType": {
		1: {Name: "packets"},
		2: {Name: "bytes"},
	},
	"E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type": {
		1: {Name: "DWRR"},
		2: {Name: "WRR"},
		3: {Name: "STRICT"},
	},
	"E_SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE": {
		1: {Name: "RO"},
		2: {Name: "RW"},
	},
	"E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType": {
		1: {Name: "broadcast"},
		2: {Name: "unknown-unicast"},
		3: {Name: "unknown-multicast"},
	},
	"E_SonicTypes_AdminMode": {
		1: {Name: "enabled"},
		2: {Name: "disabled"},
	},
	"E_SonicTypes_AdminStatus": {
		1: {Name: "up"},
		2: {Name: "down"},
	},
	"E_SonicTypes_InterfaceType": {
		1: {Name: "CR"},
		2: {Name: "CR2"},
		3: {Name: "CR4"},
		4: {Name: "CR8"},
		5: {Name: "SR"},
		6: {Name: "SR2"},
		7: {Name: "SR4"},
		8: {Name: "SR8"},
		9: {Name: "LR"},
		10: {Name: "LR4"},
		11: {Name: "LR8"},
		12: {Name: "KR"},
		13: {Name: "KR4"},
		14: {Name: "KR8"},
		15: {Name: "CAUI"},
		16: {Name: "GMII"},
		17: {Name: "SFI"},
		18: {Name: "XLAUI"},
		19: {Name: "KR2"},
		20: {Name: "CAUI4"},
		21: {Name: "XAUI"},
		22: {Name: "XFI"},
		23: {Name: "XGMII"},
		24: {Name: "none"},
	},
	"E_SonicTypes_IpFamily": {
		1: {Name: "IPv4"},
		2: {Name: "IPv6"},
	},
	"E_SonicTypes_IpProtocolType": {
		1: {Name: "TCP"},
		2: {Name: "UDP"},
	},
	"E_SonicTypes_VlanTaggingMode": {
		1: {Name: "tagged"},
		2: {Name: "untagged"},
		3: {Name: "priority_tagged"},
	},
	"E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope": {
		1: {Name: "global"},
		2: {Name: "local"},
	},
	"E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls": {
		1: {Name: "enable"},
		2: {Name: "disable"},
	},
}


var (
	// ySchema is a byte slice contain a gzip compressed representation of the
	// YANG schema from which the Go code was generated. When uncompressed the
	// contents of the byte slice is a JSON document containing an object, keyed
	// on the name of the generated struct, and containing the JSON marshalled
	// contents of a goyang yang.Entry struct, which defines the schema for the
	// fields within the struct.
	ySchema = []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0xfd, 0x79, 0x73, 0xda, 0x58,
		0xfa, 0x3e, 0x0e, 0xff, 0xdf, 0xaf, 0x42, 0x1f, 0xaa, 0xba, 0x82, 0x12, 0xb3, 0x1a, 0xb0, 0x4d,
		0x55, 0x57, 0x1e, 0xe2, 0xe0, 0xb4, 0xab, 0xbd, 0x7d, 0x31, 0xc9, 0xf4, 0x8c, 0xcd, 0xa8, 0x64,
		0x10, 0xb6, 0x9e, 0x08, 0x89, 0x91, 0x84, 0x93, 0xb4, 0xcd, 0x7b, 0xff, 0x95, 0x16, 0x40, 0x80,
		0x40, 0xe7, 0x1c, 0x09, 0x21, 0xc9, 0x57, 0xd7, 0x8c, 0x03, 0x42, 0xf7, 0x91, 0xce, 0x76, 0x2f,
		0xd7, 0xbd, 0x9c, 0x97, 0xdf, 0x38, 0x8e, 0xe3, 0x72, 0x57, 0xe2, 0x48, 0xca, 0x35, 0xb9, 0xdc,
		0x40, 0x7a, 0x96, 0xfb, 0x52, 0xee, 0xc0, 0xb9, 0xfa, 0x97, 0xac, 0x0e, 0x72, 0x4d, 0xae, 0xe2,
		0x7e, 0x3d, 0xd5, 0xd4, 0xa1, 0xfc, 0x98, 0x6b, 0x72, 0x65, 0xf7, 0xc2, 0x67, 0x59, 0xcf, 0x35,
		0x39, 0xa7, 0x09, 0xfb, 0x82, 0xa1, 0xa9, 0x72, 0xbf, 0x20, 0x4e, 0x4c, 0x4d, 0x30, 0xa5, 0xfe,
		0x93, 0x31, 0x19, 0x8f, 0x35, 0xdd, 0x5c, 0xba, 0x67, 0xe9, 0x71, 0x1b, 0xee, 0x3f, 0x58, 0xbe,
		0x7b, 0xf9, 0x35, 0xe6, 0x97, 0x57, 0x5f, 0x67, 0xfe, 0xc3, 0x8d, 0x2e, 0x0d, 0xe5, 0x9f, 0x6b,
		0x4f, 0x5d, 0x7a, 0x72, 0xc0, 0x33, 0xed, 0x7b, 0x6f, 0xb5, 0x89, 0xde, 0x97, 0x7c, 0xdb, 0x71,
		0xde, 0x4b, 0xfa, 0xf5, 0x43, 0xd3, 0xad, 0x57, 0xcb, 0x8d, 0x9d, 0x47, 0x1e, 0xf8, 0xdf, 0xf8,
		0xa7, 0x68, 0xb4, 0xf4, 0xc7, 0xc9, 0x48, 0x52, 0xad, 0xb1, 0x30, 0xf5, 0x89, 0xb4, 0xe1, 0x46,
		0xcf, 0x5d, 0xeb, 0x6f, 0xb8, 0x46, 0x32, 0x5d, 0xba, 0x32, 0x5d, 0x19, 0x85, 0xd5, 0xc9, 0x59,
		0x3c, 0xe4, 0x6b, 0xf7, 0x5a, 0xe8, 0xb6, 0x4f, 0xff, 0xbc, 0xfd, 0x7a, 0x73, 0x73, 0xdd, 0xe9,
		0x6e, 0xee, 0xe0, 0x6c, 0xb0, 0xd6, 0x28, 0x36, 0xbc, 0xbe, 0xff, 0x44, 0x05, 0x4e, 0x18, 0xc9,
		0xc4, 0xb1, 0x4c, 0x20, 0xe9, 0x44, 0x52, 0x4f, 0x28, 0xf5, 0xc4, 0x32, 0x4e, 0xb0, 0xff, 0x44,
		0x6f, 0x98, 0xf0, 0xc0, 0x89, 0x9f, 0xdf, 0xf0, 0xe5, 0xe2, 0xfa, 0x53, 0xeb, 0x22, 0x78, 0x38,
		0x66, 0x43, 0xed, 0xde, 0x1f, 0xd0, 0xb5, 0xed, 0x93, 0x4f, 0xbc, 0x08, 0x68, 0x16, 0x43, 0x98,
		0x45, 0x41, 0xbb, 0x38, 0x98, 0x17, 0x09, 0xf3, 0x62, 0x09, 0xb9, 0x68, 0xb6, 0x2f, 0x9e, 0x80,
		0x45, 0x44, 0xbc, 0x98, 0xe6, 0x37, 0x8a, 0xcf, 0xa2, 0xac, 0x88, 0x0f, 0x8a, 0x24, 0x8c, 0xa4,
		0x91, 0x60, 0x3e, 0xe9, 0x92, 0xf1, 0xa4, 0x29, 0x03, 0xf2, 0x71, 0x9d, 0xcf, 0xe1, 0x86, 0x86,
		0x08, 0x07, 0xeb, 0xb3, 0x34, 0x14, 0x27, 0x8a, 0x35, 0x56, 0x77, 0x44, 0x04, 0x36, 0x51, 0xa5,
		0x5c, 0x2c, 0xe7, 0x88, 0x6e, 0xef, 0x11, 0xbe, 0x86, 0xbb, 0x1b, 0xca, 0x84, 0xb7, 0x93, 0xee,
		0x0a, 0x96, 0xdd, 0x11, 0xc5, 0x2e, 0x61, 0xdd, 0x2d, 0xa1, 0x77, 0x4d, 0xe8, 0xdd, 0x13, 0xd1,
		0x2e, 0x22, 0xdb, 0x4d, 0x84, 0xbb, 0x6a, 0xfe, 0x4e, 0xdd, 0x5f, 0x63, 0x89, 0x6d, 0x0e, 0x07,
		0x52, 0x5f, 0x1e, 0x89, 0x4a, 0x41, 0x97, 0xc6, 0x3a, 0xcd, 0xfc, 0xcd, 0xb8, 0x74, 0x95, 0x82,
		0xe6, 0x4c, 0x17, 0xfb, 0xa6, 0xac, 0xa9, 0x9f, 0xe5, 0x47, 0xd9, 0x34, 0x72, 0x4d, 0x8e, 0x86,
		0xb8, 0x23, 0xaa, 0x8f, 0x12, 0xd5, 0x6e, 0xb4, 0xfe, 0xa3, 0x5b, 0x5d, 0xf6, 0x83, 0x2e, 0x65,
		0x95, 0x7a, 0x59, 0xce, 0x89, 0xbf, 0x89, 0xca, 0x44, 0x22, 0xdf, 0x7e, 0x91, 0x0e, 0xd1, 0xf2,
		0xfc, 0x4a, 0x8f, 0xa2, 0x29, 0x3f, 0x5b, 0xef, 0x32, 0x14, 0x15, 0x43, 0xa2, 0x6e, 0x65, 0x7a,
		0xc0, 0x30, 0x74, 0xe2, 0xcf, 0xf0, 0x43, 0x77, 0x72, 0x72, 0x72, 0x92, 0xfe, 0xd1, 0xfb, 0x6d,
		0x37, 0x77, 0xf7, 0x7e, 0x8b, 0xa6, 0x3d, 0x82, 0xd9, 0xcd, 0x8d, 0xc4, 0x9f, 0x42, 0x5f, 0xd3,
		0x25, 0x41, 0x91, 0x47, 0xb2, 0x49, 0x2f, 0x80, 0x57, 0xe8, 0x21, 0xf0, 0x20, 0xf0, 0x20, 0xf0,
		0x20, 0xf0, 0x20, 0xf0, 0x20, 0xf0, 0x92, 0x2b, 0xf0, 0x3c, 0xbc, 0x2d, 0x8c, 0xdc, 0x5b, 0x6f,
		0x06, 0xe2, 0x0f, 0xe2, 0x0f, 0xe2, 0x0f, 0xe2, 0x0f, 0xe2, 0x0f, 0xe2, 0x2f, 0xa1, 0xe2, 0x4f,
		0x56, 0x85, 0x25, 0xd0, 0x94, 0x41, 0xf4, 0xad, 0x35, 0xb1, 0x4b, 0xb4, 0xb5, 0x5a, 0x06, 0xd8,
		0x0a, 0xe1, 0x9b, 0x22, 0xe1, 0x3b, 0x91, 0x55, 0xf3, 0xb0, 0xca, 0x20, 0x76, 0x8f, 0x20, 0x38,
		0x83, 0x58, 0x7f, 0xf9, 0xcd, 0x09, 0xce, 0x5a, 0xf5, 0xa4, 0x76, 0xd2, 0x38, 0xaa, 0x9e, 0xd4,
		0xd3, 0x3f, 0x86, 0x19, 0x10, 0x9f, 0xba, 0x68, 0xba, 0x50, 0xa7, 0x20, 0xab, 0xa6, 0xa4, 0x3f,
		0x8b, 0x0a, 0xbd, 0x00, 0xf5, 0x6b, 0x04, 0xc2, 0x0b, 0xc2, 0x2b, 0x21, 0xc2, 0xab, 0xd2, 0x60,
		0x10, 0x5e, 0x0d, 0x08, 0x2f, 0x08, 0xaf, 0xd5, 0xa1, 0x6b, 0xd4, 0xeb, 0x87, 0x90, 0x5b, 0x49,
		0x90, 0x5b, 0x86, 0xac, 0xd2, 0x84, 0x2d, 0xcd, 0x43, 0x2e, 0x6d, 0x32, 0xc8, 0x26, 0xc8, 0xa6,
		0x04, 0xc8, 0x26, 0xc3, 0xd4, 0x65, 0xf5, 0x91, 0x05, 0xcf, 0x3c, 0xa6, 0xa0, 0xb9, 0x90, 0xd4,
		0x47, 0xf3, 0x29, 0x35, 0xd2, 0xa9, 0x02, 0xe9, 0xc4, 0x3a, 0x74, 0xd5, 0x3a, 0x64, 0x53, 0x22,
		0x64, 0x93, 0x29, 0x9a, 0x2c, 0xb2, 0xc9, 0x26, 0x83, 0x6c, 0x82, 0x6c, 0x4a, 0x80, 0x6c, 0x12,
		0x07, 0x23, 0x59, 0x15, 0x46, 0xda, 0x40, 0x62, 0x91, 0x4f, 0x35, 0x0a, 0x9a, 0xb6, 0x3a, 0x19,
		0xd1, 0xcf, 0x77, 0x57, 0xbb, 0x75, 0xa4, 0x27, 0x0b, 0xd7, 0xcc, 0x95, 0xad, 0x2e, 0x4a, 0xaa,
		0xf8, 0xa0, 0x48, 0x83, 0x1c, 0x03, 0xbb, 0xae, 0xd8, 0x4e, 0x49, 0xd9, 0x70, 0x1a, 0xf8, 0x6d,
		0x87, 0xd2, 0x21, 0xd7, 0xd5, 0xce, 0x55, 0x93, 0xad, 0x97, 0xf3, 0x17, 0x64, 0x92, 0xaa, 0xf3,
		0xf1, 0x69, 0x72, 0xe5, 0x1d, 0x31, 0xe5, 0x69, 0x54, 0x4c, 0x39, 0x54, 0x90, 0x7f, 0x4b, 0x55,
		0x35, 0x53, 0xb4, 0xc4, 0x1f, 0x59, 0xac, 0xbf, 0xd1, 0x7f, 0x92, 0x46, 0xe2, 0x58, 0xb4, 0x95,
		0xaa, 0x5c, 0xc9, 0x3f, 0x8b, 0x6b, 0xd3, 0xe5, 0xd5, 0x64, 0xa2, 0x12, 0x51, 0x7a, 0x89, 0x2b,
		0x56, 0xf4, 0x49, 0xdf, 0x54, 0xdd, 0x0d, 0x7a, 0x6b, 0xb5, 0xdf, 0x9a, 0x98, 0x5a, 0xd7, 0x13,
		0xb4, 0xe1, 0x7b, 0x71, 0xf5, 0x91, 0x82, 0xfb, 0xc8, 0xdf, 0xd8, 0x86, 0x94, 0x2e, 0x1d, 0x87,
		0x70, 0x70, 0xa3, 0x1d, 0xd4, 0x6d, 0xd9, 0x50, 0x51, 0x8d, 0xa2, 0xff, 0xf0, 0xad, 0x0f, 0x8e,
		0xcf, 0xc0, 0xac, 0x65, 0x94, 0x09, 0x67, 0xed, 0x56, 0xf7, 0x6b, 0xa7, 0x4d, 0x9f, 0x8b, 0x36,
		0xa7, 0x44, 0x4e, 0x1a, 0x9b, 0x18, 0x4f, 0x46, 0x4e, 0xda, 0xa6, 0x69, 0x15, 0x2e, 0xce, 0x6f,
		0xbb, 0xe4, 0xa9, 0x6a, 0xdb, 0x9b, 0x41, 0x06, 0x1b, 0x87, 0x0c, 0xb6, 0x8d, 0x37, 0x22, 0x83,
		0x0d, 0xf6, 0x15, 0xec, 0xab, 0xd8, 0xec, 0x2b, 0x44, 0x34, 0xee, 0x04, 0x3d, 0x44, 0x44, 0x23,
		0xf3, 0xd0, 0x21, 0xa2, 0x31, 0x21, 0xf0, 0xe1, 0x50, 0x12, 0xcd, 0x89, 0x2e, 0x09, 0xae, 0x8d,
		0x42, 0x29, 0x7e, 0x97, 0xa8, 0x21, 0xec, 0x20, 0xec, 0x12, 0x20, 0xec, 0xe0, 0xe8, 0xf2, 0xe1,
		0xb7, 0x70, 0x74, 0x31, 0x0f, 0x1d, 0x1c, 0x5d, 0xc9, 0x90, 0x54, 0x08, 0x1e, 0x84, 0xdc, 0xca,
		0xb2, 0xdc, 0x42, 0xf0, 0xe0, 0xee, 0x0c, 0x2c, 0x04, 0x0f, 0x42, 0x6e, 0xed, 0x4b, 0x6e, 0x21,
		0x40, 0x03, 0xb2, 0x09, 0x01, 0x1a, 0xa4, 0x34, 0x08, 0xd0, 0x08, 0xe8, 0x28, 0x02, 0x34, 0xc2,
		0xdd, 0x11, 0xe4, 0xc3, 0xfa, 0x4b, 0xfa, 0x45, 0x89, 0x6c, 0xe5, 0x2e, 0x64, 0xc3, 0x6c, 0x99,
		0x26, 0xa1, 0xef, 0xeb, 0x52, 0x56, 0xdb, 0x8a, 0x64, 0xf1, 0x06, 0x42, 0xd1, 0x6a, 0x29, 0x04,
		0x1e, 0x8a, 0xca, 0x71, 0xad, 0xd6, 0x38, 0xaa, 0xd5, 0xca, 0x47, 0x87, 0x47, 0xe5, 0x93, 0x7a,
		0xbd, 0xd2, 0xa8, 0x10, 0x08, 0xfa, 0xdc, 0xb5, 0x3e, 0x90, 0x74, 0x69, 0xf0, 0xc9, 0xea, 0x9d,
		0x3a, 0x51, 0x94, 0xf4, 0x46, 0xb1, 0xcc, 0x1c, 0xcd, 0xa5, 0x30, 0x1e, 0x68, 0x2e, 0xd2, 0x20,
		0x97, 0xd9, 0x83, 0xb7, 0xbf, 0x51, 0x76, 0x63, 0x60, 0x02, 0x22, 0x43, 0x76, 0x32, 0xd8, 0xc4,
		0x31, 0x31, 0x5b, 0x4b, 0x37, 0x07, 0x0c, 0x57, 0xa8, 0x61, 0xf2, 0x2b, 0x74, 0xcd, 0x38, 0x0a,
		0xcb, 0x9d, 0x5d, 0x74, 0xc9, 0xd3, 0x1d, 0xb7, 0xc2, 0xf7, 0x83, 0x2e, 0x89, 0xdf, 0xb5, 0x89,
		0x29, 0xf4, 0x87, 0x8f, 0x41, 0xd5, 0xc0, 0x97, 0xee, 0x8d, 0xa1, 0x12, 0xf8, 0x96, 0xe7, 0x71,
		0xfb, 0xaf, 0x02, 0xbe, 0xf4, 0x76, 0x51, 0x55, 0x00, 0xff, 0xd4, 0x69, 0xb7, 0xfe, 0xba, 0xfe,
		0xda, 0x15, 0x4e, 0xcf, 0xbe, 0x04, 0x47, 0x5c, 0x2d, 0xdd, 0x9d, 0x80, 0x28, 0xab, 0x80, 0x09,
		0xa3, 0xd5, 0xd3, 0x63, 0x8e, 0xb0, 0xda, 0x3e, 0xa1, 0x6c, 0xec, 0x35, 0x30, 0xba, 0xca, 0x3b,
		0x85, 0x94, 0x11, 0x55, 0xeb, 0xa4, 0x29, 0x88, 0xa2, 0x22, 0x5c, 0x22, 0xac, 0x26, 0xdd, 0x9e,
		0x23, 0xa8, 0xc8, 0x96, 0x50, 0x34, 0x9a, 0x27, 0x71, 0xf4, 0xd4, 0x83, 0x6e, 0xbf, 0x92, 0x6d,
		0x8e, 0x51, 0xe3, 0x0a, 0x5e, 0xe2, 0x0c, 0xa0, 0x0b, 0x94, 0xcb, 0x2f, 0x63, 0xc8, 0x02, 0xdd,
		0xf2, 0x4c, 0x1a, 0xaa, 0x00, 0x4f, 0xad, 0x0f, 0x70, 0x0b, 0x4f, 0x2d, 0x3b, 0xe6, 0x5d, 0x03,
		0xe0, 0x9d, 0x00, 0xc0, 0xdb, 0xf7, 0x1c, 0xa2, 0x40, 0x66, 0x40, 0x01, 0x0d, 0x43, 0x20, 0x41,
		0x20, 0x41, 0x20, 0x41, 0x20, 0x25, 0x5e, 0x20, 0x21, 0x74, 0x28, 0x06, 0x89, 0x14, 0x05, 0xda,
		0x4f, 0x20, 0x7c, 0x80, 0xf2, 0xb3, 0xa1, 0xfc, 0x5e, 0x89, 0xe0, 0x77, 0xc9, 0x0b, 0x7a, 0x94,
		0x68, 0x11, 0x90, 0x4d, 0x90, 0xea, 0x27, 0xf7, 0x09, 0xa7, 0xc3, 0x47, 0x61, 0xed, 0xc2, 0xd2,
		0x43, 0xd6, 0x9f, 0x98, 0x7c, 0x94, 0x9e, 0x66, 0x48, 0x29, 0x11, 0x79, 0xe2, 0x81, 0xdb, 0x23,
		0xfa, 0x1e, 0xd0, 0x7d, 0x42, 0xd4, 0x7d, 0x5b, 0x4f, 0xc9, 0xd1, 0xf6, 0xbe, 0xa6, 0x1a, 0x9a,
		0x22, 0x05, 0x01, 0xed, 0xb3, 0xdb, 0x62, 0xc0, 0xd8, 0xfd, 0x1f, 0x95, 0x00, 0x78, 0x7d, 0xf6,
		0x62, 0x51, 0x21, 0xeb, 0xa7, 0xd7, 0x57, 0xb7, 0xd7, 0x17, 0x6d, 0x81, 0xec, 0x5c, 0xcd, 0xa5,
		0xbb, 0x13, 0x80, 0xac, 0x6f, 0x9e, 0xa6, 0x84, 0x83, 0xea, 0x1b, 0xa7, 0x71, 0x47, 0x78, 0xba,
		0x77, 0xe2, 0x28, 0xf1, 0xf4, 0x75, 0xd2, 0x14, 0xe0, 0xe9, 0xc1, 0x0b, 0x23, 0xa5, 0x50, 0x7a,
		0xe0, 0xc2, 0x89, 0x1b, 0x45, 0x17, 0x27, 0x03, 0x41, 0x67, 0x8a, 0xcd, 0x5b, 0x90, 0x66, 0x00,
		0xb0, 0x20, 0x5f, 0x70, 0x19, 0xc3, 0x2a, 0x88, 0x17, 0x64, 0xd2, 0x60, 0x0a, 0xd4, 0x48, 0x5f,
		0xb3, 0xb4, 0x11, 0x29, 0xce, 0x3c, 0x74, 0xa8, 0x91, 0x9e, 0x28, 0xf4, 0x7c, 0xa8, 0x68, 0x3f,
		0x84, 0xbe, 0xa6, 0x9a, 0xba, 0xc6, 0x90, 0xdf, 0xb4, 0x44, 0xbd, 0xcb, 0x22, 0x18, 0x6f, 0xa8,
		0x02, 0x06, 0x04, 0x64, 0xda, 0x04, 0xa4, 0xfb, 0xe2, 0x05, 0x6b, 0x37, 0x14, 0xe8, 0x76, 0x03,
		0x33, 0xaa, 0x7f, 0x23, 0x9a, 0xa6, 0xa4, 0xab, 0xd4, 0x12, 0x33, 0x57, 0x7e, 0xad, 0xe4, 0x12,
		0xc9, 0x89, 0xd8, 0x4a, 0x02, 0x64, 0xa5, 0x14, 0x00, 0x76, 0x7d, 0x1a, 0xd5, 0x62, 0x24, 0x50,
		0x42, 0x2d, 0x46, 0x02, 0x65, 0xb6, 0x34, 0x62, 0x5d, 0x1a, 0x69, 0xa6, 0x24, 0x0c, 0xa4, 0x67,
		0x99, 0xe5, 0x14, 0x86, 0x65, 0x72, 0x48, 0x26, 0x48, 0xa6, 0xd8, 0x25, 0xd3, 0x93, 0x66, 0x98,
		0x14, 0x7a, 0x11, 0x87, 0xc8, 0x12, 0x48, 0xa7, 0x00, 0xe9, 0x74, 0x08, 0xd1, 0xb4, 0x6b, 0xd1,
		0x14, 0x45, 0x60, 0x09, 0xd2, 0x47, 0x7d, 0x99, 0x7a, 0x14, 0x81, 0x25, 0xae, 0x34, 0x58, 0xf9,
		0xe6, 0xf5, 0xf9, 0x95, 0x68, 0x1d, 0x80, 0xdc, 0x86, 0x58, 0x81, 0x53, 0xa7, 0x71, 0x61, 0xe9,
		0xcb, 0x52, 0xe3, 0xeb, 0x4f, 0x4a, 0x7e, 0x18, 0x49, 0xf0, 0x00, 0x52, 0x06, 0x8f, 0x04, 0x0e,
		0x53, 0x98, 0x32, 0xe6, 0xb3, 0x76, 0x6e, 0xff, 0x75, 0xde, 0x3d, 0xfd, 0x93, 0xdc, 0xe1, 0xef,
		0xde, 0x0f, 0x97, 0x7f, 0x7a, 0x5c, 0xfe, 0xee, 0xf3, 0x84, 0xd1, 0xe3, 0xc8, 0x24, 0xf7, 0xf6,
		0x2f, 0x51, 0xc1, 0xd1, 0x0f, 0x47, 0xff, 0xec, 0xc6, 0x45, 0xe5, 0x0a, 0x4a, 0xcb, 0x91, 0xae,
		0x24, 0x08, 0x9b, 0x1f, 0x45, 0xd5, 0xe0, 0x48, 0x81, 0xe1, 0x9a, 0x54, 0xc3, 0x75, 0xe6, 0x48,
		0xb1, 0x78, 0x6a, 0x81, 0xbe, 0x42, 0x4e, 0xbc, 0x8e, 0x94, 0x5f, 0x92, 0xf1, 0x4a, 0xba, 0x9d,
		0x92, 0x63, 0x28, 0xc4, 0xa0, 0x0b, 0x3b, 0x2a, 0x50, 0x89, 0x42, 0x40, 0x32, 0x69, 0x78, 0xce,
		0x63, 0x04, 0xf7, 0xf2, 0xa5, 0xf5, 0x94, 0xb4, 0x2b, 0xc1, 0x5b, 0x95, 0xc7, 0x10, 0x83, 0xb4,
		0xc7, 0xe8, 0x69, 0xdf, 0x0e, 0x13, 0xc6, 0x4c, 0xfb, 0xf5, 0x8c, 0x3c, 0x56, 0x7a, 0xf0, 0xd4,
		0x1f, 0x17, 0x0c, 0x49, 0x7f, 0x96, 0xf4, 0xa0, 0x78, 0x69, 0xef, 0xad, 0x31, 0xc4, 0x4c, 0x6f,
		0x7e, 0x1c, 0xb7, 0xff, 0xb8, 0x69, 0xef, 0xcb, 0x45, 0x15, 0x3b, 0xfd, 0xf9, 0xcf, 0xd3, 0x1b,
		0xe1, 0xb6, 0xdd, 0xf9, 0xd6, 0xee, 0x04, 0x5b, 0x52, 0xde, 0x9b, 0x13, 0x60, 0x46, 0x6d, 0x9f,
		0xac, 0x84, 0x9b, 0x52, 0x5b, 0x27, 0x73, 0x47, 0xe6, 0x94, 0x67, 0xfe, 0x28, 0x03, 0xa8, 0xd7,
		0x28, 0x53, 0x60, 0x56, 0x91, 0x2d, 0x8f, 0x94, 0x9a, 0x56, 0x44, 0xcb, 0x27, 0x66, 0xf3, 0x4a,
		0x1e, 0xd3, 0x5b, 0x56, 0xf2, 0x38, 0x0b, 0x8e, 0x38, 0xba, 0xa5, 0x96, 0x31, 0x9b, 0x86, 0x6a,
		0x29, 0x26, 0xcd, 0xae, 0x91, 0xc7, 0xcf, 0xb5, 0x82, 0x38, 0x18, 0xe8, 0x92, 0x61, 0x24, 0xd6,
		0x9e, 0xc9, 0xe7, 0xef, 0xca, 0x85, 0x93, 0xde, 0xeb, 0x5d, 0xa5, 0x70, 0xd2, 0x73, 0x3e, 0x56,
		0xec, 0x7f, 0x9c, 0xcf, 0xd5, 0xbb, 0x72, 0xa1, 0x36, 0xfb, 0x5c, 0xbf, 0x2b, 0x17, 0xea, 0x3d,
		0xfe, 0xfe, 0xbe, 0xc8, 0xbf, 0x1c, 0x4e, 0xe9, 0x09, 0xf3, 0xbf, 0xdf, 0xdd, 0xdf, 0x8f, 0x5f,
		0xae, 0xa6, 0xd6, 0xdf, 0x8b, 0x69, 0xef, 0x03, 0xff, 0x31, 0x97, 0x4e, 0x8f, 0x4b, 0x20, 0x6b,
		0x81, 0xbf, 0x85, 0xcd, 0xc6, 0xf4, 0x6c, 0x78, 0x9f, 0x2b, 0x1e, 0x55, 0xa1, 0x44, 0xa9, 0x36,
		0x6c, 0xb2, 0x36, 0x3e, 0x3f, 0xf5, 0xc7, 0xb7, 0x76, 0xeb, 0xc2, 0xea, 0x77, 0xef, 0x13, 0xd6,
		0x9e, 0x96, 0x7c, 0xa3, 0x93, 0x78, 0x28, 0x29, 0x2d, 0x4f, 0xb2, 0x11, 0xdb, 0xa3, 0xf1, 0xb9,
		0xb5, 0xe3, 0x84, 0x46, 0xe8, 0xe6, 0x4e, 0xd2, 0x99, 0xa2, 0xcf, 0x8d, 0x82, 0x2e, 0x29, 0xe2,
		0x2f, 0x12, 0x5b, 0x74, 0x7e, 0x6f, 0x0c, 0xc6, 0xa8, 0xe1, 0x3c, 0xd0, 0xef, 0x79, 0x09, 0xb0,
		0x46, 0x97, 0xde, 0x2e, 0x52, 0x73, 0xb4, 0xd3, 0xbe, 0x68, 0xfd, 0x9b, 0xd0, 0x1a, 0x75, 0xee,
		0x4d, 0x80, 0x31, 0x1a, 0x30, 0x59, 0x09, 0xb7, 0x46, 0xb7, 0x4f, 0xe6, 0x2e, 0xcd, 0x51, 0x7b,
		0x02, 0x59, 0xac, 0x51, 0x0f, 0x61, 0x0a, 0x8c, 0x51, 0xc2, 0xe5, 0x91, 0x52, 0x6b, 0x94, 0x6c,
		0xf9, 0xc4, 0x6c, 0x8e, 0x3a, 0xef, 0x24, 0x38, 0x22, 0xc5, 0xa0, 0x37, 0x4d, 0x57, 0xe8, 0x33,
		0x60, 0xa6, 0x52, 0x2e, 0xc2, 0x8c, 0xd9, 0xa9, 0x74, 0x8b, 0x34, 0x81, 0x86, 0x6a, 0x23, 0x05,
		0x86, 0x6a, 0xf3, 0xd5, 0x32, 0x27, 0xc5, 0xc2, 0xb0, 0x55, 0x38, 0xeb, 0xbd, 0x94, 0x0f, 0x6a,
		0x53, 0xbe, 0xc9, 0xe7, 0x57, 0xaf, 0x35, 0xf9, 0x97, 0xf2, 0x41, 0x7d, 0x9a, 0xcf, 0xfb, 0xfc,
		0xf2, 0xd1, 0xaf, 0x0d, 0xfe, 0x35, 0x9f, 0xcf, 0xbb, 0x26, 0xea, 0x92, 0xd9, 0x7a, 0x57, 0xae,
		0xf4, 0x3e, 0xda, 0x1f, 0x9d, 0xbf, 0x73, 0xc3, 0x97, 0xe8, 0x66, 0xde, 0xd7, 0xdc, 0x3d, 0xa0,
		0xb6, 0xce, 0xff, 0xdb, 0xec, 0x7d, 0x68, 0xf2, 0x2f, 0x8d, 0xe9, 0xec, 0xb3, 0xfd, 0x97, 0x7f,
		0xcd, 0x17, 0xdf, 0xdf, 0xdf, 0x17, 0x8b, 0xef, 0x79, 0xa7, 0x03, 0xee, 0x7d, 0xef, 0x9d, 0x5f,
		0x3f, 0x36, 0x9b, 0x6b, 0x97, 0xf8, 0xfc, 0xef, 0xc5, 0x5d, 0x58, 0xdc, 0x84, 0xcb, 0x93, 0xca,
		0x20, 0x66, 0x37, 0x8c, 0x23, 0x35, 0x90, 0xd9, 0x0c, 0x65, 0x0a, 0x2c, 0x02, 0x09, 0x72, 0x10,
		0x2b, 0x99, 0x15, 0x2b, 0x21, 0x0a, 0x5d, 0xc6, 0x99, 0xf8, 0x33, 0xec, 0x37, 0x4e, 0x0e, 0x4f,
		0x84, 0xd9, 0x19, 0x18, 0xf4, 0xa9, 0x3f, 0x2b, 0x0d, 0x60, 0xd7, 0x61, 0xd7, 0xed, 0x71, 0xd7,
		0x3d, 0x68, 0x9a, 0x22, 0x89, 0x2a, 0xcb, 0xb6, 0xab, 0x20, 0xa9, 0xe1, 0xcd, 0x80, 0xec, 0x33,
		0xb0, 0xd1, 0xef, 0xd2, 0x02, 0x03, 0x29, 0xd1, 0xc1, 0x21, 0xdb, 0xd0, 0xd4, 0xe7, 0x46, 0xc7,
		0x6a, 0x5c, 0x58, 0xbb, 0xe0, 0x79, 0xc4, 0xea, 0xd3, 0xd2, 0x01, 0xb2, 0x93, 0x0d, 0x25, 0x03,
		0xca, 0x4e, 0x30, 0x64, 0x7b, 0x86, 0xd9, 0xb7, 0x74, 0x9d, 0x02, 0x68, 0xdf, 0xd4, 0x4f, 0x72,
		0xa8, 0xdd, 0x3d, 0x48, 0x2f, 0x08, 0x65, 0x9f, 0xdd, 0x16, 0x03, 0xc0, 0xee, 0xff, 0xa8, 0x04,
		0x60, 0xeb, 0xb3, 0x17, 0x8b, 0x0a, 0x56, 0x9f, 0x1d, 0x94, 0x16, 0x88, 0xa9, 0x6f, 0x3f, 0xbd,
		0x2d, 0x56, 0x40, 0x7d, 0xf3, 0xe4, 0x24, 0x1c, 0x4b, 0xdf, 0x38, 0x79, 0x3b, 0x82, 0xd1, 0x97,
		0x4e, 0x16, 0x24, 0xc6, 0xd0, 0x29, 0x4e, 0x48, 0x4c, 0x04, 0x80, 0x1e, 0xbc, 0x1c, 0x52, 0x8a,
		0x9d, 0x07, 0x2e, 0x97, 0x98, 0x61, 0x73, 0xfb, 0xec, 0x42, 0x5d, 0x32, 0x4c, 0x91, 0xc5, 0xd0,
		0x5a, 0xa2, 0xde, 0x65, 0xba, 0xcc, 0x2c, 0x07, 0xe1, 0xcd, 0xe4, 0xcc, 0x90, 0x6f, 0x80, 0x8c,
		0x99, 0x7a, 0xc4, 0x1b, 0x24, 0x69, 0x56, 0x9e, 0xfb, 0xe2, 0x05, 0x9a, 0x03, 0xdc, 0xf7, 0x06,
		0xb1, 0xf4, 0x9f, 0xa4, 0xfe, 0x77, 0x61, 0x32, 0x16, 0xac, 0xb7, 0x9d, 0x30, 0xb8, 0xcb, 0x56,
		0x1b, 0xd8, 0xe5, 0xe6, 0xb7, 0xeb, 0x0c, 0x60, 0xeb, 0x63, 0xeb, 0x27, 0x1c, 0xe0, 0x11, 0x4c,
		0xab, 0x85, 0xa4, 0x7a, 0xeb, 0xec, 0x5d, 0xf4, 0x6a, 0x4d, 0xd1, 0xeb, 0x99, 0xfd, 0xb1, 0xab,
		0x4f, 0xa4, 0x64, 0x56, 0x20, 0x7c, 0x12, 0x0d, 0xe1, 0x51, 0xd1, 0x1e, 0x44, 0x45, 0x30, 0xfa,
		0xda, 0x98, 0xc1, 0xd9, 0xb2, 0xd6, 0x02, 0xf8, 0x13, 0xf8, 0x13, 0xf8, 0x13, 0xf8, 0x53, 0x64,
		0xfc, 0x69, 0x2c, 0xe9, 0x82, 0x68, 0xc8, 0xfd, 0x30, 0x1c, 0x6a, 0xa5, 0x0d, 0xf0, 0x28, 0xf0,
		0x28, 0x98, 0x4f, 0xd6, 0x56, 0x28, 0x50, 0x59, 0x15, 0x7b, 0xb3, 0xa2, 0xac, 0x3d, 0x6c, 0xca,
		0x23, 0x49, 0x67, 0xdb, 0xfe, 0x0e, 0x29, 0x76, 0x3d, 0x76, 0x3d, 0x34, 0x13, 0x68, 0x26, 0xd1,
		0x70, 0x24, 0xf9, 0xf1, 0x49, 0x18, 0x49, 0x23, 0x41, 0x54, 0x24, 0x16, 0x40, 0x77, 0x85, 0x7e,
		0x97, 0xbc, 0x69, 0x20, 0x1b, 0xc0, 0x74, 0xc1, 0x9e, 0x80, 0xe9, 0x22, 0x2c, 0x15, 0x9b, 0xeb,
		0x2d, 0x6e, 0x2e, 0x9c, 0xba, 0xee, 0x21, 0x46, 0x6d, 0xec, 0xd0, 0x43, 0x77, 0x58, 0x45, 0x6d,
		0xec, 0x04, 0xa8, 0xa0, 0x86, 0x64, 0x0a, 0xda, 0x0f, 0x95, 0xc5, 0x28, 0x5e, 0x90, 0xee, 0x52,
		0xf1, 0x54, 0xb4, 0xbe, 0xa8, 0x40, 0xeb, 0x84, 0x60, 0x4c, 0xba, 0xd6, 0x49, 0xb3, 0x15, 0xe2,
		0xb7, 0x8a, 0xbf, 0x4f, 0x1e, 0xa4, 0x57, 0x8a, 0xbd, 0x14, 0x3b, 0x1f, 0x32, 0x99, 0xce, 0xf8,
		0xa5, 0x51, 0xf5, 0x11, 0xcb, 0x04, 0x0e, 0x04, 0xbb, 0x77, 0xdf, 0x76, 0xaf, 0x9b, 0xe5, 0x25,
		0x18, 0xbf, 0x0c, 0x45, 0x7b, 0xb4, 0xcf, 0xe7, 0x16, 0x14, 0x79, 0x24, 0x33, 0xc0, 0x5f, 0x9b,
		0x9b, 0x02, 0x4a, 0x0f, 0x76, 0x00, 0x94, 0x1e, 0x28, 0x3d, 0x32, 0xed, 0x52, 0x9e, 0x69, 0xe7,
		0x6e, 0xc2, 0x95, 0x6f, 0x6e, 0x7e, 0x44, 0x89, 0x22, 0x4f, 0x82, 0xdb, 0x90, 0x3e, 0x75, 0xe6,
		0x34, 0x29, 0x2c, 0x7d, 0x99, 0xb5, 0xbb, 0xd4, 0x7e, 0xf2, 0x73, 0xe9, 0xb6, 0x0e, 0x16, 0x65,
		0xfa, 0xdc, 0xb6, 0x71, 0xd9, 0x63, 0xce, 0x9c, 0x6f, 0x17, 0x09, 0x33, 0xe5, 0xfc, 0xba, 0x44,
		0x91, 0x21, 0xa7, 0x48, 0x3f, 0x85, 0xbe, 0x36, 0x51, 0xcd, 0xe0, 0xc2, 0xe8, 0x4b, 0xf7, 0xc6,
		0x91, 0x2b, 0xb7, 0xf9, 0x79, 0x5c, 0x02, 0x12, 0xe6, 0xbc, 0x6f, 0x17, 0x59, 0xd6, 0xdc, 0x45,
		0xfb, 0x6f, 0xe1, 0xf4, 0xfa, 0xeb, 0x55, 0xb7, 0xdd, 0x11, 0xba, 0xad, 0x4f, 0x17, 0x24, 0x09,
		0x74, 0xeb, 0x34, 0x49, 0xc8, 0xa5, 0xdb, 0x3e, 0x79, 0xb4, 0x5a, 0x55, 0xdc, 0x09, 0x75, 0x5b,
		0x27, 0x97, 0x8d, 0x09, 0x06, 0x66, 0xd5, 0xb5, 0x4e, 0x2f, 0xc8, 0x93, 0xe9, 0xac, 0x9b, 0xd3,
		0x90, 0x43, 0x47, 0xb6, 0x0c, 0x58, 0x95, 0xec, 0x7d, 0x27, 0xd2, 0x11, 0x2d, 0x93, 0x68, 0xb4,
		0x32, 0xe2, 0x6c, 0xba, 0x25, 0x7e, 0xf0, 0xd9, 0xce, 0x9a, 0xbf, 0xed, 0xb6, 0xba, 0x5f, 0x6f,
		0xe9, 0x4d, 0xd1, 0xcd, 0x4d, 0x65, 0xc1, 0x04, 0xa4, 0x5b, 0x9a, 0x59, 0xb3, 0x03, 0xa9, 0x96,
		0x6e, 0xe2, 0xb0, 0x21, 0xeb, 0xed, 0x07, 0x76, 0x75, 0x80, 0x10, 0x51, 0x9a, 0x88, 0xdb, 0xda,
		0xcc, 0x38, 0x22, 0x61, 0x19, 0x60, 0x16, 0x60, 0x16, 0x09, 0x61, 0x16, 0xec, 0x6c, 0xa2, 0x46,
		0x41, 0xd3, 0x56, 0x27, 0x23, 0xfa, 0xc9, 0xee, 0x6a, 0xb7, 0x4e, 0x18, 0x0a, 0x4b, 0xf8, 0x41,
		0xae, 0xbc, 0x38, 0x2e, 0x32, 0xc7, 0x10, 0xf6, 0x50, 0xb1, 0x0b, 0xcf, 0x3a, 0x71, 0x90, 0x39,
		0x3a, 0xd7, 0xff, 0x01, 0x6d, 0x37, 0xcf, 0x55, 0x93, 0xad, 0x8f, 0xb3, 0xf7, 0x63, 0x8a, 0x4d,
		0x99, 0x0d, 0x4e, 0x93, 0x2b, 0xef, 0x28, 0xb4, 0x61, 0x1a, 0x23, 0x97, 0xbe, 0xb9, 0xbe, 0xb8,
		0x10, 0xce, 0x2d, 0xf6, 0xfa, 0xad, 0x75, 0x41, 0xcf, 0x9f, 0x97, 0xc9, 0xc1, 0x99, 0xc1, 0x99,
		0xf7, 0xc8, 0x99, 0xc7, 0x9a, 0xa2, 0x08, 0xb2, 0xf5, 0xee, 0xcf, 0xa2, 0xc2, 0xc0, 0x9b, 0x8f,
		0x28, 0x48, 0x3a, 0xa2, 0xfa, 0x28, 0xa5, 0x27, 0x04, 0xaf, 0x5c, 0x46, 0x10, 0x1e, 0xeb, 0xe0,
		0xd5, 0xaa, 0x27, 0xb5, 0x93, 0xc6, 0x51, 0xf5, 0xa4, 0x8e, 0x60, 0xbc, 0x5d, 0xdb, 0x15, 0x09,
		0x70, 0xa6, 0x78, 0x58, 0xa0, 0xdf, 0xa5, 0x75, 0x7c, 0xb4, 0x14, 0x0c, 0x9e, 0x6d, 0x44, 0xdb,
		0x15, 0xe9, 0xe7, 0xa9, 0xd3, 0xb0, 0xb0, 0x76, 0x61, 0xfd, 0x49, 0x82, 0xf5, 0x24, 0x56, 0x17,
		0xcb, 0x16, 0xd4, 0xf4, 0xd3, 0xd7, 0xb3, 0xb3, 0x76, 0x47, 0xb8, 0xb9, 0xbe, 0xbe, 0x10, 0xfe,
		0xd5, 0xea, 0xb6, 0x3b, 0x97, 0xad, 0xce, 0x5f, 0xe4, 0xe0, 0xa1, 0x3f, 0x39, 0xe0, 0x44, 0xc0,
		0x89, 0x80, 0x13, 0xa1, 0x87, 0x02, 0x4e, 0x04, 0x9c, 0x08, 0x38, 0x11, 0xcc, 0x02, 0xcc, 0x02,
		0x70, 0x22, 0xe0, 0x44, 0xc0, 0x89, 0x80, 0x13, 0xc1, 0x99, 0x01, 0x27, 0x02, 0x4e, 0x04, 0x9c,
		0x08, 0x38, 0x11, 0x70, 0xa2, 0x0f, 0x9c, 0xc8, 0x02, 0xa7, 0x45, 0x05, 0x30, 0xfa, 0x3f, 0x7b,
		0x07, 0x90, 0xe3, 0xe7, 0xf6, 0xa7, 0xaf, 0x5f, 0x66, 0x0f, 0xa7, 0x38, 0x38, 0x77, 0x89, 0x0c,
		0x10, 0x23, 0x20, 0x46, 0x40, 0x8c, 0xd0, 0x4d, 0x01, 0x31, 0x02, 0x62, 0x04, 0xc4, 0x08, 0x66,
		0x01, 0x66, 0x01, 0x88, 0x11, 0x10, 0x63, 0x9a, 0x21, 0xc6, 0x54, 0x1a, 0x6c, 0x34, 0x46, 0x49,
		0x54, 0x86, 0xda, 0xf2, 0x33, 0x77, 0x60, 0xa0, 0x9d, 0x5d, 0x5c, 0xff, 0x4b, 0x38, 0xbd, 0xea,
		0x0a, 0x9d, 0xeb, 0xaf, 0xdd, 0x36, 0xc5, 0xb1, 0x6c, 0xcb, 0x74, 0x30, 0xd1, 0x60, 0xa2, 0xc1,
		0x44, 0x83, 0xd6, 0x05, 0x13, 0x0d, 0x26, 0x1a, 0x4c, 0x34, 0x30, 0x0b, 0x30, 0x0b, 0x98, 0x68,
		0x30, 0xd1, 0xd2, 0x6c, 0xa2, 0x21, 0x0a, 0x04, 0x9c, 0xf9, 0x0d, 0x71, 0x66, 0x44, 0x81, 0xac,
		0x12, 0x23, 0x0a, 0x04, 0x51, 0x20, 0x6c, 0x32, 0x88, 0x43, 0x14, 0x08, 0x31, 0xa8, 0x48, 0x85,
		0xa3, 0x45, 0x85, 0x2a, 0xae, 0x3c, 0x74, 0x97, 0xb0, 0x62, 0xb7, 0xd3, 0xba, 0x61, 0x40, 0x15,
		0x6d, 0x32, 0x80, 0x8a, 0x00, 0x15, 0x01, 0x2a, 0x42, 0x1b, 0x05, 0xa8, 0x08, 0x50, 0x11, 0xa0,
		0x22, 0x98, 0x05, 0x98, 0x05, 0x40, 0x45, 0x80, 0x8a, 0x00, 0x15, 0x01, 0x2a, 0x82, 0x33, 0x03,
		0x54, 0x04, 0xa8, 0x08, 0x50, 0x11, 0xa0, 0x22, 0x40, 0xc5, 0x6d, 0xa0, 0x22, 0x01, 0x8c, 0x16,
		0x39, 0xa6, 0x68, 0x3f, 0x73, 0x07, 0x90, 0xe2, 0xcd, 0xd9, 0xe9, 0xbf, 0x3e, 0x93, 0x43, 0x89,
		0xce, 0xed, 0x80, 0x10, 0x01, 0x21, 0x02, 0x42, 0x84, 0xee, 0x09, 0x08, 0x11, 0x10, 0x22, 0x20,
		0x44, 0x30, 0x0b, 0x30, 0x0b, 0x40, 0x88, 0x80, 0x10, 0xd3, 0x0c, 0x21, 0xa6, 0xd2, 0x20, 0x23,
		0x31, 0x46, 0xa2, 0x32, 0xc4, 0x9c, 0x67, 0xed, 0xc2, 0x00, 0xfb, 0x22, 0x7c, 0xee, 0x5c, 0x53,
		0x44, 0x73, 0xcc, 0x08, 0x60, 0x84, 0xc1, 0x08, 0x83, 0x11, 0x06, 0xbd, 0x0a, 0x46, 0x18, 0x8c,
		0x30, 0x18, 0x61, 0x60, 0x16, 0x60, 0x16, 0x30, 0xc2, 0x60, 0x84, 0xa5, 0xd9, 0x08, 0x43, 0x1c,
		0x07, 0x38, 0xf3, 0x1b, 0xe2, 0xcc, 0x88, 0xe3, 0x58, 0x25, 0x46, 0x1c, 0x07, 0xe2, 0x38, 0xd8,
		0x64, 0x10, 0x87, 0x38, 0x0e, 0x72, 0xd8, 0x90, 0x08, 0x40, 0x8b, 0x0c, 0x38, 0x74, 0x9f, 0xb6,
		0x1b, 0xe8, 0x90, 0xe1, 0xc0, 0xb1, 0x25, 0x2a, 0x80, 0x88, 0x00, 0x11, 0x01, 0x22, 0x42, 0xfb,
		0x04, 0x88, 0x08, 0x10, 0x11, 0x20, 0x22, 0x98, 0x05, 0x98, 0x05, 0x40, 0x44, 0x80, 0x88, 0x00,
		0x11, 0x01, 0x22, 0x82, 0x33, 0x03, 0x44, 0x04, 0x88, 0x08, 0x10, 0x11, 0x20, 0x22, 0x40, 0x44,
		0x7f, 0x10, 0x31, 0xee, 0xe3, 0xc5, 0x96, 0x1e, 0xb9, 0x0b, 0x38, 0xf1, 0xba, 0xd3, 0xa5, 0x80,
		0x11, 0xad, 0xbb, 0x01, 0x1f, 0x02, 0x3e, 0x04, 0x7c, 0x08, 0xbd, 0x13, 0xf0, 0x21, 0xe0, 0x43,
		0xc0, 0x87, 0x60, 0x16, 0x60, 0x16, 0x80, 0x0f, 0x01, 0x1f, 0x02, 0x3e, 0x04, 0x7c, 0x08, 0xce,
		0x0c, 0xf8, 0x10, 0xf0, 0x21, 0xe0, 0x43, 0xc0, 0x87, 0x80, 0x0f, 0xfd, 0xe0, 0xc3, 0x60, 0xf4,
		0x2c, 0x32, 0xd8, 0xd0, 0x7a, 0xd4, 0x8e, 0xe0, 0x42, 0xe1, 0xd3, 0xd7, 0xb3, 0xb3, 0x76, 0x87,
		0x36, 0x83, 0x79, 0x95, 0x12, 0x30, 0x22, 0x60, 0x44, 0xc0, 0x88, 0xd0, 0x3f, 0x01, 0x23, 0x02,
		0x46, 0x04, 0x8c, 0x08, 0x66, 0x01, 0x66, 0x01, 0x18, 0x11, 0x30, 0x22, 0x60, 0x44, 0xc0, 0x88,
		0xe0, 0xcc, 0x80, 0x11, 0x01, 0x23, 0x02, 0x46, 0x04, 0x8c, 0x08, 0x18, 0x71, 0x03, 0x8c, 0x48,
		0x81, 0xa4, 0x45, 0x09, 0x29, 0x2e, 0x3d, 0x76, 0x57, 0xf0, 0x62, 0xa7, 0xd5, 0x6d, 0xdf, 0x52,
		0x02, 0x8b, 0x0e, 0x0d, 0x20, 0x45, 0x40, 0x8a, 0x80, 0x14, 0xa1, 0x8b, 0x02, 0x52, 0x04, 0xa4,
		0x08, 0x48, 0x11, 0xcc, 0x02, 0xcc, 0x02, 0x90, 0x22, 0x20, 0xc5, 0x34, 0x43, 0x8a, 0xe9, 0x35,
		0xd0, 0x48, 0x2c, 0x92, 0x48, 0x4d, 0x33, 0xe7, 0x81, 0x3b, 0x30, 0xca, 0xfe, 0xdf, 0xd7, 0xf6,
		0xd7, 0x36, 0xb9, 0x3d, 0xe6, 0xdc, 0x0e, 0x53, 0x0c, 0xa6, 0x18, 0x4c, 0x31, 0x68, 0x57, 0x30,
		0xc5, 0x60, 0x8a, 0xc1, 0x14, 0x03, 0xb3, 0x00, 0xb3, 0x80, 0x29, 0x06, 0x53, 0x2c, 0xcd, 0xa6,
		0x18, 0xa2, 0x3b, 0xc0, 0x99, 0xdf, 0x10, 0x67, 0x46, 0x74, 0xc7, 0x2a, 0x31, 0xa2, 0x3b, 0x10,
		0xdd, 0xc1, 0x26, 0x83, 0x38, 0x44, 0x77, 0x10, 0x83, 0x87, 0x24, 0xf0, 0x59, 0x54, 0xb8, 0xa1,
		0xf3, 0xac, 0x5d, 0x41, 0x86, 0x2c, 0x75, 0xea, 0x57, 0x09, 0x01, 0x23, 0x02, 0x46, 0x04, 0x8c,
		0x08, 0xfd, 0x13, 0x30, 0x22, 0x60, 0x44, 0xc0, 0x88, 0x60, 0x16, 0x60, 0x16, 0x80, 0x11, 0x01,
		0x23, 0x02, 0x46, 0x04, 0x8c, 0x08, 0xce, 0x0c, 0x18, 0x11, 0x30, 0x22, 0x60, 0x44, 0xc0, 0x88,
		0x80, 0x11, 0x37, 0xc1, 0x88, 0xb1, 0x57, 0xab, 0x5f, 0x7d, 0xea, 0x0e, 0xa0, 0xc5, 0xce, 0xf9,
		0x19, 0x39, 0x9c, 0x68, 0xdd, 0x0c, 0x08, 0x11, 0x10, 0x22, 0x20, 0x44, 0xe8, 0x9e, 0x80, 0x10,
		0x01, 0x21, 0x02, 0x42, 0x04, 0xb3, 0x00, 0xb3, 0x00, 0x84, 0x08, 0x08, 0x11, 0x10, 0x22, 0x20,
		0x44, 0x70, 0x66, 0x40, 0x88, 0x80, 0x10, 0x01, 0x21, 0x02, 0x42, 0x04, 0x84, 0xe8, 0x03, 0x21,
		0x06, 0x83, 0x67, 0x51, 0xc1, 0x86, 0xd6, 0x93, 0x76, 0x03, 0x15, 0xd2, 0x16, 0x93, 0x5a, 0x90,
		0x00, 0x36, 0x04, 0x6c, 0x08, 0xd8, 0x10, 0xfa, 0x26, 0x60, 0x43, 0xc0, 0x86, 0x80, 0x0d, 0xc1,
		0x2c, 0xc0, 0x2c, 0x00, 0x1b, 0x02, 0x36, 0x4c, 0x33, 0x6c, 0x98, 0x56, 0x23, 0x2c, 0xd6, 0x52,
		0x52, 0x8b, 0xe7, 0xed, 0xc0, 0x20, 0xeb, 0x7e, 0xbd, 0xba, 0x6a, 0x5f, 0x90, 0x5b, 0x63, 0xee,
		0xfd, 0x30, 0xc5, 0x60, 0x8a, 0xc1, 0x14, 0x83, 0x76, 0x05, 0x53, 0x0c, 0xa6, 0x18, 0x4c, 0x31,
		0x30, 0x0b, 0x30, 0x0b, 0x98, 0x62, 0x30, 0xc5, 0xd2, 0x6c, 0x8a, 0x21, 0x82, 0x03, 0x9c, 0xf9,
		0x0d, 0x71, 0x66, 0x44, 0x70, 0xac, 0x12, 0x23, 0x82, 0x03, 0x11, 0x1c, 0x6c, 0x32, 0x88, 0x43,
		0x04, 0x07, 0x31, 0x78, 0x48, 0x84, 0x9f, 0x45, 0x85, 0x1c, 0xba, 0x0f, 0x63, 0x85, 0x0d, 0x7f,
		0xa3, 0x18, 0x58, 0xd2, 0x01, 0x8d, 0x6a, 0x20, 0xb7, 0x8c, 0x60, 0x04, 0x23, 0xe7, 0x3f, 0x64,
		0xeb, 0x03, 0xe2, 0x33, 0x18, 0xb9, 0xb3, 0x8b, 0xeb, 0x7f, 0xcd, 0x5b, 0xeb, 0x5c, 0x7f, 0xed,
		0xb6, 0x85, 0x9b, 0x56, 0xb7, 0xdb, 0xee, 0x5c, 0x6d, 0x1c, 0x18, 0x8f, 0x09, 0xbb, 0x91, 0x76,
		0xc3, 0xb0, 0x6f, 0x47, 0x5a, 0x03, 0xf5, 0x21, 0x12, 0xfd, 0x87, 0x56, 0xdf, 0x21, 0xd5, 0x6f,
		0xa8, 0xf5, 0x19, 0x6a, 0xfd, 0x85, 0x41, 0x5f, 0xa1, 0x5b, 0xf4, 0x41, 0xc8, 0xe8, 0x96, 0x09,
		0x15, 0x2e, 0xce, 0x6f, 0xbb, 0xe4, 0xb8, 0x7b, 0x50, 0x43, 0x00, 0xe4, 0x01, 0xc8, 0xaf, 0xdf,
		0x28, 0x8f, 0x85, 0x31, 0x9d, 0x81, 0x33, 0x9f, 0xad, 0x05, 0x29, 0x2c, 0x35, 0x58, 0x6a, 0x7b,
		0xb4, 0xd4, 0xe4, 0x71, 0x81, 0x7a, 0x0c, 0xe7, 0xfc, 0xee, 0x84, 0x82, 0xc6, 0x7d, 0xc5, 0x9d,
		0x5b, 0x69, 0x8b, 0x8e, 0x3d, 0xd7, 0x0a, 0x4c, 0xcb, 0x83, 0xd5, 0x97, 0x10, 0xda, 0xa7, 0x30,
		0x6f, 0x20, 0x9f, 0xbf, 0x2b, 0x17, 0x4e, 0x7a, 0xaf, 0x77, 0x95, 0xc2, 0x49, 0xcf, 0xf9, 0x58,
		0xb1, 0xff, 0x71, 0x3e, 0x57, 0xef, 0xca, 0x85, 0xda, 0xec, 0x73, 0xfd, 0xae, 0x5c, 0xa8, 0xf7,
		0xf8, 0xfb, 0xfb, 0x22, 0xff, 0x72, 0x38, 0xa5, 0x27, 0x2c, 0xb9, 0x0f, 0xe3, 0x5f, 0xf3, 0x77,
		0x95, 0x42, 0xb5, 0x37, 0xfb, 0x72, 0x78, 0x57, 0x2e, 0x54, 0x7b, 0x3c, 0x9f, 0xa3, 0xee, 0x42,
		0x6f, 0x97, 0x60, 0x63, 0xb8, 0x15, 0xd1, 0x48, 0xef, 0x8a, 0x68, 0xbe, 0x5a, 0x33, 0x23, 0x16,
		0x86, 0xad, 0xc2, 0x59, 0xef, 0xa5, 0x7c, 0x50, 0x9b, 0xf2, 0x4d, 0x3e, 0xbf, 0x7a, 0xad, 0xc9,
		0xbf, 0x94, 0x0f, 0xea, 0xd3, 0x7c, 0xde, 0xe7, 0x97, 0x8f, 0x7e, 0x6d, 0xf0, 0xaf, 0xf9, 0x7c,
		0xde, 0x5d, 0x0b, 0x4b, 0xeb, 0xe3, 0xae, 0x5c, 0xe9, 0x7d, 0xb4, 0x3f, 0x3a, 0x7f, 0xe7, 0x2b,
		0x8c, 0xe8, 0x66, 0x9e, 0xcf, 0x7b, 0x17, 0x96, 0xf5, 0xef, 0x4b, 0x75, 0xca, 0xbf, 0xe6, 0xad,
		0xe5, 0x58, 0x99, 0x2f, 0xb2, 0x8a, 0xd5, 0xc8, 0xb1, 0x75, 0x7b, 0xee, 0x80, 0x79, 0xab, 0xfc,
		0xb7, 0xd9, 0xfb, 0xd0, 0xe4, 0x5f, 0x1a, 0xd3, 0xd9, 0x67, 0xfb, 0x2f, 0xff, 0x9a, 0x2f, 0xbe,
		0xbf, 0xbf, 0x2f, 0x16, 0xdf, 0xf3, 0x4e, 0x27, 0xdd, 0xfb, 0xde, 0x3b, 0xbf, 0x7e, 0x6c, 0x36,
		0xd7, 0x2e, 0xf1, 0xf9, 0x52, 0xf1, 0xc3, 0xee, 0x17, 0x7c, 0x22, 0x7d, 0x84, 0x23, 0xf1, 0xa7,
		0x30, 0x12, 0xcd, 0xfe, 0x93, 0x23, 0xca, 0xe8, 0x35, 0x9a, 0xd5, 0x06, 0xa0, 0xd7, 0x40, 0xaf,
		0xd9, 0xa3, 0x5e, 0x33, 0x91, 0x55, 0xf3, 0xb0, 0x0a, 0xe8, 0xd9, 0x0b, 0x3d, 0x03, 0x78, 0x66,
		0x1d, 0xba, 0x7a, 0x19, 0x80, 0x73, 0xa2, 0x01, 0xe7, 0xbf, 0xa4, 0x5f, 0x34, 0x66, 0x75, 0xee,
		0x42, 0x36, 0xcc, 0x96, 0x69, 0x12, 0x1a, 0xfa, 0x97, 0xb2, 0xda, 0x56, 0x24, 0x8b, 0x31, 0x12,
		0x4e, 0xa1, 0xb5, 0xea, 0x3c, 0x14, 0x95, 0xe3, 0x5a, 0xad, 0x71, 0x54, 0xab, 0x95, 0x8f, 0x0e,
		0x8f, 0xca, 0x27, 0xf5, 0x7a, 0xa5, 0x51, 0x21, 0xf0, 0x60, 0xe4, 0xae, 0xf5, 0x81, 0xa4, 0x4b,
		0x83, 0x4f, 0x56, 0xd7, 0xd4, 0x89, 0xa2, 0xa4, 0x01, 0x92, 0xdf, 0x84, 0xa3, 0x95, 0xc2, 0x41,
		0x6c, 0x8c, 0xc8, 0xf3, 0xc6, 0x47, 0x06, 0xbd, 0xcd, 0x0e, 0x62, 0x81, 0xb7, 0x3c, 0xf2, 0x5b,
		0xe7, 0x2c, 0x3a, 0xc0, 0x72, 0xde, 0x18, 0x40, 0x4b, 0x80, 0x96, 0x00, 0x2d, 0xa1, 0xdc, 0x03,
		0xb4, 0x04, 0x68, 0x09, 0xd0, 0x12, 0xa0, 0x25, 0x40, 0x4b, 0x80, 0x96, 0x00, 0x2d, 0x01, 0x5a,
		0x42, 0xaf, 0x01, 0x68, 0x09, 0xd0, 0x12, 0xa0, 0x25, 0x40, 0xcb, 0x58, 0x84, 0xd4, 0xb3, 0x3e,
		0x14, 0x5c, 0xcc, 0x8a, 0x52, 0x3a, 0xcd, 0x29, 0x21, 0x96, 0x20, 0x96, 0xf6, 0x28, 0x96, 0x0c,
		0x27, 0x89, 0x6d, 0xc7, 0x99, 0xb8, 0x17, 0x92, 0xfa, 0x68, 0x83, 0xcd, 0xe9, 0x10, 0x4c, 0x48,
		0xe3, 0x60, 0x97, 0xe9, 0x0d, 0x08, 0xa6, 0x5d, 0x0b, 0xa6, 0x28, 0xbc, 0x69, 0x33, 0xf9, 0xc3,
		0xc1, 0xad, 0xb6, 0x99, 0xcb, 0x27, 0xd7, 0xad, 0x46, 0xe8, 0x08, 0xe2, 0xe2, 0x73, 0xad, 0xcd,
		0xdf, 0x28, 0x0b, 0x39, 0x33, 0x94, 0xb9, 0x24, 0x11, 0x0f, 0x33, 0x71, 0x0e, 0xcd, 0x6f, 0x5b,
		0x86, 0x2a, 0x68, 0x88, 0x98, 0x86, 0xc6, 0xa7, 0xff, 0xb4, 0xfd, 0x5e, 0xee, 0xdc, 0xa2, 0x0b,
		0x9e, 0xd7, 0xcf, 0x39, 0x0f, 0x7e, 0x54, 0x47, 0xf2, 0xda, 0xab, 0x2f, 0x14, 0x97, 0xc5, 0x3d,
		0x2b, 0x1d, 0xf7, 0x77, 0x7e, 0x6e, 0x54, 0x89, 0xb7, 0xa9, 0xbe, 0xf3, 0xa7, 0xf9, 0x3c, 0x87,
		0x44, 0x85, 0x25, 0x56, 0x55, 0x89, 0x55, 0xd2, 0x25, 0xd5, 0xd3, 0x7e, 0x2b, 0xca, 0x65, 0xb1,
		0xc9, 0x99, 0x98, 0xfb, 0x72, 0x75, 0x79, 0x1e, 0x9c, 0x67, 0x65, 0xdf, 0x95, 0x80, 0x8c, 0xaa,
		0x0d, 0x13, 0x42, 0x6b, 0x5b, 0xc4, 0x9c, 0x49, 0xe5, 0x3f, 0x61, 0x6c, 0x2c, 0x30, 0x30, 0x83,
		0xaa, 0x2f, 0xe9, 0xb6, 0x28, 0x25, 0x0c, 0x3b, 0x70, 0x6e, 0x4f, 0x41, 0x60, 0x41, 0xc0, 0xd4,
		0xb3, 0x9a, 0x97, 0x7b, 0x0e, 0x28, 0xd8, 0xbe, 0x34, 0xa2, 0xd1, 0xfd, 0x88, 0x03, 0x09, 0xfa,
		0xa2, 0xd0, 0xd7, 0x19, 0x30, 0x77, 0x97, 0x2e, 0x03, 0x98, 0x06, 0xe1, 0x22, 0xcb, 0x18, 0x96,
		0x41, 0xb6, 0x08, 0xdf, 0x26, 0x86, 0xc1, 0x5c, 0x4d, 0x2c, 0x5f, 0xba, 0x13, 0x0b, 0xff, 0xb4,
		0x0a, 0xff, 0x29, 0x17, 0x4e, 0x84, 0x42, 0xef, 0x03, 0xff, 0xbe, 0x94, 0x5f, 0xb9, 0x52, 0xec,
		0xd3, 0x60, 0x47, 0x71, 0x22, 0x9c, 0x86, 0xa4, 0x3f, 0x4b, 0x3a, 0x1b, 0x37, 0xf0, 0xd0, 0x82,
		0x23, 0x80, 0x23, 0x80, 0x23, 0x64, 0x89, 0x23, 0x7c, 0xb7, 0x71, 0x24, 0x36, 0x8e, 0x60, 0xd1,
		0x82, 0x23, 0x80, 0x23, 0x80, 0x23, 0xd0, 0x70, 0x04, 0x6b, 0xd7, 0xbc, 0xc5, 0x5a, 0x41, 0xd6,
		0x82, 0xf3, 0x7e, 0xfc, 0x72, 0x75, 0x79, 0x5e, 0x22, 0xb1, 0x56, 0x37, 0xc1, 0x53, 0x5f, 0xd4,
		0x91, 0x2c, 0x2c, 0x3e, 0x59, 0xed, 0x09, 0xa7, 0x76, 0x7b, 0x3b, 0x48, 0x0d, 0xf0, 0x45, 0xb1,
		0xc2, 0xb0, 0x14, 0xd8, 0xe0, 0x6f, 0xc4, 0x06, 0x57, 0x64, 0x49, 0x35, 0x05, 0x71, 0x62, 0x6f,
		0x06, 0x5a, 0x43, 0xdc, 0x43, 0x0c, 0x49, 0x0b, 0x49, 0x1b, 0xa3, 0xa4, 0x7d, 0xd0, 0x34, 0x45,
		0x12, 0x55, 0x16, 0x51, 0x5b, 0x89, 0x51, 0x8d, 0x55, 0xb4, 0x47, 0x41, 0x91, 0x9e, 0x25, 0x85,
		0x7e, 0x73, 0x2d, 0x48, 0xb1, 0xb5, 0xb0, 0xb5, 0x62, 0xdc, 0x5a, 0x13, 0x59, 0x35, 0x8f, 0x19,
		0x36, 0x56, 0x3d, 0xb3, 0x21, 0xa4, 0x88, 0xd4, 0x61, 0x1e, 0xba, 0x4c, 0x54, 0xab, 0xcd, 0x40,
		0x0c, 0xe9, 0x58, 0x63, 0xc1, 0x56, 0x6d, 0x2a, 0x88, 0x1f, 0x88, 0x9f, 0x18, 0xc5, 0x8f, 0xb5,
		0xe6, 0x0a, 0xea, 0x64, 0xf4, 0x40, 0x17, 0xe6, 0xeb, 0x2e, 0xbf, 0x06, 0x84, 0x10, 0x84, 0xd0,
		0xea, 0xd0, 0x35, 0xea, 0xf5, 0x43, 0x14, 0xfc, 0x7e, 0xab, 0x20, 0x1e, 0x29, 0x8a, 0x44, 0x88,
		0xe1, 0x7d, 0x09, 0xe4, 0xaa, 0x89, 0x08, 0x3f, 0xf4, 0x1b, 0x0a, 0xca, 0xc0, 0x42, 0x9f, 0xde,
		0xef, 0x31, 0x68, 0x70, 0xa5, 0x43, 0x84, 0x41, 0x82, 0xcb, 0x7d, 0x20, 0x0f, 0x0b, 0x7c, 0x12,
		0x8d, 0xa7, 0xa0, 0xb0, 0x40, 0xfb, 0x9e, 0x18, 0xc2, 0x02, 0x7d, 0x9e, 0xc3, 0xed, 0x3f, 0x2c,
		0xd0, 0x7e, 0xab, 0xa8, 0xc2, 0x02, 0x6f, 0xff, 0x75, 0xde, 0x3d, 0xfd, 0x53, 0xf8, 0xb3, 0x75,
		0xfb, 0x67, 0x70, 0x74, 0xa0, 0xf7, 0xe6, 0x04, 0x04, 0x09, 0x6e, 0x98, 0x1e, 0x5a, 0x65, 0x32,
		0xe6, 0x20, 0x41, 0xff, 0xe9, 0x63, 0x63, 0x54, 0x81, 0x41, 0x82, 0x5f, 0x2e, 0xae, 0x3f, 0xb5,
		0x28, 0x4e, 0x31, 0x75, 0xef, 0x4f, 0x81, 0x8b, 0x22, 0x60, 0xf2, 0x59, 0x2d, 0x8a, 0x3d, 0xbb,
		0x28, 0xb6, 0x2f, 0x8e, 0x68, 0x04, 0x3e, 0xb1, 0x8b, 0x42, 0xea, 0x8f, 0xc6, 0x82, 0x2f, 0x3f,
		0x0e, 0x9c, 0x9d, 0x05, 0x69, 0x06, 0x8c, 0x58, 0x8a, 0x7e, 0x64, 0xc8, 0x88, 0x25, 0x5b, 0x8a,
		0x49, 0x33, 0x62, 0xad, 0xb7, 0x2e, 0x0c, 0x65, 0x49, 0x19, 0x64, 0xf6, 0x5c, 0xc1, 0xf3, 0x2b,
		0xe1, 0xe6, 0xba, 0xd3, 0x65, 0x3e, 0x58, 0xf0, 0xf3, 0x6d, 0x57, 0xb8, 0x6c, 0x9d, 0x32, 0xd1,
		0xbb, 0x2f, 0x70, 0xd5, 0xee, 0x08, 0x61, 0x9a, 0xa9, 0x2c, 0x9a, 0xb9, 0xed, 0x9c, 0x32, 0x37,
		0x53, 0x5d, 0x34, 0xd3, 0xee, 0xfe, 0xd9, 0xee, 0x74, 0xff, 0x7d, 0xd3, 0x66, 0x6a, 0xe8, 0x70,
		0xd1, 0xd0, 0xf9, 0x8d, 0x70, 0xd3, 0xb9, 0xee, 0x5e, 0x9f, 0x5e, 0x5f, 0x30, 0x35, 0x55, 0x5b,
		0x1e, 0xa1, 0xf3, 0x1b, 0xa6, 0x56, 0xea, 0xcb, 0x03, 0xc4, 0xd8, 0x4a, 0x63, 0xd1, 0xca, 0x45,
		0xcd, 0x7e, 0x1d, 0xe6, 0x85, 0x73, 0xb4, 0xd4, 0x94, 0xf5, 0x4e, 0xac, 0x4d, 0xd9, 0x93, 0x16,
		0x62, 0xd6, 0xed, 0xb9, 0x0a, 0x35, 0xdd, 0xf6, 0x14, 0x7d, 0xbb, 0x68, 0x5d, 0x09, 0xe7, 0x9f,
		0x59, 0xe8, 0x9d, 0xc9, 0x09, 0xb7, 0x4e, 0x1a, 0xb3, 0x9d, 0xc8, 0x36, 0xb5, 0x47, 0xb3, 0x41,
		0x64, 0x23, 0x3f, 0xb6, 0xc8, 0x43, 0x2e, 0x89, 0x13, 0xb7, 0x8d, 0xf9, 0x5a, 0x48, 0xea, 0x41,
		0xa5, 0xee, 0x28, 0x53, 0x41, 0x94, 0x4b, 0xc4, 0xd6, 0x42, 0x65, 0x3b, 0xe5, 0x74, 0xb1, 0x4c,
		0x9b, 0xdc, 0x21, 0x03, 0xfd, 0x12, 0x1f, 0xa1, 0x93, 0x4f, 0x3e, 0x6d, 0xb8, 0xfd, 0x28, 0x33,
		0x37, 0xe2, 0xed, 0x4e, 0xa5, 0xca, 0xdc, 0x8c, 0x77, 0xeb, 0x34, 0xb9, 0x0a, 0xfb, 0xc0, 0x78,
		0x57, 0x30, 0x5b, 0x6e, 0xba, 0x0f, 0x4b, 0x6b, 0x72, 0x95, 0x23, 0xe6, 0x86, 0xdc, 0x2d, 0xd9,
		0xe4, 0x2a, 0xf5, 0x50, 0x6d, 0xb8, 0x53, 0x55, 0x61, 0x6a, 0x64, 0xd6, 0x0f, 0xa6, 0x89, 0x5e,
		0x9a, 0x1b, 0x96, 0x4e, 0x2c, 0x4f, 0xca, 0x31, 0x5b, 0x0b, 0x9e, 0xd9, 0x38, 0x61, 0x68, 0x61,
		0x3e, 0x0d, 0x47, 0x8c, 0xc4, 0xce, 0xf8, 0xb3, 0x2c, 0xf1, 0x99, 0x5c, 0x69, 0x72, 0xb5, 0xfd,
		0x9e, 0x6c, 0x4c, 0xa8, 0x6a, 0x53, 0xe5, 0xfd, 0x2f, 0xbc, 0x03, 0xb4, 0xf9, 0xff, 0x5e, 0xbf,
		0x42, 0xe8, 0x3a, 0x00, 0xf3, 0xc6, 0xa8, 0xea, 0x01, 0x50, 0x00, 0xea, 0x24, 0x01, 0x46, 0xe2,
		0x23, 0xa3, 0x6d, 0x3c, 0xa7, 0x84, 0x69, 0x0c, 0xd3, 0x18, 0xa6, 0x31, 0x4c, 0x63, 0x98, 0xc6,
		0x30, 0x8d, 0x61, 0x1a, 0xc3, 0x34, 0x86, 0x69, 0x0c, 0xd3, 0x18, 0xa6, 0x31, 0x4c, 0x63, 0x98,
		0xc6, 0x30, 0x8d, 0x13, 0x6b, 0x1a, 0xef, 0x3f, 0xd6, 0xcc, 0xb2, 0x63, 0xbc, 0x1f, 0x3d, 0x51,
		0x29, 0x25, 0xa2, 0xf8, 0x05, 0x6e, 0x43, 0xc8, 0xd2, 0x9f, 0xa2, 0xf1, 0x24, 0x78, 0x3e, 0x2d,
		0xda, 0x15, 0xdc, 0x76, 0x93, 0x1f, 0x7d, 0xb6, 0x65, 0x70, 0x28, 0x83, 0xd0, 0x36, 0x8f, 0xc6,
		0x1e, 0x63, 0xd1, 0x56, 0xba, 0x47, 0x18, 0x8b, 0xb6, 0xdc, 0x15, 0xf2, 0x58, 0x34, 0x59, 0x35,
		0x25, 0x7d, 0x28, 0xfa, 0x00, 0x16, 0x2b, 0x01, 0x69, 0x8b, 0x1b, 0x63, 0x88, 0x4a, 0x93, 0x55,
		0x73, 0x98, 0xbc, 0xa8, 0x34, 0xfb, 0xad, 0xa2, 0x8a, 0x4a, 0x3b, 0xbf, 0xea, 0xb6, 0x3b, 0x67,
		0xad, 0xd3, 0x76, 0x70, 0x4c, 0xda, 0xe2, 0xd6, 0x04, 0x44, 0xa4, 0x6d, 0x98, 0x1a, 0x5a, 0xf8,
		0x2b, 0xe6, 0x88, 0x34, 0xff, 0xa9, 0x63, 0x63, 0x5e, 0x81, 0x11, 0x69, 0xf3, 0xf9, 0x12, 0xce,
		0x6f, 0x6e, 0x3a, 0xed, 0xb3, 0xf3, 0xbf, 0x29, 0xcf, 0xcf, 0xdb, 0xd4, 0x40, 0x0a, 0x62, 0xd6,
		0x02, 0x96, 0x07, 0x2b, 0x4a, 0xba, 0xe7, 0x98, 0xb5, 0xed, 0xcb, 0x27, 0x1a, 0xc5, 0x81, 0x38,
		0x66, 0x6d, 0x28, 0x8e, 0x64, 0x85, 0xa1, 0x74, 0x8d, 0x4b, 0x97, 0x01, 0x48, 0x9e, 0x70, 0x91,
		0x65, 0x0c, 0x92, 0x27, 0x5b, 0x84, 0x49, 0x83, 0xe4, 0xe5, 0x71, 0x81, 0x6a, 0xe1, 0xa5, 0x10,
		0x91, 0xbf, 0x79, 0xae, 0x31, 0xc3, 0xf1, 0xe7, 0x37, 0xcf, 0x8d, 0xc4, 0x62, 0x67, 0x76, 0xcf,
		0x58, 0x91, 0x84, 0xe7, 0x86, 0x35, 0x83, 0xa9, 0xb0, 0x82, 0xa5, 0x9f, 0xa6, 0x2e, 0x16, 0x26,
		0xaa, 0x61, 0x8a, 0x0f, 0x0a, 0xe5, 0x3a, 0x1f, 0x4d, 0x0c, 0x33, 0xce, 0x43, 0x18, 0xf3, 0x7d,
		0x4d, 0x35, 0x45, 0x59, 0x35, 0xf2, 0xc5, 0x62, 0x69, 0x7e, 0xd4, 0xe4, 0x01, 0xf7, 0xae, 0xf9,
		0x8e, 0xe7, 0x44, 0x75, 0xc0, 0xf5, 0x27, 0xba, 0x2e, 0xa9, 0x66, 0x9e, 0xff, 0xe3, 0x9d, 0x35,
		0x09, 0xef, 0x78, 0x4e, 0xd3, 0xef, 0xd5, 0x7b, 0x73, 0x23, 0x61, 0xd1, 0x97, 0xb0, 0xf6, 0x8e,
		0xf2, 0xd8, 0xb6, 0x64, 0xe6, 0x26, 0x2f, 0x0e, 0xe3, 0x64, 0x38, 0x50, 0xb6, 0x90, 0x9d, 0x03,
		0x65, 0x21, 0x32, 0xd3, 0x23, 0x32, 0x27, 0xaa, 0xac, 0xa9, 0x59, 0x3b, 0x3c, 0xd6, 0x45, 0x11,
		0xc6, 0x38, 0x41, 0x16, 0x27, 0xc8, 0xfa, 0x2c, 0x0b, 0x1c, 0x23, 0x8b, 0x63, 0x64, 0x71, 0x8c,
		0xac, 0xdf, 0x38, 0xb2, 0x9d, 0xce, 0x97, 0x95, 0x93, 0xf9, 0xa0, 0xb7, 0xa4, 0x47, 0x6f, 0x51,
		0x24, 0x71, 0xa8, 0x4b, 0x43, 0x16, 0xcd, 0xe5, 0x88, 0xae, 0x44, 0xad, 0xe3, 0x2f, 0x19, 0x6b,
		0xba, 0xd9, 0x74, 0x04, 0x88, 0xf5, 0xd1, 0xf9, 0x7e, 0x73, 0xdd, 0xe9, 0x2e, 0x3e, 0xd9, 0xb8,
		0xa9, 0xf3, 0xd5, 0xde, 0x11, 0x6f, 0xd8, 0x6c, 0x9c, 0x59, 0x77, 0xdc, 0x1f, 0x5c, 0xb1, 0x58,
		0x2a, 0x16, 0x4b, 0x0b, 0x94, 0xd9, 0x1a, 0xa4, 0x3b, 0x6b, 0x7c, 0xfe, 0x98, 0xdf, 0xd5, 0x2b,
		0x59, 0xdf, 0x59, 0x98, 0x7f, 0xae, 0xad, 0xeb, 0x9a, 0x7e, 0x29, 0x19, 0x86, 0xf8, 0x28, 0xb1,
		0xd7, 0x57, 0x99, 0xbd, 0xf8, 0xe5, 0xc4, 0x30, 0xb9, 0xbe, 0xa6, 0x0e, 0x64, 0x53, 0xd6, 0x54,
		0x4e, 0xd5, 0x4c, 0xce, 0x10, 0x4d, 0xd9, 0x18, 0xca, 0xd2, 0xe0, 0x80, 0xeb, 0xea, 0xbf, 0x38,
		0x71, 0x30, 0x90, 0xd5, 0x47, 0xce, 0x9a, 0xee, 0x26, 0xf7, 0x32, 0x3d, 0xe0, 0xda, 0x3f, 0xc5,
		0xd1, 0x58, 0x91, 0x9a, 0xdc, 0xbb, 0xb6, 0xf9, 0x24, 0xe9, 0xaa, 0x64, 0x96, 0xdf, 0x59, 0xbf,
		0xb0, 0x4a, 0x32, 0x46, 0x9e, 0xb2, 0x89, 0xbf, 0x48, 0xd6, 0xf8, 0x14, 0x46, 0xee, 0x00, 0x1d,
		0xb0, 0xb7, 0x19, 0x96, 0xe5, 0x6c, 0x64, 0x3f, 0x51, 0x8e, 0x39, 0xd3, 0x1b, 0x4d, 0xdf, 0x64,
		0x1d, 0x35, 0xa3, 0xaf, 0x8d, 0x19, 0x44, 0xbd, 0x43, 0x06, 0x59, 0x0f, 0x59, 0x1f, 0xa3, 0xac,
		0x97, 0xd4, 0xc9, 0x48, 0xd2, 0x9d, 0xd8, 0x86, 0xac, 0x02, 0xfb, 0x8f, 0x8a, 0xf6, 0x20, 0x2a,
		0xcc, 0xd0, 0xbe, 0xa2, 0xf5, 0x45, 0x25, 0xb1, 0xd8, 0xbe, 0xdb, 0x39, 0x36, 0x74, 0xdf, 0xe9,
		0xda, 0xde, 0xe1, 0xfd, 0x78, 0x0e, 0x9a, 0x75, 0x0f, 0x99, 0x2d, 0xe0, 0x90, 0xd9, 0x0d, 0xcc,
		0x2c, 0x8a, 0x88, 0xb7, 0x79, 0x78, 0xd1, 0xda, 0xf7, 0xb9, 0x9a, 0x5a, 0x62, 0x0b, 0x8b, 0xe0,
		0x36, 0x44, 0x4c, 0x9d, 0xcf, 0x9e, 0x20, 0xac, 0x7c, 0xf5, 0x3c, 0x66, 0xc3, 0x03, 0x77, 0x70,
		0xc8, 0xc2, 0xb2, 0x32, 0xce, 0x12, 0x2a, 0x82, 0x08, 0x11, 0x44, 0x88, 0xcc, 0xd9, 0xb3, 0x36,
		0x7e, 0x10, 0xfb, 0xdf, 0x05, 0xa7, 0xbc, 0x24, 0x4b, 0x7d, 0xf8, 0xe5, 0x06, 0xa0, 0x5c, 0x42,
		0xb9, 0x8c, 0x13, 0x48, 0x62, 0x5a, 0x7e, 0x5c, 0xec, 0x67, 0x1e, 0x0d, 0x74, 0x6d, 0xfc, 0x3a,
		0xd4, 0xf4, 0x1f, 0xa2, 0x3e, 0x48, 0xe6, 0x51, 0x67, 0xa3, 0xb1, 0x62, 0xd0, 0x6f, 0x7f, 0x9b,
		0x0a, 0x7b, 0x1e, 0x7b, 0x1e, 0x06, 0x65, 0xa4, 0x06, 0xa5, 0xa4, 0xda, 0x40, 0x31, 0xab, 0x41,
		0x39, 0x90, 0x0d, 0x9b, 0x3e, 0xa9, 0x26, 0xe5, 0xec, 0xfd, 0xd8, 0xb2, 0x25, 0xdd, 0xc1, 0x69,
		0x72, 0xe5, 0xa4, 0x1b, 0x95, 0x70, 0xda, 0x81, 0xef, 0x66, 0x47, 0xd7, 0xca, 0x8a, 0xd3, 0x2e,
		0xa2, 0x7d, 0x6b, 0x0a, 0xff, 0x68, 0x2a, 0xd3, 0xde, 0x75, 0x29, 0x09, 0x67, 0xec, 0xb3, 0x34,
		0x14, 0x27, 0x0a, 0x9d, 0x0f, 0x30, 0x57, 0x26, 0x1b, 0x8b, 0x1e, 0x78, 0x08, 0x78, 0x48, 0x8c,
		0x3c, 0x04, 0xa7, 0x7a, 0xcd, 0x88, 0x71, 0xa0, 0x4a, 0xe8, 0xa1, 0x3b, 0xc4, 0x61, 0x2a, 0x09,
		0x00, 0x0e, 0x9e, 0xf5, 0xa1, 0xc0, 0xa6, 0xc4, 0xce, 0x29, 0x21, 0x84, 0x20, 0x84, 0x32, 0xac,
		0xc8, 0x3e, 0xeb, 0x43, 0x57, 0x8f, 0x7d, 0xd6, 0x87, 0xf6, 0xb7, 0x6f, 0x9d, 0xb3, 0xd9, 0xbf,
		0x8e, 0x0a, 0x6b, 0x7d, 0x89, 0x54, 0x83, 0x8d, 0xca, 0x9d, 0x09, 0x27, 0xe6, 0xda, 0xfa, 0x8f,
		0xdf, 0x89, 0x19, 0x97, 0xef, 0x32, 0x94, 0xcb, 0x32, 0xbe, 0xb2, 0x1e, 0x04, 0x83, 0x47, 0x59,
		0xde, 0x23, 0x78, 0x94, 0xf6, 0x58, 0xe6, 0x63, 0x63, 0x77, 0x09, 0x0b, 0x7e, 0x6c, 0xea, 0x1c,
		0x79, 0xe9, 0x8f, 0xef, 0x83, 0xc9, 0x68, 0x1c, 0x54, 0xf6, 0xc3, 0xb9, 0x29, 0x86, 0x92, 0x1f,
		0x7e, 0x0f, 0xe2, 0xf6, 0x5f, 0xf3, 0xc3, 0x79, 0xad, 0xa8, 0x8a, 0x7e, 0xfc, 0xf5, 0xf9, 0xeb,
		0xe5, 0x4d, 0x70, 0xc1, 0x0f, 0xe7, 0xb6, 0x04, 0x14, 0xfb, 0xd8, 0x34, 0x29, 0xb4, 0x0a, 0x4f,
		0xcc, 0xd5, 0x3e, 0x36, 0x4c, 0x1a, 0x1b, 0x53, 0x0b, 0x2c, 0xf7, 0xd1, 0x9f, 0x8d, 0x38, 0x61,
		0xc8, 0x86, 0x7b, 0x7f, 0x0a, 0x42, 0x35, 0x82, 0xa6, 0x9f, 0x55, 0xef, 0xdd, 0x73, 0xac, 0x46,
		0xc0, 0xf2, 0x88, 0x46, 0xdb, 0x22, 0x3f, 0x82, 0xca, 0xf6, 0x7b, 0x0c, 0x18, 0x0e, 0xa0, 0x72,
		0x09, 0x33, 0x60, 0x67, 0x91, 0x2e, 0xb4, 0x8c, 0x19, 0x5a, 0x84, 0x0b, 0x31, 0x69, 0x96, 0xd6,
		0x83, 0xa6, 0x29, 0x92, 0xc8, 0xe4, 0xa6, 0xad, 0xc4, 0x19, 0xfb, 0x20, 0x8d, 0x34, 0x9d, 0xa1,
		0x4e, 0x8e, 0x4b, 0x87, 0x6d, 0x85, 0x6d, 0x15, 0xeb, 0xb6, 0x32, 0x9c, 0xf0, 0x82, 0xa4, 0x06,
		0x3b, 0xe5, 0xdd, 0xd4, 0xe5, 0xde, 0x87, 0xbb, 0xcb, 0x2f, 0x3d, 0xfe, 0x63, 0xbe, 0xb0, 0xf4,
		0x95, 0x6f, 0xf2, 0x1f, 0x17, 0xdf, 0x0f, 0x3e, 0xf2, 0x34, 0xf9, 0xba, 0xb1, 0xe6, 0xd3, 0x4e,
		0x46, 0x82, 0xb5, 0x40, 0x18, 0xe2, 0xa2, 0x16, 0xa4, 0x60, 0x0e, 0x60, 0x0e, 0xb1, 0x32, 0x07,
		0xb8, 0xd8, 0x66, 0xc4, 0x33, 0x3f, 0x51, 0x05, 0x2e, 0x36, 0xd6, 0xa1, 0x3b, 0x81, 0x8b, 0x6d,
		0xd7, 0x82, 0x68, 0xff, 0x60, 0xb4, 0xcd, 0xe8, 0x96, 0x3e, 0xdb, 0xb0, 0x52, 0x89, 0x08, 0x7e,
		0xd8, 0x84, 0x3a, 0xfe, 0x65, 0x35, 0x24, 0x78, 0x3e, 0xda, 0x6d, 0x0a, 0xae, 0xe0, 0x4a, 0x3e,
		0xc8, 0xbc, 0x61, 0x50, 0x28, 0x81, 0x65, 0xff, 0x51, 0xd8, 0x23, 0x98, 0xbc, 0xd6, 0x2d, 0x42,
		0x10, 0x79, 0xb5, 0x23, 0x14, 0xe0, 0xf1, 0xe4, 0xc1, 0xce, 0xf2, 0x96, 0x0c, 0x61, 0x24, 0x1a,
		0xa6, 0xa4, 0x07, 0x02, 0xc9, 0x6b, 0x04, 0x71, 0x80, 0xca, 0x01, 0x0f, 0x4d, 0x02, 0xc0, 0xbc,
		0xf6, 0x8a, 0x91, 0x81, 0xcd, 0x5f, 0x3f, 0xb5, 0x3b, 0x57, 0xed, 0x6e, 0xfb, 0x56, 0xb8, 0x6c,
		0xdd, 0x76, 0xdb, 0x1d, 0x02, 0xe0, 0x79, 0x8d, 0x24, 0x09, 0x20, 0x34, 0xc1, 0x24, 0x26, 0x1d,
		0x90, 0x0e, 0x9e, 0xe4, 0x1d, 0x81, 0xd3, 0xb7, 0xed, 0xce, 0xb7, 0x2d, 0x33, 0xbf, 0x36, 0xd8,
		0xee, 0xfd, 0x69, 0x00, 0xa7, 0x29, 0x96, 0x45, 0x5a, 0x81, 0x6a, 0xf2, 0x65, 0x13, 0x33, 0x68,
		0xbd, 0x08, 0xf5, 0xa7, 0x34, 0xa1, 0x67, 0x84, 0xbb, 0x8c, 0x92, 0xb5, 0x55, 0xca, 0xb7, 0x13,
		0x29, 0xcb, 0xb2, 0x11, 0xb2, 0x66, 0xd4, 0xd3, 0x6f, 0x94, 0x84, 0x82, 0xea, 0x82, 0xf9, 0x6b,
		0x2c, 0x25, 0x16, 0x03, 0xb4, 0x77, 0xd6, 0xab, 0x35, 0x59, 0xaf, 0x67, 0xf6, 0xc7, 0xae, 0x3e,
		0x91, 0x92, 0x09, 0xf3, 0xc9, 0xaa, 0x21, 0xf5, 0x27, 0x3a, 0x03, 0x8b, 0x9a, 0x53, 0xee, 0x92,
		0x47, 0x99, 0xc4, 0x03, 0x07, 0x16, 0x05, 0x16, 0x05, 0x16, 0x95, 0x49, 0x16, 0x35, 0x66, 0x29,
		0x4a, 0x9e, 0x03, 0x3f, 0x00, 0x3f, 0x48, 0x04, 0x3f, 0x78, 0xd2, 0x0c, 0x33, 0x6b, 0x65, 0xca,
		0xe5, 0x71, 0x41, 0x1c, 0x0c, 0x74, 0xc9, 0x30, 0xc2, 0x54, 0xa2, 0x66, 0x39, 0xb5, 0x92, 0xa9,
		0xa7, 0xec, 0x3d, 0xf6, 0xe9, 0xf9, 0x73, 0x2d, 0x44, 0xdf, 0xc3, 0x70, 0xfb, 0xc8, 0xb8, 0xff,
		0x5a, 0x43, 0x71, 0x16, 0x6d, 0xcf, 0xff, 0x7e, 0x77, 0x7f, 0x3f, 0x7e, 0xb9, 0x9a, 0x5a, 0x7f,
		0x2f, 0xa6, 0xbd, 0x0f, 0xfc, 0xc7, 0x1c, 0xf3, 0xdb, 0xf7, 0xd8, 0xea, 0x66, 0x1e, 0xec, 0x71,
		0xf5, 0x34, 0x32, 0xb8, 0x7a, 0x52, 0x57, 0xdb, 0xdd, 0x67, 0x0d, 0x1e, 0x84, 0xde, 0x42, 0x11,
		0xd6, 0x71, 0xff, 0xbd, 0xb8, 0x8f, 0x6d, 0x91, 0x99, 0xe3, 0x12, 0x06, 0xda, 0x48, 0x94, 0xd5,
		0x02, 0x45, 0x7e, 0x5d, 0x54, 0xbb, 0x2b, 0x77, 0x21, 0xa9, 0x8f, 0xb6, 0xd3, 0x29, 0x76, 0x09,
		0x15, 0x26, 0x5c, 0x60, 0xde, 0x48, 0xc8, 0xb0, 0x81, 0x79, 0x3b, 0x51, 0xf9, 0xc0, 0x17, 0x53,
		0x1b, 0xd6, 0x17, 0x1e, 0x92, 0xf9, 0x73, 0x61, 0xc3, 0x0a, 0xd6, 0x86, 0xb8, 0x5a, 0x3f, 0xcc,
		0xee, 0x20, 0xc7, 0xc5, 0x80, 0xf6, 0x73, 0x96, 0x49, 0xfe, 0x4e, 0x2c, 0xfc, 0xd3, 0x2a, 0xfc,
		0xa7, 0x5c, 0x38, 0x11, 0x7a, 0x9e, 0x2f, 0xf7, 0xf7, 0x05, 0xa1, 0x67, 0x49, 0xb9, 0x46, 0x65,
		0xca, 0x7f, 0x5c, 0x5c, 0xef, 0x59, 0xf2, 0xe9, 0x3d, 0x0b, 0xd5, 0x47, 0xfe, 0xf5, 0xfe, 0xbe,
		0xf8, 0x36, 0x8f, 0xf4, 0x18, 0x6b, 0xba, 0x49, 0x6f, 0xfa, 0xdb, 0x54, 0xbb, 0xc4, 0x24, 0x1b,
		0xb5, 0xda, 0x21, 0x30, 0x49, 0x60, 0x10, 0x69, 0xc2, 0x20, 0xac, 0x4d, 0x51, 0x50, 0x27, 0xa3,
		0x07, 0xba, 0xf9, 0x73, 0x17, 0x66, 0x03, 0x05, 0x48, 0x76, 0x24, 0x79, 0x53, 0x1c, 0x1d, 0xd9,
		0xa8, 0xd7, 0x0f, 0xeb, 0x88, 0x90, 0xdc, 0xb5, 0x9c, 0x4c, 0x40, 0x84, 0xe4, 0x2a, 0xfb, 0xdb,
		0x78, 0x7d, 0x2d, 0x2e, 0xaa, 0x44, 0x14, 0x27, 0xc3, 0x6d, 0x0a, 0xbb, 0x9b, 0x3f, 0xe0, 0xd2,
		0x6e, 0x5f, 0xf0, 0xbf, 0xba, 0xf6, 0x54, 0xc1, 0x7d, 0x6a, 0x0a, 0xe2, 0x2c, 0xd9, 0x87, 0x96,
		0x36, 0x16, 0x93, 0x71, 0x2c, 0xf7, 0x19, 0xad, 0x49, 0x3a, 0x38, 0xa4, 0x51, 0x9c, 0x44, 0x43,
		0x40, 0x1e, 0xdb, 0xa9, 0x28, 0x83, 0xc0, 0xba, 0x00, 0xf6, 0x3d, 0x31, 0x44, 0x70, 0x1a, 0x3e,
		0x0f, 0xe2, 0xf6, 0x1f, 0xb5, 0xe9, 0xbc, 0x56, 0x54, 0x91, 0x9a, 0x17, 0x17, 0x9f, 0x09, 0xaa,
		0x02, 0xd8, 0x77, 0x25, 0x20, 0x1e, 0x73, 0xd3, 0x94, 0xd0, 0x2a, 0xc7, 0x31, 0xc7, 0x60, 0x6e,
		0x98, 0x32, 0x36, 0xe6, 0x18, 0x18, 0x77, 0xf9, 0xe5, 0xe2, 0xfa, 0x53, 0xeb, 0x82, 0x3c, 0xee,
		0xd2, 0xbd, 0x3f, 0x05, 0x71, 0x97, 0x41, 0xd3, 0xcf, 0x6a, 0x23, 0xed, 0x39, 0xd6, 0x32, 0x60,
		0x79, 0x44, 0xa3, 0xb6, 0x24, 0xae, 0x28, 0x00, 0x62, 0x97, 0x22, 0x5b, 0xef, 0x19, 0xc3, 0x06,
		0x08, 0xf7, 0x43, 0xd2, 0xf0, 0x80, 0x94, 0xd4, 0x26, 0x78, 0x92, 0x14, 0x45, 0x13, 0x4c, 0x99,
		0xa5, 0xc0, 0xa2, 0x87, 0x76, 0x97, 0xbb, 0xfc, 0xb0, 0x8c, 0x3d, 0x8e, 0x3d, 0x9e, 0xc4, 0x3d,
		0x8e, 0x5c, 0xe8, 0x55, 0xc8, 0xaa, 0x0e, 0xb4, 0x8f, 0x75, 0xe8, 0xaa, 0xf5, 0x1a, 0xb0, 0xbe,
		0x5d, 0x63, 0x7d, 0x24, 0xd5, 0x7a, 0xb4, 0x01, 0x83, 0x2c, 0xb4, 0xa9, 0x20, 0x80, 0x20, 0x80,
		0x62, 0x15, 0x40, 0x6f, 0xe1, 0xac, 0xa2, 0x4e, 0xfb, 0xb4, 0x7d, 0xfe, 0xad, 0xcd, 0x7c, 0x58,
		0x51, 0xb7, 0xd3, 0xba, 0xba, 0xbd, 0x3c, 0xef, 0x26, 0xf6, 0xb4, 0xa2, 0x59, 0x07, 0xd9, 0x4e,
		0xc0, 0x9d, 0x77, 0x2f, 0x05, 0x87, 0xe0, 0x92, 0x70, 0xdf, 0x89, 0x62, 0xca, 0x63, 0x45, 0x96,
		0x74, 0x06, 0x1e, 0xbc, 0xa0, 0xdd, 0xa5, 0x3d, 0x52, 0x83, 0x39, 0x02, 0x69, 0x00, 0x73, 0x24,
		0x0d, 0xe6, 0x08, 0x4a, 0x33, 0xb1, 0x0f, 0x5d, 0x19, 0xd6, 0x48, 0x02, 0xac, 0x11, 0x63, 0x32,
		0x1e, 0x0b, 0xa3, 0xc7, 0x91, 0x29, 0xb8, 0x39, 0x0d, 0x82, 0xa9, 0x3c, 0xd3, 0x8b, 0x46, 0xff,
		0x66, 0x50, 0xfb, 0x00, 0x92, 0x12, 0xe0, 0x3c, 0x9d, 0xcd, 0x54, 0x89, 0x7b, 0xf3, 0x1b, 0xbf,
		0x0c, 0x53, 0x1a, 0x09, 0x7d, 0x71, 0x2c, 0x3e, 0xc8, 0x8a, 0x6c, 0xca, 0x52, 0x18, 0x1e, 0xb0,
		0xa9, 0x35, 0xb0, 0x02, 0xb0, 0x02, 0xb0, 0x82, 0x04, 0xb3, 0x02, 0x67, 0xdf, 0x0e, 0x24, 0xa3,
		0xaf, 0xcb, 0x63, 0xe2, 0x78, 0xc3, 0xe5, 0x85, 0xb9, 0xde, 0x06, 0xb6, 0x1b, 0xb6, 0x5b, 0xac,
		0xdb, 0x2d, 0x44, 0x6d, 0xf1, 0xf8, 0x77, 0x1b, 0xdb, 0xb9, 0x83, 0x5e, 0x62, 0xec, 0x2f, 0xec,
		0xaf, 0xb7, 0xb6, 0xbf, 0xf6, 0x1f, 0x4f, 0x6f, 0x4d, 0x9d, 0xf7, 0xe3, 0xc5, 0xc5, 0xe7, 0x9b,
		0x12, 0x51, 0x60, 0x23, 0xb7, 0x21, 0xb2, 0xf9, 0x42, 0x19, 0xb8, 0xe5, 0x69, 0xed, 0x4f, 0x56,
		0x83, 0x82, 0xdb, 0x60, 0xf2, 0x63, 0xe0, 0xfd, 0x86, 0x83, 0x32, 0xb8, 0xdd, 0xa7, 0xff, 0xc4,
		0x71, 0xeb, 0x07, 0xfe, 0x71, 0xc6, 0xc2, 0xcd, 0x75, 0xa7, 0x4b, 0x16, 0x6c, 0xec, 0xdc, 0x8a,
		0x88, 0xe3, 0x74, 0x44, 0x1c, 0xcf, 0x67, 0xcc, 0x39, 0xf0, 0x91, 0x38, 0xf2, 0x78, 0x85, 0x0e,
		0x11, 0xc8, 0x88, 0x40, 0x46, 0x04, 0x32, 0x54, 0x41, 0xa8, 0x82, 0xd9, 0x46, 0x36, 0xe4, 0x21,
		0x9b, 0x99, 0xe5, 0xd2, 0x61, 0x5b, 0x61, 0x5b, 0xc5, 0xba, 0xad, 0xe2, 0x3e, 0xde, 0x7d, 0xac,
		0x9b, 0xee, 0xf1, 0xee, 0x63, 0x4d, 0x37, 0xed, 0xaf, 0x96, 0x92, 0x34, 0xff, 0xe0, 0x9c, 0xf0,
		0x6e, 0x7d, 0x8b, 0xf4, 0x84, 0x77, 0x44, 0x4a, 0x62, 0xd7, 0x66, 0x68, 0xd7, 0x22, 0x52, 0x72,
		0x2b, 0x3d, 0x22, 0x25, 0x43, 0xaf, 0x61, 0x2e, 0xca, 0x48, 0xc9, 0x50, 0xa6, 0xd5, 0x5f, 0xd2,
		0x2f, 0x62, 0x05, 0x29, 0x77, 0x21, 0x1b, 0x66, 0xcb, 0x34, 0x09, 0x8d, 0xb1, 0x4b, 0x59, 0x6d,
		0x2b, 0x92, 0xc5, 0x0b, 0x08, 0x23, 0x7b, 0x72, 0x97, 0xe2, 0x4f, 0x0f, 0x45, 0xe5, 0xb8, 0x56,
		0x6b, 0x1c, 0xd5, 0x6a, 0xe5, 0xa3, 0xc3, 0xa3, 0xf2, 0x49, 0xbd, 0x5e, 0x69, 0x54, 0x08, 0xa2,
		0xcf, 0x72, 0xd7, 0xfa, 0x40, 0xd2, 0xa5, 0xc1, 0x27, 0xab, 0x5f, 0xea, 0x44, 0x51, 0x92, 0x09,
		0x31, 0xda, 0xe0, 0x45, 0x89, 0x0a, 0xc6, 0xa0, 0xc1, 0x1b, 0x9d, 0x36, 0x97, 0x5b, 0x4f, 0x27,
		0xf8, 0xb8, 0x0d, 0xcf, 0xa3, 0x1d, 0x91, 0x3d, 0x96, 0xcf, 0x58, 0xe9, 0x1a, 0x61, 0x91, 0x8c,
		0xe5, 0x8e, 0x50, 0x14, 0xc3, 0xd0, 0xb4, 0xf1, 0x83, 0xd8, 0xff, 0x5e, 0x90, 0x55, 0x53, 0xd2,
		0x87, 0xa2, 0x8f, 0x2a, 0xb1, 0x5a, 0x1a, 0x63, 0x9d, 0x22, 0x86, 0x42, 0x19, 0x8a, 0x26, 0xab,
		0xe6, 0x30, 0x79, 0x95, 0x32, 0xdc, 0xf7, 0x8a, 0xac, 0x54, 0xc6, 0xf5, 0xf5, 0xcd, 0xa7, 0xd6,
		0xe9, 0x5f, 0xc2, 0xf9, 0x55, 0xb7, 0xdd, 0x39, 0x6b, 0x9d, 0xb6, 0x09, 0xb0, 0xec, 0x75, 0x9a,
		0x04, 0x80, 0xda, 0x1b, 0x27, 0x2c, 0xe1, 0xa8, 0xf6, 0xa6, 0x09, 0xdd, 0x15, 0xac, 0xbd, 0x36,
		0x79, 0xc2, 0xf9, 0xcd, 0x4d, 0xa7, 0x7d, 0x76, 0xfe, 0x37, 0x2d, 0xd0, 0x1d, 0xd4, 0x52, 0x0a,
		0xa0, 0xef, 0xc0, 0x45, 0x93, 0x52, 0xec, 0x3b, 0x68, 0x51, 0xc5, 0x0c, 0x7e, 0x0f, 0xc5, 0x91,
		0xac, 0xfc, 0xa2, 0x37, 0xb2, 0x5d, 0xba, 0x0c, 0x98, 0xd9, 0xc4, 0x0b, 0x2d, 0x63, 0x76, 0x36,
		0xe9, 0x42, 0x4c, 0x9a, 0xa1, 0x2d, 0x8f, 0x0b, 0x54, 0x8b, 0x2f, 0x7d, 0x66, 0xf6, 0xf9, 0xcd,
		0x73, 0x8d, 0xd9, 0xc6, 0x3e, 0xbf, 0x79, 0x6e, 0x24, 0xd6, 0xbe, 0xb6, 0x7b, 0xc6, 0x66, 0x5c,
		0xdb, 0xfd, 0xda, 0xbb, 0x61, 0x4d, 0xb8, 0xba, 0xa5, 0x9f, 0xa6, 0x2e, 0x16, 0x26, 0xaa, 0x61,
		0x52, 0x9d, 0x1d, 0xe9, 0x80, 0x9e, 0x13, 0xc3, 0x8c, 0xf3, 0x1c, 0x98, 0x7c, 0x5f, 0x53, 0x4d,
		0x51, 0x56, 0x8d, 0x7c, 0xb1, 0x58, 0x92, 0xc7, 0x05, 0x87, 0x35, 0x1d, 0x70, 0xef, 0x9a, 0xef,
		0x78, 0x4e, 0x54, 0x07, 0x5c, 0x7f, 0xa2, 0xeb, 0x92, 0x6a, 0xe6, 0xf9, 0x3f, 0xde, 0x59, 0x93,
		0xf0, 0x8e, 0xe7, 0x34, 0xfd, 0x5e, 0xdd, 0x48, 0x56, 0xf4, 0x25, 0xab, 0xbd, 0xe3, 0x73, 0x19,
		0xc8, 0x96, 0x99, 0x77, 0x94, 0xe5, 0x3c, 0xab, 0x02, 0x9d, 0xba, 0x01, 0xa1, 0x09, 0xa1, 0x19,
		0x95, 0xd0, 0x9c, 0xa8, 0x8c, 0xb8, 0x74, 0x92, 0x4f, 0xb0, 0x72, 0x40, 0x08, 0x79, 0x5c, 0x2b,
		0x30, 0xad, 0x0c, 0x2e, 0xec, 0x39, 0x21, 0x11, 0x9c, 0x42, 0x10, 0xdf, 0x99, 0x4d, 0x25, 0xf7,
		0x61, 0xfc, 0x6b, 0xfe, 0xae, 0x52, 0xa8, 0xf6, 0x66, 0x5f, 0x0e, 0xef, 0xca, 0x85, 0x6a, 0x8f,
		0xe7, 0x73, 0x99, 0x39, 0x39, 0x66, 0xb6, 0x2c, 0x1a, 0xe9, 0x5d, 0x16, 0xa9, 0x3b, 0x8c, 0xc9,
		0xbb, 0xba, 0xac, 0x7f, 0x5f, 0xaa, 0x53, 0xfe, 0x35, 0x6f, 0xad, 0xc9, 0xca, 0x7c, 0xa5, 0x55,
		0xac, 0x46, 0x8e, 0xad, 0xdb, 0x19, 0x0f, 0x6a, 0x8a, 0xf8, 0x80, 0xa6, 0x52, 0xf1, 0x03, 0xff,
		0x36, 0x4f, 0xe5, 0x60, 0x8b, 0x87, 0xc9, 0x4a, 0x34, 0x0c, 0x74, 0x97, 0x74, 0xe9, 0x2e, 0x31,
		0xc7, 0xc3, 0x14, 0x8b, 0xa5, 0x62, 0xb1, 0xe4, 0x03, 0xa1, 0xda, 0x61, 0x30, 0x71, 0x87, 0xc0,
		0x18, 0x7d, 0x6d, 0xcc, 0x92, 0x22, 0x64, 0x93, 0x61, 0xb3, 0x62, 0xb3, 0xc6, 0xbc, 0x59, 0xdf,
		0x42, 0x18, 0xcc, 0xa3, 0xa2, 0x3d, 0x88, 0x0a, 0x33, 0x42, 0xa7, 0x68, 0x7d, 0x51, 0x49, 0x2c,
		0x44, 0xe7, 0x76, 0x8e, 0x0d, 0xa4, 0x73, 0xba, 0xf6, 0x46, 0xc2, 0x5f, 0x2c, 0x51, 0xc0, 0x91,
		0xa2, 0x3a, 0x08, 0x83, 0x21, 0x10, 0x75, 0x7e, 0x21, 0x10, 0x6b, 0x21, 0x06, 0x9b, 0x7f, 0x58,
		0x97, 0xd9, 0xa5, 0x90, 0x9e, 0x50, 0x6e, 0x53, 0x88, 0x85, 0xfb, 0xf0, 0xf3, 0xd9, 0xb3, 0x85,
		0x0d, 0x97, 0xfd, 0xd4, 0x88, 0xa0, 0x57, 0x62, 0x0d, 0xb9, 0x39, 0xa0, 0x72, 0x2d, 0x87, 0xf6,
		0x28, 0xc3, 0x91, 0x0c, 0x47, 0x32, 0x6c, 0x4a, 0xa8, 0xa9, 0xa9, 0x54, 0x53, 0xd3, 0x51, 0x25,
		0x42, 0x15, 0x4d, 0xe1, 0x1f, 0x4d, 0x65, 0xda, 0x57, 0x2e, 0xe5, 0x2e, 0x73, 0x13, 0xdf, 0xd0,
		0xb1, 0x09, 0xd8, 0xdf, 0xe9, 0xda, 0xdf, 0xa8, 0x54, 0x3a, 0x23, 0xc6, 0x31, 0xa9, 0xa1, 0x87,
		0xee, 0x10, 0x85, 0x4a, 0x37, 0xb1, 0xf6, 0x18, 0x85, 0xe1, 0xb3, 0x3e, 0x64, 0xac, 0x97, 0x34,
		0xa7, 0x84, 0x20, 0x82, 0x20, 0x8a, 0x59, 0x10, 0xc5, 0x9d, 0xcc, 0xfb, 0xac, 0x0f, 0xdd, 0x64,
		0xde, 0x67, 0x7d, 0x68, 0x7f, 0xfb, 0xd6, 0x39, 0x9b, 0xfd, 0xeb, 0xb8, 0x30, 0xac, 0x2f, 0x91,
		0xba, 0x31, 0xa2, 0x02, 0xd3, 0x00, 0xa1, 0xa5, 0x04, 0x42, 0x4b, 0x0e, 0x72, 0x96, 0x96, 0x1c,
		0xb5, 0x50, 0x53, 0x40, 0x9b, 0xc8, 0xc6, 0x3e, 0xc4, 0xfb, 0xcc, 0x75, 0x23, 0x1f, 0x22, 0xd2,
		0x3c, 0x38, 0xc2, 0x71, 0xa0, 0xc9, 0x90, 0x33, 0x0c, 0x45, 0x32, 0x8c, 0x82, 0xa9, 0x8b, 0xc3,
		0xa1, 0xdc, 0x2f, 0x8c, 0xe7, 0xa1, 0x3e, 0x01, 0x79, 0x72, 0x1b, 0xe8, 0x62, 0xc9, 0x96, 0x23,
		0x7a, 0x36, 0x97, 0x84, 0xfc, 0xb9, 0x0d, 0x6f, 0x1a, 0x5d, 0x46, 0xdd, 0xed, 0xed, 0x45, 0xfb,
		0xf6, 0x56, 0xe8, 0x76, 0x5a, 0x67, 0x67, 0xe7, 0xa7, 0xc2, 0x4d, 0xab, 0xdb, 0x6d, 0x77, 0xae,
		0x48, 0xf2, 0xea, 0x36, 0x50, 0x26, 0x22, 0xbb, 0x8e, 0x78, 0x82, 0x69, 0x75, 0xc2, 0xd8, 0xf3,
		0xed, 0x48, 0x17, 0x00, 0x1b, 0x0b, 0x27, 0xc8, 0xc0, 0xf3, 0x9f, 0x66, 0x6a, 0x67, 0xc9, 0xb6,
		0x66, 0x52, 0xe1, 0x32, 0xa1, 0x5e, 0x52, 0xa9, 0x75, 0xa2, 0xd0, 0x2e, 0xb9, 0x98, 0xdd, 0x2a,
		0x23, 0x73, 0xc2, 0x50, 0x01, 0xc7, 0x9c, 0x64, 0xc3, 0xd6, 0x65, 0x5e, 0x86, 0x99, 0xb3, 0x7e,
		0x59, 0x97, 0xe9, 0x6e, 0xec, 0xe1, 0x4b, 0x51, 0x1d, 0x88, 0xa6, 0xa6, 0xff, 0x22, 0x3f, 0x02,
		0x29, 0x24, 0x98, 0x5b, 0x69, 0x30, 0x98, 0xd0, 0x0d, 0x9c, 0x3b, 0x05, 0x34, 0x77, 0x75, 0xe8,
		0x4e, 0xaa, 0x95, 0x06, 0x00, 0xdd, 0x04, 0x00, 0xba, 0x6f, 0x3d, 0x62, 0x00, 0xc2, 0x2d, 0x99,
		0xc2, 0x6d, 0x2f, 0x51, 0x05, 0x14, 0x34, 0x17, 0x92, 0xfa, 0x68, 0x43, 0x27, 0x10, 0x55, 0x19,
		0x17, 0x55, 0x87, 0x55, 0x08, 0xaa, 0x4d, 0x82, 0x8a, 0xce, 0x39, 0xc2, 0x94, 0x90, 0x97, 0xbb,
		0x13, 0x0b, 0xff, 0xb4, 0x0a, 0xff, 0xb1, 0x13, 0xda, 0x2a, 0xd3, 0xfc, 0x5d, 0x61, 0xfe, 0x5d,
		0xe8, 0xbd, 0x94, 0x0f, 0x0e, 0x2b, 0x53, 0x8a, 0x04, 0xb2, 0x58, 0x0f, 0x75, 0x1c, 0x89, 0x8a,
		0x22, 0x8c, 0xc5, 0xfe, 0x77, 0xc9, 0x14, 0xc6, 0x92, 0xde, 0x97, 0x54, 0x53, 0x7c, 0x64, 0xc9,
		0x23, 0xd9, 0xd0, 0x10, 0x04, 0x30, 0x04, 0x70, 0x86, 0xac, 0x4b, 0x84, 0x0a, 0x21, 0x54, 0x28,
		0xa2, 0x43, 0x8d, 0x71, 0xaa, 0xf1, 0xce, 0x05, 0x20, 0xe2, 0x0d, 0x3c, 0x8d, 0x24, 0x31, 0xde,
		0xc0, 0x5f, 0x9c, 0x04, 0xfd, 0xbc, 0xc9, 0x6d, 0x52, 0x0a, 0xe3, 0x4f, 0xe1, 0x36, 0x3a, 0x87,
		0x9d, 0xb7, 0xe8, 0x3a, 0x2f, 0xe1, 0xaa, 0x88, 0xc2, 0xb6, 0xdf, 0x36, 0xbf, 0xc6, 0xd6, 0xf7,
		0x4b, 0x43, 0x74, 0x42, 0xb4, 0x13, 0x46, 0x1d, 0xaf, 0x10, 0xd9, 0x54, 0xec, 0x35, 0x7e, 0x81,
		0x69, 0x10, 0x89, 0x63, 0x19, 0x68, 0xc7, 0x88, 0x3c, 0xaa, 0x61, 0x24, 0xf6, 0x0d, 0xa9, 0x1f,
		0x14, 0xc3, 0xe0, 0xde, 0x15, 0x43, 0xc4, 0x82, 0xef, 0x93, 0xb8, 0xfd, 0xc7, 0x27, 0xb8, 0xef,
		0x15, 0x55, 0x34, 0xc2, 0x65, 0xeb, 0xf4, 0xb6, 0x7d, 0x2a, 0xdc, 0x74, 0xae, 0xcf, 0xce, 0x2f,
		0x08, 0x6a, 0xfb, 0xae, 0xdc, 0x9f, 0x80, 0xc8, 0x83, 0x8d, 0x13, 0x45, 0x6b, 0x1f, 0xc5, 0x1c,
		0x67, 0xb0, 0x69, 0x22, 0xd9, 0x58, 0x6f, 0x60, 0x54, 0xc1, 0xf2, 0xc4, 0x51, 0xc6, 0x12, 0xf8,
		0x11, 0xa7, 0x20, 0x82, 0x20, 0x70, 0x69, 0xb0, 0x9a, 0xd0, 0x7b, 0x8e, 0x17, 0x08, 0x5a, 0x3a,
		0xd1, 0xe8, 0xa8, 0xc4, 0xd1, 0x01, 0x7d, 0x79, 0xfc, 0x24, 0xe9, 0x82, 0x31, 0x91, 0x4d, 0x06,
		0x70, 0x67, 0x89, 0x7a, 0x97, 0x89, 0x62, 0x5f, 0x4e, 0x2f, 0x0b, 0xad, 0xf6, 0x6d, 0xa1, 0x52,
		0x3d, 0x7e, 0x3b, 0x29, 0x63, 0xc4, 0x5b, 0x20, 0x63, 0x68, 0x12, 0xe9, 0x16, 0x79, 0x9b, 0xce,
		0x1b, 0x66, 0x2c, 0xda, 0xb3, 0x87, 0x5e, 0x67, 0x9f, 0xab, 0xf5, 0xc6, 0xfc, 0xf3, 0xdf, 0x37,
		0x57, 0x4b, 0xbf, 0x59, 0xdf, 0xab, 0xf5, 0x46, 0x32, 0xf1, 0x69, 0xe7, 0xe4, 0x4c, 0x41, 0x97,
		0xc6, 0x8a, 0xf8, 0x4b, 0x18, 0xeb, 0x9a, 0x29, 0xf5, 0x4d, 0xd6, 0x03, 0x38, 0x57, 0x9b, 0xd9,
		0x25, 0x27, 0xb3, 0x11, 0x15, 0xf0, 0x30, 0xf0, 0xb0, 0x64, 0xf2, 0x30, 0xf7, 0x44, 0x4e, 0xc1,
		0xfc, 0x45, 0x5c, 0xfd, 0x2b, 0x7e, 0x4e, 0x66, 0xef, 0xa1, 0x57, 0x6b, 0x86, 0x5e, 0xcf, 0xec,
		0x8f, 0x5d, 0xe2, 0x33, 0x6e, 0xe3, 0xe6, 0x53, 0x43, 0x51, 0x51, 0x1e, 0xc4, 0xfe, 0x77, 0xa1,
		0x2f, 0x7e, 0x67, 0x39, 0x23, 0xc1, 0x43, 0x0d, 0x6e, 0x00, 0x6e, 0x00, 0x8d, 0xc6, 0x4b, 0xe8,
		0x2d, 0x4f, 0x7b, 0x58, 0x9d, 0x2e, 0x95, 0xab, 0x6d, 0xd4, 0xa6, 0x49, 0xe7, 0x08, 0xdf, 0xd5,
		0x30, 0x1c, 0xe1, 0xbb, 0x0a, 0x8e, 0x00, 0x8e, 0x00, 0x8e, 0x90, 0x7e, 0x8e, 0xf0, 0xb6, 0xc3,
		0x58, 0xc1, 0x01, 0xc0, 0x01, 0xd6, 0x69, 0x10, 0xa2, 0x4a, 0xd7, 0x50, 0x8a, 0x03, 0x5e, 0xaa,
		0xc7, 0x08, 0x78, 0x49, 0x80, 0x14, 0x1a, 0x6b, 0x8a, 0xdc, 0x67, 0x38, 0xc7, 0xcf, 0xa5, 0xdb,
		0x25, 0x66, 0x66, 0x48, 0xfd, 0x89, 0x2e, 0x9b, 0xbf, 0x00, 0x9b, 0x41, 0x28, 0x42, 0x2d, 0x66,
		0x50, 0x8b, 0x65, 0xd5, 0x94, 0x1e, 0xad, 0x1d, 0x24, 0x68, 0xaa, 0xf2, 0xeb, 0x95, 0x6e, 0x3f,
		0xc5, 0xce, 0x88, 0x74, 0x79, 0x24, 0xea, 0xbf, 0xd8, 0x10, 0x33, 0x2f, 0x31, 0xf8, 0x00, 0xf8,
		0x00, 0x13, 0x1f, 0x88, 0x37, 0x7c, 0x1c, 0x26, 0xf5, 0x0e, 0x79, 0x08, 0x0b, 0xc6, 0xe6, 0x25,
		0x06, 0x0f, 0x01, 0x0f, 0x01, 0x0f, 0x79, 0xab, 0x3c, 0x44, 0xb3, 0xb5, 0x24, 0x16, 0x06, 0xe2,
		0x50, 0xee, 0xd2, 0x28, 0xaa, 0xd6, 0xeb, 0xb0, 0x87, 0xc0, 0xc3, 0x92, 0x69, 0x0f, 0x21, 0x25,
		0x6e, 0x15, 0xe6, 0x42, 0x4a, 0x1c, 0xf3, 0xd0, 0x55, 0xeb, 0x75, 0x20, 0x84, 0x09, 0x10, 0x88,
		0xba, 0xf4, 0x5d, 0xfa, 0x25, 0x8c, 0x25, 0x5d, 0xd6, 0x06, 0xf4, 0x42, 0x71, 0x89, 0x1a, 0x87,
		0x4a, 0x40, 0x2c, 0xbe, 0x51, 0xb1, 0x78, 0x58, 0x65, 0x90, 0x8b, 0x47, 0x90, 0x8b, 0x90, 0x8b,
		0xab, 0x43, 0x57, 0xab, 0x9e, 0xd4, 0x4e, 0x1a, 0x47, 0xd5, 0x13, 0x88, 0xc7, 0x64, 0x88, 0x47,
		0x3b, 0x88, 0xfc, 0x87, 0xac, 0x0e, 0xb4, 0x1f, 0x2c, 0xf2, 0xd1, 0x4b, 0x0e, 0xe1, 0x04, 0xe1,
		0x04, 0xe1, 0x04, 0xe1, 0x04, 0xe1, 0xf4, 0xe6, 0x85, 0x13, 0xe1, 0xc6, 0x97, 0x7e, 0x9a, 0xba,
		0x58, 0x98, 0xa8, 0x86, 0x29, 0x3e, 0x28, 0x94, 0x2c, 0xe0, 0xc7, 0x93, 0xa4, 0xc6, 0xb1, 0x29,
		0xe7, 0x79, 0xa3, 0x13, 0x5d, 0x97, 0x54, 0x33, 0xcf, 0x97, 0x8a, 0xc5, 0x92, 0x6f, 0x0e, 0x16,
		0xf7, 0x07, 0xf7, 0xce, 0xe2, 0xc3, 0xef, 0x58, 0x0e, 0xc9, 0x66, 0x94, 0x23, 0x7e, 0xf2, 0xc4,
		0x1e, 0x19, 0xc6, 0x85, 0x17, 0x56, 0xaa, 0xf8, 0x4a, 0x17, 0x9a, 0xa1, 0x7b, 0x93, 0x6a, 0x98,
		0x21, 0xa9, 0x03, 0xc1, 0xe8, 0xcb, 0x0c, 0xa5, 0xea, 0x66, 0x94, 0xbb, 0x44, 0x27, 0x4c, 0xe2,
		0x54, 0x25, 0x00, 0x14, 0xd0, 0x01, 0xe3, 0xd6, 0x01, 0x91, 0xfe, 0x47, 0xc1, 0x8c, 0x50, 0x45,
		0xcc, 0xd3, 0x48, 0xa4, 0x55, 0xc4, 0x18, 0x74, 0x99, 0xdc, 0x68, 0x62, 0x90, 0xb3, 0x62, 0x66,
		0x17, 0x7b, 0x41, 0xb1, 0x03, 0xd3, 0xf3, 0x9e, 0x38, 0x33, 0x9e, 0xfb, 0x83, 0xdb, 0xf0, 0xe3,
		0x77, 0x95, 0xb0, 0xbc, 0x2b, 0xe1, 0xce, 0x0e, 0xfd, 0xda, 0xde, 0x84, 0xd2, 0xf5, 0xf7, 0xf6,
		0x26, 0x97, 0xa5, 0xea, 0xc5, 0xbd, 0xb3, 0xb1, 0xef, 0xf7, 0xf6, 0x4c, 0x3e, 0xf7, 0x7f, 0x7f,
		0x70, 0x4b, 0x09, 0x7b, 0x11, 0x71, 0x9e, 0xde, 0xfe, 0x4b, 0xf4, 0x39, 0x02, 0x6e, 0xf9, 0xcb,
		0x72, 0xa5, 0xa1, 0x12, 0x7d, 0xe1, 0x21, 0x6e, 0x43, 0xed, 0xb2, 0x4b, 0xbb, 0x7d, 0xc1, 0xfb,
		0x79, 0xa5, 0x71, 0xbf, 0x67, 0x25, 0xbf, 0x6c, 0x5e, 0xf0, 0x20, 0x52, 0x16, 0xc2, 0x0b, 0x1c,
		0xa8, 0x3d, 0x96, 0xb7, 0xf3, 0xe9, 0x2c, 0x61, 0xe9, 0xba, 0xf5, 0x5e, 0x51, 0x94, 0xa6, 0xeb,
		0x2b, 0xe2, 0x63, 0x60, 0x65, 0x3a, 0xfb, 0xa6, 0x18, 0x0a, 0xd3, 0x19, 0x7e, 0x4f, 0xe2, 0xf6,
		0x5f, 0x98, 0xce, 0x7d, 0xaf, 0xc8, 0x0a, 0xd3, 0x9d, 0x5e, 0xb4, 0xbe, 0x08, 0x9f, 0xaf, 0x2f,
		0x5b, 0xe7, 0x04, 0x47, 0xe3, 0x2d, 0xdd, 0x9d, 0x80, 0xa2, 0x74, 0x1b, 0x27, 0x89, 0xd6, 0x46,
		0x89, 0xb9, 0x28, 0xdd, 0xa6, 0x49, 0x64, 0x63, 0x6c, 0xc1, 0x45, 0xe9, 0x3c, 0xd3, 0x46, 0x5b,
		0x92, 0x6e, 0x8d, 0x34, 0x05, 0x05, 0xe9, 0x02, 0x97, 0x05, 0xab, 0x09, 0xbb, 0xe7, 0x82, 0x74,
		0x41, 0xcb, 0x26, 0x1a, 0x73, 0x87, 0xb8, 0x20, 0xdd, 0x40, 0x1b, 0x89, 0xb2, 0x2a, 0xc8, 0x0c,
		0x11, 0x26, 0x0b, 0xd2, 0x0c, 0x20, 0x27, 0xc4, 0xcb, 0x2d, 0x63, 0xc8, 0x09, 0xe9, 0x72, 0x4c,
		0x1a, 0x72, 0x82, 0x23, 0xe6, 0xd6, 0x5c, 0x40, 0x48, 0x8a, 0x66, 0x1e, 0xba, 0x5a, 0x19, 0x7e,
		0xb3, 0x44, 0x78, 0x13, 0xbe, 0x4b, 0xd2, 0x58, 0x54, 0xe4, 0x67, 0x49, 0xb0, 0x0f, 0x0f, 0x7f,
		0x16, 0x15, 0x7a, 0xb9, 0xe4, 0xd3, 0xc6, 0x2e, 0x3d, 0x0c, 0x95, 0xb7, 0xe3, 0x5e, 0x80, 0x90,
		0x84, 0x90, 0x84, 0x90, 0x7c, 0xab, 0x42, 0xb2, 0x81, 0x93, 0x72, 0x92, 0x20, 0x22, 0xc7, 0x92,
		0xa4, 0x0b, 0xf2, 0x98, 0x21, 0x4d, 0xce, 0x25, 0x84, 0x20, 0x82, 0x20, 0x8a, 0x59, 0x10, 0xc9,
		0xe3, 0xe7, 0x5a, 0x41, 0x1c, 0x0c, 0x74, 0xc9, 0x30, 0x12, 0xeb, 0xe7, 0xce, 0xe7, 0xef, 0xca,
		0x85, 0x93, 0xde, 0xeb, 0x5d, 0xa5, 0x70, 0xd2, 0x73, 0x3e, 0x56, 0xec, 0x7f, 0x9c, 0xcf, 0xd5,
		0xbb, 0x72, 0xa1, 0x36, 0xfb, 0x5c, 0xbf, 0x2b, 0x17, 0xea, 0x3d, 0xfe, 0xfe, 0xbe, 0xc8, 0xbf,
		0x1c, 0x4e, 0xe9, 0x09, 0xf3, 0xbf, 0xdf, 0xdd, 0xdf, 0x8f, 0x5f, 0xae, 0xa6, 0xd6, 0xdf, 0x8b,
		0x69, 0xef, 0x03, 0xff, 0x31, 0x97, 0x5c, 0x6e, 0xa3, 0xc8, 0xea, 0x77, 0x46, 0x7e, 0x63, 0x93,
		0x82, 0xe3, 0x80, 0xe3, 0xc4, 0xad, 0xfa, 0xaa, 0xb2, 0xa6, 0xb2, 0xb0, 0x9a, 0x13, 0x0a, 0x1a,
		0xf7, 0xf5, 0x62, 0x8b, 0xe3, 0x54, 0x24, 0x71, 0xa8, 0x4b, 0x43, 0x96, 0x18, 0xcd, 0x59, 0xf7,
		0x8e, 0x18, 0x68, 0x6f, 0x66, 0x9e, 0xc5, 0xb1, 0x6e, 0x36, 0x1d, 0x17, 0xde, 0x58, 0xd3, 0x4d,
		0xfb, 0xeb, 0xcd, 0x75, 0xa7, 0x3b, 0xff, 0x60, 0x3b, 0x17, 0xec, 0x6f, 0xb6, 0x43, 0xf1, 0xb7,
		0x1d, 0xaa, 0xb5, 0x29, 0x1e, 0x45, 0x45, 0x7c, 0xf4, 0x8c, 0x62, 0xff, 0x49, 0x54, 0x55, 0x49,
		0xb1, 0xaf, 0x5a, 0x63, 0x78, 0xfa, 0x67, 0xeb, 0xea, 0xaa, 0x7d, 0xb1, 0xfa, 0xdd, 0x19, 0x5a,
		0xeb, 0x22, 0xc3, 0xd0, 0x26, 0x34, 0x70, 0xd4, 0x30, 0x64, 0x4d, 0x15, 0x4c, 0x79, 0x24, 0x69,
		0x13, 0x93, 0x25, 0x7e, 0x74, 0xb9, 0x81, 0x5d, 0x82, 0x3c, 0x87, 0x65, 0xa0, 0x3c, 0x10, 0x75,
		0x40, 0x79, 0x80, 0xf2, 0x64, 0x1d, 0xe5, 0x39, 0x6c, 0xe0, 0x44, 0xe4, 0x64, 0xc8, 0x47, 0x9b,
		0xa9, 0x32, 0x21, 0x3d, 0x0b, 0x52, 0x88, 0x23, 0x88, 0x23, 0x60, 0x3d, 0xc0, 0x7a, 0xa2, 0xc9,
		0x9e, 0x20, 0x8d, 0xf8, 0x89, 0x3b, 0x85, 0x02, 0xf9, 0x12, 0x5c, 0x2e, 0xbf, 0xee, 0xf6, 0xe6,
		0xde, 0x73, 0x87, 0x3c, 0x77, 0x3f, 0x29, 0x97, 0x0f, 0xfb, 0x7f, 0x70, 0x6c, 0xe6, 0x92, 0xfd,
		0x8c, 0xb6, 0xae, 0x6b, 0x7a, 0x6b, 0x3c, 0xee, 0xfa, 0xc4, 0xf6, 0x12, 0xbf, 0xe0, 0xe2, 0xfd,
		0x66, 0x6f, 0x32, 0x9a, 0x28, 0xa6, 0x3c, 0x56, 0x64, 0x49, 0x2f, 0xc8, 0xea, 0xb3, 0xa8, 0x10,
		0x47, 0x92, 0x85, 0xe5, 0xf4, 0xab, 0xdc, 0x5e, 0xb2, 0xfa, 0x57, 0x10, 0xc7, 0xe3, 0x82, 0x49,
		0x25, 0x69, 0x22, 0x63, 0xfc, 0x6b, 0xcc, 0x9f, 0x68, 0xb0, 0x76, 0xa4, 0xe4, 0x4c, 0x69, 0x57,
		0xc6, 0xa5, 0x64, 0x18, 0xe2, 0xa3, 0xc4, 0xbe, 0x34, 0x16, 0x6b, 0x97, 0x23, 0x5a, 0xbb, 0xdc,
		0xb3, 0xad, 0xac, 0xee, 0x73, 0xb1, 0x8c, 0xdc, 0x3e, 0x27, 0x61, 0xb1, 0x30, 0x0e, 0xdf, 0xae,
		0x96, 0x4f, 0x86, 0xb2, 0x6e, 0x2c, 0x0d, 0x6c, 0xe9, 0xb3, 0x37, 0x94, 0xba, 0x44, 0x1b, 0x57,
		0xcd, 0x6d, 0x4a, 0xb8, 0xb0, 0x9a, 0x16, 0x3c, 0x1f, 0x97, 0x1a, 0x5e, 0x7f, 0x4a, 0x0a, 0x32,
		0x6d, 0xb6, 0x0e, 0x1c, 0x6d, 0x96, 0xcd, 0xb6, 0xe1, 0x21, 0xce, 0xb0, 0x39, 0xd8, 0x94, 0x37,
		0x71, 0x7e, 0xd5, 0x6d, 0x77, 0xce, 0x5a, 0xa7, 0x6d, 0xd2, 0xd4, 0x89, 0x05, 0x01, 0xb2, 0x27,
		0xd2, 0x95, 0x3d, 0x31, 0x9f, 0x39, 0xa6, 0x04, 0x8a, 0x15, 0x6a, 0xe4, 0x50, 0x20, 0x87, 0xc2,
		0xb9, 0x11, 0x39, 0x14, 0x40, 0x6a, 0xd2, 0x88, 0xd4, 0xd0, 0x3b, 0x42, 0x59, 0x1c, 0xa0, 0x73,
		0xc7, 0x67, 0xb1, 0x58, 0x72, 0xfe, 0xb7, 0x5d, 0x89, 0x2a, 0x2d, 0xf6, 0x44, 0x8c, 0x68, 0xab,
		0x3c, 0x14, 0xd8, 0xce, 0x85, 0x9c, 0x11, 0x62, 0xff, 0x62, 0xff, 0x66, 0x7b, 0xff, 0xc6, 0x17,
		0xb8, 0x10, 0xd9, 0x96, 0x36, 0x69, 0xc6, 0xd6, 0xbb, 0xa5, 0x29, 0x0a, 0xf2, 0x60, 0x4b, 0x63,
		0x4b, 0x47, 0xb6, 0xa5, 0x43, 0x1c, 0x2c, 0x93, 0x48, 0x47, 0x01, 0x47, 0x26, 0x1e, 0xdf, 0x60,
		0xcd, 0xa5, 0x9d, 0x02, 0x54, 0x73, 0x53, 0xb5, 0xc4, 0x60, 0xba, 0x52, 0xe2, 0x30, 0x8b, 0xb6,
		0x7d, 0x9f, 0x95, 0x5e, 0xb0, 0x2a, 0x08, 0xe7, 0x61, 0x1d, 0xa7, 0xf0, 0x90, 0xd5, 0xd7, 0xab,
		0xf3, 0xff, 0xf7, 0xb5, 0x2d, 0x9c, 0xdf, 0x90, 0x42, 0x56, 0x0b, 0x02, 0x40, 0x56, 0xe9, 0x82,
		0xac, 0xe6, 0x33, 0xc7, 0x04, 0x59, 0xad, 0x50, 0x03, 0xb2, 0x02, 0x64, 0x05, 0x73, 0x17, 0xba,
		0xf1, 0x9b, 0xd3, 0x8d, 0xe3, 0x08, 0x29, 0xfa, 0xa6, 0x88, 0xaa, 0x13, 0x1c, 0xf4, 0x52, 0x39,
		0x38, 0x9c, 0xbe, 0xde, 0x55, 0x0a, 0x87, 0x4e, 0x24, 0xd0, 0x8b, 0xf5, 0xad, 0xd6, 0xbb, 0x2b,
		0x5b, 0x5f, 0x8f, 0xdd, 0xe8, 0x20, 0xf7, 0x82, 0x1d, 0x38, 0x54, 0xeb, 0xf1, 0xc9, 0xcc, 0xfe,
		0x9a, 0xa8, 0xf2, 0xff, 0x26, 0x6c, 0x31, 0x88, 0x0b, 0x52, 0xb0, 0x0a, 0xb0, 0x8a, 0x98, 0x59,
		0x85, 0xa4, 0x4e, 0x46, 0x92, 0xee, 0x18, 0x04, 0x0c, 0xfc, 0xa2, 0x46, 0x13, 0x01, 0xa3, 0x4e,
		0x46, 0xf4, 0xd3, 0xdc, 0xd5, 0x6e, 0x1d, 0x6e, 0xc6, 0x14, 0x8d, 0x52, 0x76, 0xfa, 0x68, 0x07,
		0x9f, 0xed, 0x32, 0xc9, 0x2a, 0xd7, 0xd5, 0xce, 0x55, 0x93, 0xed, 0x1d, 0xdd, 0xd7, 0x6b, 0x72,
		0xe5, 0x84, 0xc7, 0x99, 0x44, 0x02, 0x78, 0x00, 0xe6, 0xd8, 0xb4, 0x0c, 0x12, 0x18, 0x2a, 0xd9,
		0xd7, 0x26, 0xaa, 0x99, 0xa7, 0xf3, 0x45, 0xf1, 0xdc, 0xff, 0xfd, 0xc1, 0x95, 0x63, 0x0f, 0x9a,
		0xb4, 0xf9, 0x2f, 0xa2, 0x23, 0x57, 0xcb, 0xfd, 0x2f, 0x8d, 0x4a, 0x66, 0xc2, 0x20, 0xed, 0x6e,
		0x71, 0xaa, 0x66, 0x72, 0x7d, 0x5b, 0xb9, 0x99, 0xe8, 0xd2, 0x00, 0x41, 0x8e, 0xde, 0x39, 0x5f,
		0x1d, 0x1c, 0x84, 0x30, 0xb2, 0x82, 0x9b, 0x73, 0x64, 0xa8, 0xc4, 0x80, 0x14, 0x51, 0x22, 0x9f,
		0x8b, 0xb6, 0x7d, 0x9f, 0x95, 0x5e, 0x84, 0x38, 0x08, 0x56, 0x65, 0x1d, 0xa7, 0x7d, 0x96, 0x0d,
		0x5f, 0xed, 0x2a, 0x69, 0xd1, 0xf0, 0x95, 0x2e, 0x51, 0x94, 0x0c, 0x7f, 0x1c, 0x99, 0x4e, 0xca,
		0xc2, 0x50, 0xf4, 0xe1, 0x5c, 0xab, 0xb5, 0xc3, 0x97, 0xef, 0x8e, 0xa1, 0x88, 0xb8, 0xf5, 0x44,
		0x59, 0x35, 0x87, 0xc9, 0x2b, 0x23, 0x3e, 0x7f, 0xb3, 0xc8, 0x0a, 0x89, 0x7f, 0xb9, 0xec, 0x52,
		0xc5, 0xc3, 0x2e, 0xdf, 0x9f, 0x00, 0xdf, 0xc2, 0x96, 0xc9, 0x4a, 0xb8, 0x77, 0x61, 0xf3, 0x64,
		0xee, 0xca, 0xbf, 0xb0, 0x34, 0x79, 0xb4, 0xee, 0x05, 0x1f, 0xe2, 0x14, 0x78, 0x17, 0x08, 0x96,
		0x47, 0x4a, 0xfd, 0x0b, 0xc1, 0xcb, 0x27, 0x66, 0x0f, 0xc3, 0x50, 0xd3, 0xfb, 0xd2, 0x40, 0xb0,
		0xf9, 0xb5, 0xae, 0x4d, 0x4c, 0xc9, 0xa0, 0xc7, 0x10, 0x7d, 0xda, 0xc8, 0xc2, 0x21, 0x6d, 0xe4,
		0x8b, 0x30, 0x63, 0x70, 0x22, 0xf9, 0x22, 0x4d, 0x1a, 0xa0, 0x98, 0xc9, 0x72, 0x52, 0x8e, 0x46,
		0x25, 0x8f, 0x0b, 0x4c, 0x4b, 0x83, 0xb5, 0x9b, 0xe1, 0xba, 0xcb, 0xde, 0xed, 0x8d, 0xdd, 0xaf,
		0xb1, 0xf7, 0x7f, 0x6d, 0x1c, 0x8e, 0x43, 0xb4, 0xc1, 0xea, 0x79, 0x5a, 0x6b, 0x28, 0xce, 0xe4,
		0xf6, 0x92, 0xfb, 0x30, 0xfe, 0x35, 0x7f, 0x57, 0x29, 0x54, 0x7b, 0xb3, 0x2f, 0x87, 0x77, 0xe5,
		0x42, 0xb5, 0xc7, 0xf3, 0x39, 0xe6, 0xae, 0xf4, 0x98, 0x28, 0xa7, 0x07, 0xfb, 0x5e, 0x4e, 0x8d,
		0xec, 0x2d, 0xa7, 0xe6, 0xab, 0x35, 0xad, 0x62, 0x61, 0xd8, 0x2a, 0x9c, 0xf5, 0x5e, 0xca, 0x07,
		0xb5, 0x29, 0xdf, 0xe4, 0xf3, 0xab, 0xd7, 0x9a, 0xfc, 0x4b, 0xf9, 0xa0, 0x3e, 0xcd, 0xe7, 0x7d,
		0x7e, 0xf9, 0xe8, 0xd7, 0x06, 0xff, 0x9a, 0xcf, 0xe7, 0xdd, 0x85, 0xb4, 0xb4, 0xb8, 0xee, 0xca,
		0x95, 0xde, 0x47, 0xfb, 0xa3, 0xf3, 0x77, 0xbe, 0x3c, 0x89, 0x6e, 0xe6, 0xf9, 0xbc, 0x77, 0x55,
		0xda, 0x1e, 0xd8, 0xea, 0x94, 0x7f, 0xcd, 0x5b, 0x6b, 0xb9, 0x32, 0x5f, 0xa1, 0x95, 0xaa, 0xed,
		0x8d, 0xe5, 0x79, 0x3e, 0xc4, 0x4c, 0xcd, 0xf6, 0xdb, 0x7f, 0x9b, 0xbd, 0x0f, 0x4d, 0xfe, 0xa5,
		0x31, 0x9d, 0x7d, 0xb6, 0xff, 0xf2, 0xaf, 0xf9, 0xe2, 0xfb, 0xfb, 0xfb, 0x62, 0xf1, 0x3d, 0xef,
		0x74, 0xd6, 0xbd, 0xef, 0xbd, 0xf3, 0xeb, 0xc7, 0x66, 0x73, 0xed, 0x12, 0x9f, 0x2f, 0x15, 0x3f,
		0xc4, 0xbf, 0x6b, 0x7e, 0xdb, 0xed, 0x73, 0xe2, 0x2b, 0xee, 0x27, 0x8f, 0x19, 0x6a, 0x8f, 0x64,
		0x42, 0x9c, 0x31, 0xd6, 0x5d, 0x81, 0x28, 0x8b, 0xa4, 0x4e, 0x4b, 0xda, 0xa5, 0x97, 0x3c, 0x7e,
		0x6e, 0x64, 0x70, 0xf5, 0xa4, 0x4e, 0x72, 0xf9, 0xac, 0xc1, 0x44, 0x49, 0xa7, 0xdf, 0x8b, 0xfb,
		0xd8, 0x16, 0xbb, 0x16, 0x4f, 0x51, 0x07, 0x5f, 0x11, 0xda, 0xa3, 0x54, 0xe1, 0x00, 0x0b, 0xe0,
		0x8e, 0x36, 0x2c, 0x60, 0x41, 0x19, 0x41, 0x78, 0xc0, 0xbc, 0x31, 0xaa, 0x30, 0x01, 0xf2, 0x91,
		0x26, 0x09, 0x4b, 0x7b, 0xfc, 0x61, 0x71, 0x2a, 0x7a, 0x3c, 0xc9, 0xa5, 0x03, 0x86, 0x04, 0x0c,
		0x69, 0x0f, 0x18, 0x12, 0x93, 0x6a, 0x9a, 0x0a, 0x20, 0x29, 0xa4, 0xea, 0x19, 0x46, 0x69, 0x08,
		0xad, 0x2c, 0xa4, 0x4f, 0xc5, 0x4c, 0xae, 0xe9, 0x15, 0x4a, 0x85, 0xdc, 0xf7, 0x2a, 0x78, 0xbb,
		0xaa, 0x62, 0x32, 0x54, 0xc4, 0x74, 0xa8, 0x6c, 0x0c, 0xf1, 0x8c, 0x73, 0x5a, 0xaa, 0xb8, 0xc6,
		0x08, 0x36, 0x64, 0xbe, 0xaf, 0xa9, 0xa6, 0x28, 0xab, 0x46, 0xbe, 0x3f, 0xd1, 0x75, 0x49, 0x35,
		0xf3, 0xfc, 0x01, 0xf7, 0xae, 0xf9, 0x8e, 0xe7, 0x44, 0x75, 0xc0, 0xcd, 0x7f, 0x2c, 0x16, 0x4b,
		0xf2, 0x58, 0x70, 0x44, 0xbb, 0xf3, 0x3b, 0xcf, 0x69, 0x3a, 0xe7, 0x4f, 0x5d, 0x0c, 0xa0, 0x2e,
		0xbe, 0xa3, 0xc5, 0x7c, 0x93, 0x59, 0x7d, 0x79, 0xde, 0x27, 0x86, 0x14, 0xa9, 0x39, 0x29, 0x14,
		0x4d, 0x28, 0x9a, 0x7b, 0x50, 0x34, 0xd9, 0xfd, 0x7a, 0xa9, 0x72, 0x5b, 0xd6, 0x22, 0xf0, 0x5b,
		0x66, 0x5e, 0xe3, 0x8c, 0xde, 0x3f, 0x97, 0x54, 0xf5, 0x33, 0x02, 0xff, 0x1b, 0x54, 0xd0, 0x24,
		0xfa, 0xd9, 0x12, 0xe1, 0x5f, 0x83, 0x76, 0xba, 0x3f, 0xed, 0xd4, 0x81, 0xed, 0x98, 0x54, 0xd3,
		0x39, 0x69, 0x56, 0xf4, 0x52, 0xb6, 0xac, 0xfd, 0xac, 0xa4, 0xec, 0x43, 0x1b, 0x45, 0x95, 0xba,
		0xcd, 0xe2, 0xd7, 0xc9, 0x63, 0xb0, 0x46, 0x6a, 0x71, 0x50, 0xa1, 0x1d, 0x3b, 0x6a, 0x9f, 0x56,
		0x38, 0xbb, 0x6e, 0x87, 0x2e, 0xdb, 0xc7, 0x16, 0xae, 0x5d, 0x71, 0x72, 0xfe, 0x66, 0x97, 0x23,
		0xad, 0x57, 0x17, 0x45, 0x92, 0xa9, 0xf5, 0x42, 0x1c, 0xa9, 0x75, 0x89, 0x92, 0x5a, 0x81, 0x0f,
		0xf7, 0x4f, 0x80, 0x59, 0x4a, 0x30, 0xf1, 0xbf, 0xb8, 0x1c, 0xfd, 0x5e, 0xa2, 0x0f, 0x86, 0xe7,
		0x36, 0x65, 0xd1, 0x3c, 0x8e, 0xcc, 0xf3, 0xd9, 0x63, 0x04, 0x9f, 0x4b, 0x2b, 0x8f, 0xf2, 0x7b,
		0x72, 0x0a, 0xd2, 0xa9, 0xa8, 0x87, 0x98, 0x36, 0xbf, 0x8a, 0x6e, 0x18, 0xf7, 0x99, 0x6e, 0x15,
		0x3c, 0x14, 0xa4, 0x09, 0x58, 0x01, 0x7d, 0xa6, 0x4c, 0xc8, 0xb2, 0x58, 0x26, 0x51, 0x2e, 0x96,
		0x7d, 0x63, 0x4c, 0x69, 0x58, 0x63, 0xdd, 0x4c, 0x66, 0x16, 0x96, 0xf5, 0x62, 0x91, 0x26, 0x61,
		0x59, 0xd2, 0x88, 0x30, 0xff, 0xca, 0xbe, 0x35, 0x21, 0xa9, 0x57, 0xfe, 0x13, 0x44, 0xab, 0x8a,
		0xed, 0x21, 0xf3, 0xca, 0x77, 0x02, 0xd9, 0x58, 0x23, 0x59, 0xe2, 0xd5, 0x5c, 0xdd, 0xa0, 0xcc,
		0xb9, 0x5a, 0xd0, 0xa5, 0x24, 0xdd, 0x6a, 0xfb, 0x92, 0x60, 0xd5, 0xd2, 0x13, 0x90, 0x6d, 0xb5,
		0x75, 0xc9, 0x44, 0xa3, 0xf7, 0x11, 0x27, 0x5b, 0x89, 0x83, 0x91, 0xac, 0x0a, 0x86, 0x29, 0x9a,
		0x13, 0x86, 0x34, 0xab, 0x25, 0xea, 0x5d, 0x9e, 0xa2, 0x3c, 0x19, 0xbf, 0x9d, 0x53, 0x94, 0xc9,
		0xd7, 0x7e, 0x06, 0x2d, 0x55, 0xa2, 0xbd, 0x91, 0x34, 0x43, 0x95, 0x61, 0x1b, 0x70, 0xa9, 0xab,
		0x1a, 0x35, 0x19, 0xb3, 0xe0, 0xe2, 0x15, 0xa7, 0xa8, 0xf3, 0x0f, 0x35, 0xb1, 0xe5, 0xa6, 0xec,
		0x97, 0x63, 0x3a, 0xf8, 0xd9, 0x1a, 0x92, 0x14, 0x54, 0xa9, 0x22, 0x90, 0xa1, 0xa2, 0x22, 0x8b,
		0x2c, 0xec, 0xdf, 0x26, 0x03, 0xcb, 0x05, 0xcb, 0x8d, 0x9d, 0xe5, 0x26, 0xa0, 0xdc, 0x3d, 0xc9,
		0xbe, 0x9a, 0x98, 0x9a, 0x2a, 0x3d, 0x32, 0xec, 0x2c, 0x97, 0x10, 0x7b, 0x0b, 0x7b, 0x2b, 0x4d,
		0x7b, 0x2b, 0x8e, 0x72, 0xb9, 0x9a, 0xfa, 0xaa, 0x0d, 0x87, 0xc9, 0x2c, 0x7b, 0x3b, 0x90, 0x8c,
		0xbe, 0x2e, 0x8f, 0x89, 0x91, 0xe4, 0xa5, 0x71, 0xf7, 0x12, 0x63, 0xe3, 0x63, 0xe3, 0x43, 0xa8,
		0xfa, 0x3e, 0x73, 0x64, 0x4e, 0xe8, 0xf7, 0x96, 0x45, 0xb4, 0x4b, 0x80, 0xa2, 0x52, 0x2f, 0x97,
		0x01, 0x51, 0x60, 0x6b, 0x27, 0x75, 0x6b, 0x4f, 0x64, 0xd5, 0xac, 0x34, 0x18, 0xb6, 0x76, 0x83,
		0x82, 0xa4, 0x23, 0xaa, 0x8f, 0xb1, 0x04, 0x74, 0x5e, 0xca, 0x2a, 0x93, 0xb1, 0x6f, 0x13, 0x7f,
		0xb3, 0xcf, 0x30, 0x6f, 0x72, 0xd6, 0x96, 0x65, 0x8c, 0x2b, 0x3b, 0xd3, 0xc5, 0xbe, 0x25, 0xa6,
		0x3f, 0xcb, 0x8f, 0x32, 0x6d, 0x2e, 0xe5, 0xf2, 0xf4, 0x48, 0x8f, 0xa2, 0x29, 0x3f, 0x5b, 0xaf,
		0x33, 0x14, 0x15, 0x43, 0xa2, 0x6e, 0x85, 0x21, 0xef, 0x3b, 0x77, 0x29, 0xfe, 0x0c, 0x3f, 0x7a,
		0x27, 0xd5, 0x4a, 0x23, 0xfd, 0xa3, 0x87, 0xb8, 0x2e, 0x48, 0x22, 0x48, 0x22, 0x58, 0x97, 0x0b,
		0x42, 0xc9, 0x7c, 0xca, 0xaf, 0x1c, 0xc0, 0x32, 0x8f, 0x99, 0x7f, 0xa9, 0x7a, 0xbf, 0xbd, 0x3a,
		0x71, 0xca, 0xc9, 0x34, 0x44, 0x8d, 0xb1, 0x24, 0x31, 0x9c, 0x2a, 0xee, 0x90, 0x81, 0x2f, 0x80,
		0x2f, 0x40, 0x43, 0x4d, 0x80, 0x86, 0x0a, 0xfd, 0xf4, 0x4d, 0x8f, 0x5d, 0xc2, 0xf2, 0xa5, 0x22,
		0x5a, 0xd3, 0x58, 0xd4, 0x6f, 0x7b, 0xf0, 0x32, 0xba, 0xaa, 0xb1, 0xac, 0xdf, 0xf8, 0xe8, 0x25,
		0x1d, 0x4b, 0x88, 0x2a, 0x91, 0x04, 0xe9, 0x23, 0x6b, 0xfa, 0x77, 0x64, 0xe9, 0x23, 0x76, 0xbe,
		0xd1, 0xea, 0xf7, 0x45, 0xde, 0x11, 0x55, 0x20, 0x2f, 0xb7, 0x25, 0xde, 0xff, 0x46, 0xd3, 0x4d,
		0x61, 0xf9, 0xdb, 0xa2, 0xed, 0x95, 0xa7, 0xa4, 0x24, 0x2d, 0x64, 0xfb, 0xd0, 0x31, 0xe4, 0x81,
		0x6c, 0x1b, 0xa3, 0x7d, 0x27, 0x7e, 0xf8, 0x75, 0x96, 0x22, 0xdd, 0x63, 0xbd, 0x6b, 0x94, 0x49,
		0x1e, 0xcf, 0xfa, 0x90, 0x28, 0xc7, 0xc3, 0xba, 0x2f, 0x8e, 0x14, 0x8f, 0xf5, 0xe7, 0x70, 0x09,
		0xc8, 0xef, 0xb0, 0xde, 0x2a, 0xd2, 0xe4, 0x8e, 0x6f, 0x9d, 0x33, 0xe1, 0xf4, 0xfa, 0xea, 0xec,
		0xfc, 0x0b, 0x61, 0x8a, 0x87, 0x87, 0x20, 0x09, 0x89, 0x1e, 0xfe, 0xd3, 0x44, 0x8b, 0xc0, 0xc4,
		0x9d, 0xe5, 0xe1, 0x3b, 0x8d, 0x6c, 0x6c, 0x2e, 0x30, 0xc5, 0xe3, 0x59, 0x1f, 0x0a, 0x8f, 0x8a,
		0xf6, 0x20, 0x2a, 0xe4, 0xe9, 0x1d, 0x1e, 0x9a, 0x34, 0xa4, 0x76, 0x6c, 0x5f, 0x04, 0xac, 0x70,
		0xdc, 0xbe, 0xf3, 0x3a, 0xb6, 0x2e, 0x92, 0x68, 0x74, 0x30, 0xe2, 0xa4, 0x0e, 0x8b, 0xf5, 0x7e,
		0xd3, 0x87, 0x6d, 0xfb, 0x20, 0x5d, 0x06, 0x14, 0x78, 0x85, 0x7e, 0x97, 0x71, 0x13, 0xb6, 0xae,
		0xfd, 0x86, 0x02, 0x27, 0xc8, 0x16, 0x7f, 0xd6, 0x30, 0x69, 0xa2, 0xcd, 0x91, 0x34, 0x40, 0xfa,
		0x41, 0xd3, 0x14, 0x49, 0x64, 0x3a, 0xbb, 0xa7, 0x92, 0x08, 0x9b, 0x2d, 0x3a, 0xb3, 0xe4, 0x59,
		0x1f, 0xae, 0x7e, 0x5d, 0x51, 0x2f, 0x4a, 0xc4, 0x42, 0x68, 0x9b, 0x5e, 0xfa, 0x4d, 0x1f, 0x0a,
		0x4b, 0x5f, 0x56, 0x9e, 0x22, 0x7c, 0xd3, 0x87, 0x5f, 0x9c, 0x87, 0xa4, 0xc4, 0x2a, 0x09, 0x1e,
		0x39, 0x06, 0xcb, 0x24, 0x68, 0x98, 0xf6, 0x6d, 0x9d, 0xac, 0x77, 0x9a, 0xc2, 0x36, 0x59, 0xed,
		0x1c, 0x85, 0x65, 0x32, 0xf9, 0x59, 0xe8, 0xfb, 0x96, 0x2f, 0x5a, 0x35, 0x4d, 0xe6, 0x37, 0xc6,
		0x61, 0x9b, 0x4c, 0x7e, 0x0a, 0x7e, 0x0f, 0x4b, 0x82, 0x81, 0x32, 0x7f, 0xb5, 0xc8, 0xac, 0x94,
		0xaf, 0x7f, 0x0b, 0xa7, 0xad, 0x4f, 0x17, 0x24, 0x47, 0x80, 0xce, 0x6f, 0x4d, 0x82, 0x65, 0xb2,
		0x65, 0x92, 0x92, 0x6e, 0x9e, 0x6c, 0x9e, 0xc4, 0x1d, 0xd9, 0x28, 0xf3, 0x99, 0xa3, 0x4d, 0x43,
		0x5f, 0xa6, 0x4b, 0x83, 0xad, 0x42, 0xb0, 0x2c, 0xd2, 0x6a, 0xb0, 0x04, 0x2f, 0x9b, 0x98, 0xad,
		0x16, 0xfb, 0x6d, 0x04, 0x93, 0x46, 0x5f, 0x9b, 0x4f, 0x94, 0x87, 0x76, 0x97, 0xd6, 0x8a, 0xd8,
		0x37, 0xe5, 0x67, 0xa9, 0x60, 0x98, 0xa2, 0x3a, 0x78, 0xf8, 0xf5, 0x86, 0xcc, 0x16, 0x8a, 0x7d,
		0x90, 0x35, 0xdb, 0x85, 0x7c, 0x9f, 0x24, 0xcd, 0x80, 0x91, 0xd4, 0xc9, 0x48, 0xd2, 0x45, 0x93,
		0xf1, 0x00, 0xd2, 0x54, 0x64, 0xa5, 0xbb, 0x3b, 0xd2, 0xf9, 0x87, 0x39, 0x41, 0x9d, 0x65, 0x5f,
		0x53, 0xce, 0xa3, 0xa7, 0xd3, 0xcc, 0xa9, 0xea, 0xcb, 0x9d, 0x65, 0xf2, 0x75, 0xae, 0x76, 0xb5,
		0xc9, 0x55, 0x32, 0x90, 0xbf, 0x2e, 0x0f, 0xd9, 0xa2, 0xa0, 0x5d, 0x3a, 0x70, 0x68, 0x70, 0xe8,
		0xbd, 0x70, 0xe8, 0xb8, 0x2b, 0x5c, 0x2e, 0xaa, 0x5b, 0xda, 0x0e, 0x44, 0xeb, 0xab, 0xed, 0x57,
		0x9e, 0x7d, 0x70, 0xca, 0x58, 0x46, 0x5e, 0xc2, 0x92, 0x04, 0x10, 0x92, 0xf4, 0x67, 0x49, 0x17,
		0xe4, 0xf1, 0x73, 0x8d, 0x21, 0x6a, 0xd9, 0x43, 0x8c, 0xbd, 0x8c, 0xbd, 0xbc, 0x97, 0xbd, 0x6c,
		0x1f, 0x65, 0xc5, 0x7e, 0x6e, 0x42, 0x2c, 0xc9, 0x0d, 0xe9, 0x3c, 0x3f, 0xa0, 0xb7, 0x17, 0x3e,
		0xd4, 0x08, 0xc3, 0x87, 0x1a, 0xe0, 0x43, 0xe0, 0x43, 0x7b, 0xe3, 0x43, 0x8d, 0xe4, 0xf3, 0x21,
		0x1c, 0x58, 0xb1, 0xca, 0x98, 0xf7, 0x76, 0x50, 0x45, 0xac, 0xec, 0x55, 0xeb, 0xb3, 0xea, 0x78,
		0x33, 0x4a, 0x30, 0x56, 0x30, 0x56, 0x28, 0x78, 0x50, 0xf0, 0xc2, 0x71, 0xa0, 0x06, 0x33, 0x07,
		0x82, 0x6a, 0x07, 0x0e, 0x04, 0xd5, 0x0e, 0xaa, 0x1d, 0x54, 0xbb, 0x15, 0xc6, 0x6a, 0x8a, 0x26,
		0x03, 0x04, 0xef, 0x90, 0xed, 0xd4, 0x69, 0x3b, 0x31, 0x35, 0xb8, 0x6a, 0xc1, 0xd9, 0x93, 0xcc,
		0xd9, 0xdf, 0x84, 0xab, 0xd6, 0xda, 0x87, 0xac, 0x1e, 0xda, 0x91, 0xa8, 0x4e, 0x88, 0x42, 0x4b,
		0xd7, 0xc8, 0xab, 0x4e, 0x69, 0x4d, 0x53, 0xec, 0x3f, 0xb1, 0x90, 0x1f, 0x2e, 0xfc, 0xc3, 0x2c,
		0xe4, 0x35, 0x97, 0xc7, 0xa5, 0xc0, 0xaf, 0x9c, 0x6b, 0x72, 0x87, 0x2c, 0x0e, 0x65, 0x6b, 0x5a,
		0xd9, 0x7c, 0xd1, 0xee, 0xac, 0x34, 0xb9, 0x2a, 0x03, 0xb1, 0xbb, 0x22, 0xd8, 0x2a, 0xb7, 0x2f,
		0xdc, 0xdf, 0xb5, 0xa4, 0xbb, 0xbf, 0xa3, 0x48, 0xdb, 0x25, 0xf2, 0x73, 0x23, 0x71, 0x37, 0x78,
		0xd9, 0xf8, 0x86, 0x3c, 0xcf, 0xa2, 0x89, 0xd7, 0xbe, 0xcf, 0x03, 0x1e, 0x4b, 0x54, 0xa1, 0x8f,
		0xdc, 0xa6, 0xe8, 0xe8, 0xc9, 0xcf, 0x53, 0x3b, 0xce, 0x6d, 0xf9, 0xdb, 0xa2, 0xed, 0x95, 0xa7,
		0xa4, 0x20, 0x44, 0x3e, 0x78, 0xe8, 0x68, 0xc3, 0xe3, 0x03, 0xc6, 0x68, 0x9f, 0xa1, 0xf1, 0x9b,
		0x3a, 0x4b, 0x1a, 0x1c, 0xef, 0xdb, 0x35, 0xf2, 0xf0, 0x78, 0x55, 0x0c, 0x3c, 0x97, 0xcd, 0xba,
		0x25, 0x86, 0x90, 0x78, 0x63, 0xfd, 0x39, 0xdc, 0xfe, 0xa3, 0xe1, 0xed, 0xb7, 0x8a, 0x2a, 0x10,
		0xfe, 0xaa, 0xd5, 0x15, 0x3e, 0x9d, 0x5f, 0x7d, 0x3e, 0xbf, 0xfa, 0x72, 0x1b, 0x1c, 0x0b, 0xbf,
		0x74, 0x77, 0x02, 0xc2, 0xe1, 0x37, 0x4c, 0x10, 0xad, 0xbd, 0x10, 0x73, 0x24, 0xbc, 0xff, 0x04,
		0xb2, 0xb1, 0xb5, 0xc0, 0x20, 0x78, 0xef, 0x94, 0x51, 0xc6, 0xc1, 0xaf, 0x93, 0xa6, 0x20, 0x14,
		0x3e, 0x60, 0x49, 0xb0, 0x9a, 0x92, 0x7b, 0x8e, 0x82, 0xdf, 0xbe, 0x64, 0xa2, 0xd1, 0xc1, 0x88,
		0x03, 0xe0, 0xdf, 0x76, 0x25, 0x57, 0xc2, 0x05, 0x96, 0x31, 0xcc, 0x82, 0x6c, 0x01, 0x26, 0x0d,
		0xae, 0x88, 0xa7, 0x86, 0xeb, 0x85, 0xa4, 0x3e, 0xda, 0x1a, 0x54, 0x4a, 0xaa, 0x35, 0xa2, 0x00,
		0x18, 0xeb, 0xd0, 0x1d, 0x56, 0x51, 0xfe, 0x2b, 0x1c, 0x26, 0x1d, 0xce, 0x69, 0x73, 0x27, 0x16,
		0xfe, 0x69, 0x15, 0xfe, 0x63, 0x3b, 0x3f, 0x2a, 0xd3, 0xfc, 0x5d, 0x61, 0xfe, 0x5d, 0xe8, 0xbd,
		0x94, 0x0f, 0x0e, 0x2b, 0xd3, 0x84, 0x3a, 0x1d, 0x54, 0xd1, 0x14, 0xc6, 0x9a, 0xa6, 0xb0, 0x88,
		0x4d, 0x97, 0x12, 0xa2, 0x13, 0xa2, 0x93, 0x5a, 0x74, 0x5e, 0x8a, 0xea, 0x40, 0x34, 0x35, 0xfd,
		0x17, 0x39, 0xdf, 0x4f, 0x4f, 0x9a, 0x40, 0xb1, 0x58, 0x72, 0xfe, 0x67, 0x19, 0x2a, 0x37, 0xd7,
		0xd7, 0x17, 0xf3, 0x0f, 0x4e, 0x7e, 0x40, 0xdc, 0xb9, 0x01, 0xd6, 0x56, 0x65, 0x4b, 0x0b, 0x9d,
		0x53, 0xee, 0xd2, 0xbf, 0x48, 0xbe, 0x0e, 0x7b, 0xe0, 0x35, 0xe0, 0x35, 0x31, 0xaa, 0xe9, 0xaa,
		0x68, 0x16, 0x28, 0x96, 0x3f, 0x97, 0x3a, 0x97, 0x22, 0xe5, 0x62, 0x9c, 0x13, 0x3b, 0xa7, 0x12,
		0x53, 0xcd, 0x29, 0x17, 0xf3, 0xa9, 0xc4, 0x0e, 0x5a, 0xcb, 0xe4, 0xdb, 0x72, 0x48, 0xb3, 0x70,
		0x2e, 0xb1, 0xf9, 0x43, 0xee, 0x4b, 0x82, 0xc5, 0xc5, 0x65, 0x86, 0x32, 0x66, 0x4b, 0xd4, 0x60,
		0xbd, 0x60, 0xbd, 0x31, 0xb2, 0x5e, 0x9c, 0x66, 0x01, 0x7c, 0x24, 0x3a, 0x7c, 0xe4, 0xe4, 0xe4,
		0xe4, 0x04, 0x08, 0xc9, 0xae, 0xf1, 0x86, 0x8c, 0x16, 0x48, 0x6f, 0xa4, 0x32, 0xaa, 0x42, 0x15,
		0x4d, 0xcf, 0x27, 0xaf, 0xcb, 0xac, 0x44, 0xeb, 0x3f, 0xe3, 0x36, 0x38, 0xd4, 0xaf, 0x44, 0xb7,
		0x08, 0xb6, 0xf5, 0x61, 0xa9, 0xd1, 0xf5, 0x27, 0x24, 0x3f, 0x96, 0x62, 0xf3, 0x80, 0x51, 0x86,
		0x50, 0x6c, 0x1c, 0x16, 0xe2, 0xd8, 0x89, 0x03, 0x7f, 0x7f, 0xf8, 0x97, 0x8b, 0xeb, 0x4f, 0xad,
		0x0b, 0x32, 0x6f, 0xb8, 0x7b, 0x2f, 0x7c, 0xe1, 0x69, 0xf0, 0x85, 0xdb, 0x62, 0xca, 0x20, 0x77,
		0x80, 0xbb, 0xf7, 0xc3, 0xeb, 0x0d, 0xaf, 0x37, 0x97, 0x13, 0x07, 0x23, 0x59, 0x15, 0x46, 0xda,
		0x80, 0x01, 0xdf, 0xf3, 0xd0, 0xee, 0x12, 0xe1, 0x1b, 0xc8, 0x86, 0x53, 0x09, 0x1b, 0x28, 0x1f,
		0x4c, 0xcd, 0xc4, 0x99, 0x9a, 0xd4, 0x9b, 0x20, 0x7d, 0x38, 0x9f, 0x44, 0x55, 0x89, 0xde, 0x07,
		0xea, 0xa3, 0xda, 0xc0, 0xfb, 0x80, 0xfb, 0x66, 0x2f, 0xc8, 0x06, 0xf9, 0x49, 0xf3, 0x4a, 0xff,
		0x59, 0x40, 0xfd, 0x6c, 0xaf, 0x4d, 0x7f, 0x2c, 0x98, 0xf2, 0x48, 0xd2, 0x26, 0x26, 0xa3, 0xdb,
		0xc7, 0xd3, 0xc0, 0x2e, 0x65, 0xc3, 0x71, 0xa3, 0x56, 0x2e, 0x43, 0x30, 0x40, 0x30, 0x24, 0x13,
		0x83, 0x3c, 0xac, 0x32, 0x08, 0x85, 0xa3, 0xcc, 0x62, 0x90, 0x87, 0x38, 0xa6, 0x91, 0x7d, 0xf0,
		0x6a, 0x87, 0x55, 0x1c, 0xd4, 0x18, 0x03, 0x0e, 0x49, 0x2a, 0x22, 0x43, 0x89, 0xc7, 0x18, 0x44,
		0x63, 0x03, 0x82, 0x11, 0x82, 0x11, 0x82, 0x11, 0x82, 0x11, 0x82, 0x11, 0x82, 0x31, 0x46, 0xc1,
		0x38, 0x19, 0x84, 0xb4, 0x1d, 0xbd, 0x0d, 0xec, 0x52, 0x40, 0x1e, 0x42, 0x40, 0x42, 0x40, 0x26,
		0x55, 0x40, 0x22, 0x7a, 0x65, 0x89, 0xc7, 0x57, 0xaa, 0x10, 0x90, 0xcc, 0x83, 0xd7, 0x80, 0x74,
		0xdc, 0xbd, 0x74, 0x4c, 0x62, 0xcc, 0x86, 0xe3, 0xc6, 0x2f, 0x11, 0x39, 0x7c, 0x39, 0xd2, 0x78,
		0x04, 0xa7, 0x51, 0xc1, 0x6d, 0x34, 0x8d, 0x91, 0x19, 0x5b, 0xa3, 0x1b, 0x28, 0xc7, 0x21, 0x6c,
		0x54, 0xc6, 0xcd, 0xf5, 0x35, 0x61, 0x4c, 0x86, 0x7d, 0x27, 0x22, 0x32, 0xd2, 0x52, 0x9d, 0x60,
		0x9e, 0xb0, 0x43, 0x57, 0x99, 0x60, 0x41, 0x86, 0xf8, 0x0c, 0xc4, 0x67, 0xa0, 0x2a, 0x01, 0xac,
		0x96, 0xb4, 0x58, 0x2d, 0xa8, 0x4a, 0xe0, 0x67, 0xb7, 0xc0, 0x6a, 0x61, 0xc6, 0x44, 0x51, 0x95,
		0x20, 0x24, 0x20, 0xc5, 0xbd, 0xdd, 0xaa, 0x04, 0xf2, 0x98, 0x0d, 0x7b, 0x94, 0xc7, 0x10, 0x9b,
		0x10, 0x9b, 0xf4, 0x62, 0x33, 0xde, 0x8a, 0x04, 0xf2, 0xb8, 0x20, 0x0e, 0x06, 0xba, 0x64, 0x18,
		0x05, 0xdd, 0x86, 0xf1, 0x18, 0x84, 0x2e, 0x45, 0x46, 0xd3, 0xec, 0x4d, 0x77, 0x2e, 0x72, 0x97,
		0xce, 0xfa, 0x70, 0x7b, 0xc8, 0x12, 0x75, 0xc8, 0xa0, 0x58, 0x84, 0xe6, 0x97, 0xf3, 0x06, 0xe2,
		0x3c, 0x04, 0x24, 0xff, 0xfb, 0xdd, 0xfd, 0xfd, 0xf8, 0xe5, 0x6a, 0x6a, 0xfd, 0xbd, 0x98, 0xf6,
		0x3e, 0xf0, 0x1f, 0x73, 0xd4, 0x6f, 0xdd, 0xdb, 0x65, 0x58, 0x66, 0x88, 0x55, 0x40, 0xad, 0x50,
		0x26, 0x64, 0xfe, 0xfd, 0x0e, 0x3e, 0xf0, 0x4e, 0xa4, 0x3d, 0xbf, 0x8b, 0xc3, 0x12, 0x12, 0x75,
		0x7f, 0xbe, 0x90, 0xea, 0xd7, 0x8f, 0x61, 0xf9, 0x27, 0xb8, 0x10, 0x93, 0x6e, 0xb2, 0x16, 0x62,
		0xd2, 0x4d, 0xa8, 0x3d, 0x50, 0x7b, 0xb2, 0x87, 0x16, 0x84, 0x3d, 0xc9, 0xeb, 0xa5, 0x72, 0x50,
		0x9b, 0x5a, 0x1c, 0xa6, 0xee, 0x30, 0x9b, 0x97, 0xda, 0xf4, 0xb5, 0xb1, 0xe0, 0x43, 0x2f, 0x87,
		0xd3, 0xd7, 0x46, 0xdd, 0xf3, 0xbd, 0x6a, 0x7d, 0xaf, 0xdb, 0x27, 0x70, 0x39, 0xcc, 0xa9, 0x51,
		0xaf, 0x1f, 0xda, 0xbf, 0xf3, 0xf9, 0x02, 0x1f, 0x6d, 0x9b, 0xf5, 0xfd, 0x1c, 0xf2, 0x85, 0x34,
		0xed, 0x44, 0xa7, 0x69, 0xaf, 0x17, 0x0c, 0x8b, 0xca, 0xef, 0x67, 0x37, 0xb8, 0xdc, 0x72, 0x1a,
		0x9d, 0x7f, 0x5b, 0xdc, 0x68, 0x54, 0x43, 0x11, 0xc6, 0xf1, 0x77, 0xdb, 0x6d, 0x75, 0xcf, 0x4f,
		0x85, 0xab, 0xd6, 0x4d, 0x37, 0xd8, 0xf7, 0xe7, 0xbd, 0x19, 0xee, 0xbf, 0x34, 0xb8, 0xff, 0x3c,
		0x33, 0x46, 0xe9, 0x01, 0x5c, 0xa3, 0x84, 0x13, 0x10, 0x4e, 0x40, 0x2e, 0xf7, 0xa8, 0x68, 0x0f,
		0xa2, 0xc2, 0x04, 0x6a, 0x2e, 0x48, 0xa1, 0xe0, 0x43, 0xc1, 0x8f, 0x51, 0xc1, 0x67, 0xc4, 0xf0,
		0xb2, 0x7b, 0x60, 0x6f, 0x28, 0xac, 0x2e, 0x4e, 0x30, 0xc1, 0x65, 0x19, 0x4a, 0x8d, 0x11, 0x52,
		0x58, 0xa1, 0x07, 0xdf, 0x01, 0xdf, 0x89, 0x91, 0xef, 0x58, 0x6b, 0xae, 0xa0, 0x4e, 0x46, 0x0f,
		0x92, 0x8e, 0x08, 0x6a, 0x8f, 0x3b, 0x1d, 0xf1, 0xd3, 0xcc, 0x43, 0xd7, 0xa8, 0xd7, 0x0f, 0xeb,
		0x08, 0x46, 0x48, 0x80, 0x68, 0x92, 0xc7, 0xc2, 0x58, 0xd7, 0x4c, 0xad, 0xcf, 0x72, 0xe6, 0x80,
		0x97, 0x18, 0x42, 0x09, 0x42, 0x29, 0x56, 0x65, 0xb8, 0x30, 0x5b, 0x7a, 0xd9, 0x2e, 0x09, 0xde,
		0x3d, 0xbd, 0x61, 0x2e, 0x13, 0xf4, 0xf5, 0xf3, 0x4d, 0x62, 0x2b, 0x04, 0x59, 0xfd, 0x62, 0x3b,
		0x65, 0xd7, 0xea, 0x55, 0x93, 0xab, 0x64, 0xa0, 0x30, 0x90, 0xa2, 0xf5, 0x19, 0x41, 0x88, 0x39,
		0x25, 0xd8, 0x2e, 0xd8, 0x2e, 0x35, 0xdb, 0x8d, 0x3b, 0xb6, 0x0a, 0xb8, 0x45, 0x3a, 0x71, 0x0b,
		0x87, 0xcb, 0xb0, 0x61, 0x16, 0x1e, 0x5a, 0xf0, 0x28, 0xf0, 0xa8, 0x84, 0xf3, 0x28, 0x60, 0x1c,
		0xc0, 0x38, 0x80, 0x71, 0x64, 0x14, 0xe3, 0x48, 0xf8, 0x79, 0x6b, 0x03, 0x9c, 0xb7, 0x06, 0x49,
		0x9a, 0x48, 0x90, 0x05, 0xe7, 0xad, 0x6d, 0x43, 0x57, 0x70, 0xde, 0x5a, 0xe2, 0x01, 0x16, 0x9c,
		0xb7, 0x06, 0xd6, 0x8b, 0x8a, 0x55, 0x19, 0xb1, 0x45, 0x90, 0xf9, 0xcd, 0x3c, 0x74, 0x38, 0x6f,
		0x2d, 0x0e, 0x53, 0x24, 0x8a, 0x40, 0xfe, 0x79, 0x74, 0x21, 0xe7, 0x71, 0xae, 0x72, 0x54, 0x01,
		0x40, 0x71, 0x07, 0xfa, 0x1f, 0xd7, 0x6a, 0x8d, 0xa3, 0x5a, 0xad, 0x7c, 0x74, 0x78, 0x54, 0x3e,
		0xa9, 0xd7, 0x2b, 0x8d, 0x4a, 0x3d, 0x03, 0xa1, 0xff, 0x9e, 0xc0, 0xe1, 0x12, 0x65, 0x10, 0x31,
		0x47, 0x12, 0xf5, 0xee, 0x6d, 0x73, 0xad, 0xfd, 0xb4, 0xa5, 0x01, 0x04, 0x47, 0xd4, 0xd3, 0x8e,
		0x49, 0x24, 0xc9, 0x00, 0x34, 0xb9, 0x00, 0x48, 0x05, 0x48, 0x59, 0x2a, 0x00, 0x73, 0x26, 0x00,
		0x12, 0x01, 0x90, 0x08, 0x30, 0xbf, 0x11, 0x89, 0x00, 0xb0, 0x0d, 0xd3, 0x66, 0x1b, 0xc2, 0xa1,
		0x9e, 0x6e, 0x87, 0x3a, 0x02, 0x7e, 0xc0, 0x6b, 0xe2, 0xe5, 0x35, 0x08, 0xf8, 0x01, 0x7f, 0x82,
		0xa7, 0x14, 0x6c, 0x12, 0x6c, 0x72, 0x47, 0x2c, 0x0f, 0x9e, 0xd2, 0x0d, 0xc4, 0xf0, 0x94, 0xb2,
		0x03, 0xd3, 0xf0, 0x94, 0x82, 0xf5, 0x82, 0xf5, 0x06, 0xcd, 0x15, 0x3c, 0xa5, 0x73, 0x62, 0x78,
		0x4a, 0xe1, 0x29, 0xe5, 0xde, 0x9c, 0xa7, 0x14, 0xee, 0xd0, 0x35, 0xa6, 0xbe, 0x43, 0x77, 0xa8,
		0xc7, 0x1b, 0xba, 0x03, 0x67, 0x68, 0x57, 0x58, 0x6d, 0x3d, 0xb5, 0xae, 0xd0, 0x68, 0x3c, 0xa1,
		0xe4, 0x8e, 0xd0, 0xdf, 0xb6, 0x74, 0x34, 0xa8, 0x83, 0x04, 0x1d, 0xf3, 0xe9, 0x4d, 0x50, 0x2f,
		0x96, 0x5f, 0x7d, 0xf1, 0x82, 0x9e, 0x97, 0xcb, 0xb9, 0xed, 0x9b, 0xeb, 0x90, 0xe8, 0x42, 0x19,
		0x9b, 0xdf, 0xb2, 0xd2, 0x29, 0x7f, 0x17, 0xdd, 0x46, 0x4d, 0x71, 0x9b, 0x46, 0xb8, 0x30, 0xe4,
		0x4c, 0x3f, 0x7e, 0x12, 0xa4, 0xe0, 0x11, 0x2b, 0x72, 0xc4, 0x0a, 0xdb, 0x92, 0x62, 0x66, 0xbd,
		0x14, 0xe5, 0x84, 0x6f, 0x72, 0x80, 0xe5, 0xae, 0xba, 0x37, 0x04, 0xa7, 0x63, 0x75, 0x6f, 0x92,
		0xe0, 0x0e, 0xf7, 0x9f, 0x0c, 0x5a, 0xad, 0x3b, 0x66, 0x6f, 0xb8, 0xef, 0x64, 0xb1, 0xb1, 0xa5,
		0x40, 0x67, 0xb8, 0x23, 0x03, 0xc9, 0x7d, 0xe0, 0xee, 0xfd, 0x29, 0x70, 0x7d, 0x6f, 0x9f, 0x7a,
		0x56, 0xc3, 0x6b, 0xcf, 0x9e, 0xef, 0xad, 0x4b, 0x23, 0x1a, 0xe5, 0x88, 0xd8, 0xf1, 0x6d, 0xe8,
		0x7d, 0x41, 0x56, 0xcd, 0x21, 0xbd, 0xb1, 0x3f, 0xa7, 0xcc, 0x80, 0xa1, 0x4f, 0xb6, 0xcc, 0x32,
		0x66, 0xe7, 0x13, 0x2d, 0xc3, 0xc4, 0x99, 0xf9, 0xaa, 0xa5, 0xbc, 0x64, 0xec, 0x58, 0x0e, 0x45,
		0x12, 0x87, 0xba, 0x34, 0x0c, 0x73, 0x22, 0xc3, 0x11, 0xdb, 0x89, 0x0c, 0x8e, 0x9e, 0x37, 0xd6,
		0x74, 0xb3, 0xe9, 0xe8, 0x57, 0xd6, 0x47, 0xe7, 0xfb, 0xcd, 0x75, 0xa7, 0xbb, 0xf8, 0x64, 0x6b,
		0xe1, 0xce, 0x57, 0x5b, 0xd1, 0x4b, 0xe8, 0xd1, 0x16, 0xfb, 0x1e, 0x49, 0x45, 0x7c, 0xf4, 0x0c,
		0x64, 0xff, 0x49, 0x54, 0x55, 0x49, 0xb1, 0xaf, 0x5a, 0x83, 0x78, 0xfa, 0x67, 0xeb, 0xea, 0xaa,
		0x7d, 0xb1, 0xfa, 0xdd, 0x19, 0x5b, 0xeb, 0x22, 0x86, 0x76, 0xcb, 0xd0, 0x6a, 0xee, 0xc8, 0x2a,
		0x9a, 0x36, 0x7e, 0x10, 0xfb, 0xdf, 0x0b, 0xb2, 0x6a, 0x4a, 0xfa, 0x50, 0xec, 0x4b, 0xd6, 0x6f,
		0x17, 0xd7, 0xd7, 0x37, 0x9f, 0x5a, 0xa7, 0x7f, 0x09, 0xe7, 0x57, 0xdd, 0x76, 0xe7, 0xac, 0x75,
		0xda, 0xf6, 0xbf, 0xea, 0x0e, 0xb6, 0x86, 0xb1, 0xde, 0x32, 0xd6, 0xa3, 0xf1, 0x9c, 0x21, 0x8c,
		0x1e, 0x47, 0xce, 0x41, 0x16, 0xce, 0xc5, 0xcb, 0x2f, 0x97, 0x5d, 0xc1, 0x66, 0x0d, 0xcb, 0x5f,
		0x9d, 0x61, 0xb5, 0xaf, 0x31, 0x0c, 0x6c, 0xd4, 0xd0, 0x13, 0xa1, 0x18, 0xa2, 0x82, 0x84, 0xd8,
		0xa1, 0xa1, 0x48, 0x21, 0x22, 0x36, 0xa8, 0x88, 0x02, 0x94, 0x23, 0x50, 0xb7, 0x9f, 0x75, 0x06,
		0x7d, 0xd1, 0x22, 0x82, 0xaa, 0x08, 0x55, 0x31, 0x36, 0x55, 0x31, 0xe1, 0x27, 0xa1, 0x58, 0x8c,
		0xf5, 0x75, 0xe0, 0xc6, 0xbf, 0xec, 0x89, 0x01, 0x4a, 0x3f, 0x4d, 0x5d, 0x2c, 0x4c, 0x54, 0xc3,
		0x14, 0x1f, 0x14, 0xca, 0x61, 0x1e, 0x4d, 0x0c, 0x33, 0x4e, 0x25, 0x39, 0xdf, 0x9f, 0xe8, 0xba,
		0xa4, 0x9a, 0x79, 0x9e, 0xfb, 0xbf, 0x3f, 0xb8, 0x77, 0xd6, 0xf0, 0xbd, 0xe3, 0x39, 0x4d, 0xe7,
		0xf2, 0xa5, 0xd1, 0xb3, 0x3e, 0xf4, 0x8a, 0xab, 0x67, 0x7d, 0xe8, 0x5c, 0xb3, 0xc5, 0xd3, 0xb7,
		0xce, 0x99, 0x70, 0x7a, 0x7d, 0x75, 0x76, 0xfe, 0xc5, 0xb9, 0xf8, 0xac, 0x0f, 0x05, 0x07, 0x01,
		0x71, 0xbe, 0x5b, 0x24, 0xdf, 0xf4, 0x61, 0x5b, 0xb5, 0xc6, 0x60, 0xc0, 0xfd, 0xc1, 0xbd, 0xb3,
		0x76, 0xcb, 0x3b, 0x9e, 0x45, 0xfa, 0xb6, 0x75, 0x5d, 0xd3, 0x2f, 0x25, 0xc3, 0x10, 0x1f, 0x25,
		0x76, 0x2f, 0xd4, 0xac, 0xcb, 0x97, 0x13, 0xc3, 0xe4, 0xfa, 0x9a, 0x3a, 0x90, 0x4d, 0x59, 0x53,
		0x39, 0x55, 0x33, 0x39, 0x43, 0x34, 0x65, 0x63, 0x28, 0x4b, 0x83, 0x22, 0xd7, 0xd5, 0x7f, 0x71,
		0x92, 0xfd, 0xd2, 0xdc, 0xa5, 0xa8, 0x8a, 0x8f, 0xb6, 0x60, 0xe1, 0xbe, 0x75, 0xce, 0x8a, 0x39,
		0x46, 0x8f, 0x13, 0x23, 0xb3, 0xda, 0xc4, 0xb8, 0x24, 0x6b, 0x30, 0x0a, 0x23, 0x77, 0x34, 0x0e,
		0xd8, 0xdb, 0x0c, 0xcb, 0xcb, 0x36, 0xf2, 0x35, 0xe6, 0x01, 0x66, 0x7a, 0xfc, 0x14, 0x1e, 0x3c,
		0x16, 0x77, 0x4b, 0x80, 0x77, 0xc2, 0x1c, 0x7b, 0x3e, 0x5d, 0x75, 0x6f, 0x4a, 0x44, 0xe8, 0xe6,
		0x46, 0xc7, 0x85, 0x39, 0x16, 0xe6, 0x1f, 0xae, 0xba, 0x37, 0xc2, 0x17, 0xa7, 0xb5, 0x14, 0xf8,
		0x9f, 0x56, 0x07, 0x82, 0xd6, 0xf1, 0xb4, 0xd2, 0xf3, 0x30, 0xa9, 0x77, 0xd6, 0xc0, 0xdd, 0xb6,
		0x3b, 0xdf, 0xda, 0x1d, 0x22, 0x27, 0xc3, 0xec, 0x5e, 0xf8, 0x1a, 0x92, 0xef, 0x6b, 0x58, 0x4c,
		0x17, 0x65, 0xe2, 0xdd, 0x2a, 0x21, 0xbc, 0x0f, 0xf0, 0x3e, 0x18, 0x92, 0xfe, 0x2c, 0xe9, 0xc2,
		0x2c, 0x49, 0x80, 0xde, 0x07, 0xb1, 0x4c, 0x0f, 0xf3, 0x12, 0xe6, 0x65, 0x6c, 0xe6, 0xe5, 0x93,
		0x66, 0x98, 0xd9, 0x3b, 0x1f, 0x3c, 0x8a, 0xd3, 0xc1, 0x19, 0x22, 0xe7, 0xd8, 0x7a, 0xca, 0xde,
		0x63, 0x9f, 0x9e, 0x87, 0x3a, 0x19, 0x3d, 0x0c, 0x84, 0x10, 0x19, 0xa4, 0xb0, 0xd6, 0x50, 0xea,
		0x4e, 0x4c, 0xa7, 0xb3, 0x4f, 0x42, 0xe2, 0xf3, 0xd1, 0xae, 0x9e, 0x46, 0x06, 0x57, 0x4f, 0xf3,
		0xd5, 0x9a, 0x63, 0xb1, 0x30, 0x6c, 0x15, 0xce, 0x7a, 0x2f, 0xe5, 0x83, 0xda, 0x94, 0x6f, 0x3a,
		0x87, 0xed, 0x7a, 0xaf, 0x35, 0xf9, 0x97, 0xf2, 0x41, 0x7d, 0x9a, 0xcf, 0xfb, 0xfc, 0xf2, 0xd1,
		0xaf, 0x0d, 0xfe, 0x35, 0x9f, 0xf7, 0x3d, 0x7d, 0xfc, 0xae, 0x5c, 0x71, 0x0f, 0x1c, 0x5f, 0x1c,
		0x53, 0x6e, 0xaf, 0x46, 0xa2, 0x9b, 0x79, 0xdf, 0x35, 0x78, 0x10, 0x7a, 0x0b, 0xfd, 0xb7, 0xd9,
		0xfb, 0xd0, 0xe4, 0x5f, 0x1a, 0xd3, 0xd9, 0x67, 0xfb, 0x2f, 0xff, 0x9a, 0x2f, 0xbe, 0xbf, 0xbf,
		0x2f, 0x16, 0xdf, 0xf3, 0x4e, 0x87, 0xdc, 0xfb, 0xde, 0x3b, 0xbf, 0x7e, 0x6c, 0x36, 0xd7, 0x2e,
		0xf1, 0xf9, 0xdf, 0x8b, 0xfb, 0xd8, 0x16, 0xbb, 0x3e, 0xb9, 0x3d, 0x36, 0xb7, 0xd8, 0x40, 0x1b,
		0x89, 0xb2, 0x5a, 0x20, 0x38, 0xe5, 0x38, 0xea, 0xdd, 0x95, 0xbb, 0x90, 0xd4, 0x47, 0xdb, 0xdc,
		0x8e, 0x5d, 0x42, 0x85, 0x49, 0x05, 0x98, 0x37, 0x12, 0x32, 0x25, 0x60, 0xde, 0x4e, 0x54, 0xc1,
		0xed, 0x8b, 0xa9, 0x0d, 0x1b, 0xe4, 0x1e, 0x92, 0xf9, 0x73, 0x61, 0x53, 0x06, 0xd6, 0x86, 0xb8,
		0x5a, 0x3f, 0xcc, 0xee, 0x20, 0xc7, 0xc5, 0x80, 0xd8, 0x9c, 0xd7, 0xa1, 0xe4, 0x5e, 0xce, 0xe2,
		0xe1, 0x62, 0xe1, 0x9f, 0x56, 0xe1, 0x3f, 0xe5, 0xc2, 0x89, 0xd0, 0xf3, 0x7c, 0xb9, 0xbf, 0x2f,
		0x08, 0x3d, 0x4b, 0xca, 0x35, 0x2a, 0x53, 0xfe, 0xe3, 0xe2, 0x7a, 0xcf, 0x92, 0x4f, 0xef, 0x59,
		0xa8, 0x3e, 0xf2, 0xaf, 0xf7, 0xf7, 0x0c, 0x30, 0x72, 0xef, 0x2d, 0xa4, 0x74, 0x50, 0x59, 0xf5,
		0x71, 0xe7, 0x75, 0x94, 0xd3, 0x99, 0xc5, 0xb1, 0x0a, 0x0e, 0xbb, 0x50, 0x5c, 0x89, 0x0e, 0x95,
		0x23, 0x46, 0xcd, 0xdd, 0x26, 0x57, 0x5b, 0x4f, 0x21, 0x8a, 0xbe, 0x1d, 0x9b, 0xa6, 0x1c, 0x90,
		0x7d, 0x66, 0x71, 0x78, 0x3b, 0x46, 0x9a, 0xc5, 0xe1, 0xe9, 0x05, 0x45, 0x16, 0xc7, 0xf3, 0xa3,
		0x2e, 0x15, 0xcc, 0x89, 0xaa, 0x4a, 0x4a, 0x60, 0x3a, 0x87, 0xf7, 0xde, 0x38, 0xf2, 0x3a, 0xac,
		0xe7, 0x25, 0x30, 0xb3, 0xc3, 0x7e, 0xad, 0xc8, 0x72, 0x3b, 0xbe, 0x7d, 0xe9, 0xb4, 0x85, 0xee,
		0xd7, 0xab, 0xab, 0xf6, 0x05, 0x81, 0xff, 0xc5, 0x7b, 0x77, 0x12, 0x3c, 0x30, 0x1b, 0xa6, 0x28,
		0xe9, 0x3e, 0x18, 0xff, 0x29, 0xdc, 0x95, 0x17, 0xc6, 0x33, 0x69, 0xb4, 0x7e, 0x98, 0x35, 0xd2,
		0x34, 0x78, 0x62, 0x02, 0x16, 0x45, 0x5a, 0x7d, 0x31, 0xdb, 0x17, 0x4d, 0xdc, 0xde, 0x18, 0xbd,
		0xcf, 0x54, 0x94, 0xcc, 0xa5, 0xcb, 0x82, 0xf7, 0x85, 0x70, 0x99, 0x65, 0xcd, 0xff, 0x42, 0xb6,
		0x0c, 0x77, 0xe3, 0x81, 0x89, 0xbb, 0x28, 0x59, 0x98, 0x92, 0x64, 0xc9, 0xf6, 0xdd, 0x84, 0xf2,
		0x60, 0x84, 0x42, 0xc7, 0x22, 0xb0, 0xbd, 0x53, 0xe6, 0xa9, 0x48, 0x2a, 0x44, 0x1a, 0xd2, 0x13,
		0xb1, 0xef, 0x55, 0xf0, 0x76, 0x3d, 0x0e, 0xc9, 0xf0, 0x34, 0xf4, 0x32, 0x70, 0xce, 0x9b, 0x63,
		0x4d, 0x0a, 0xae, 0x25, 0x4b, 0x5b, 0xc2, 0xca, 0x43, 0x0c, 0x85, 0x06, 0x0a, 0x0d, 0x83, 0x42,
		0x93, 0xf4, 0x8c, 0x05, 0x46, 0x57, 0x16, 0xaa, 0x58, 0xa5, 0xae, 0x8a, 0x55, 0xb5, 0x8e, 0x93,
		0x47, 0x53, 0xe1, 0xf1, 0x20, 0x97, 0x3a, 0x28, 0x63, 0xc5, 0xe8, 0x00, 0xf1, 0x00, 0xcd, 0x7e,
		0x97, 0xbc, 0xa8, 0x58, 0x89, 0x16, 0x22, 0xdb, 0x88, 0x9f, 0x5b, 0x4f, 0xe8, 0x3a, 0x73, 0xbb,
		0x76, 0x61, 0xe9, 0x21, 0xeb, 0x4f, 0x4c, 0x81, 0xab, 0x84, 0x62, 0x48, 0x69, 0xdd, 0x27, 0xa4,
		0x03, 0x17, 0x2a, 0x49, 0xc1, 0x3b, 0xe6, 0x97, 0xad, 0x1b, 0x3a, 0xa8, 0xdc, 0xa6, 0x00, 0x5c,
		0x9e, 0x42, 0xb8, 0xfc, 0xb2, 0x75, 0x13, 0x06, 0x32, 0x9f, 0x93, 0x03, 0x36, 0x07, 0x6c, 0xee,
		0xb1, 0x37, 0x47, 0xe2, 0x38, 0x9c, 0xcd, 0x39, 0x6f, 0x00, 0x76, 0x27, 0xec, 0x4e, 0xd8, 0x9d,
		0xb0, 0x3b, 0x61, 0x77, 0xc2, 0xee, 0x04, 0x12, 0x0a, 0x89, 0xf4, 0x06, 0x25, 0x12, 0x7d, 0x01,
		0x2c, 0x96, 0xc2, 0x57, 0x8b, 0x82, 0x57, 0xf6, 0x30, 0x35, 0x7d, 0x8c, 0x58, 0xe7, 0x87, 0x25,
		0x74, 0x60, 0xfd, 0x92, 0x53, 0xfc, 0xca, 0xb9, 0xee, 0xdd, 0x36, 0x71, 0x96, 0x64, 0x52, 0x44,
		0x95, 0xe9, 0xcc, 0x8e, 0x19, 0x21, 0xb6, 0x38, 0xb6, 0x38, 0xc3, 0x16, 0x8f, 0x37, 0x7a, 0x03,
		0x87, 0x7c, 0x40, 0x4d, 0x8d, 0x4e, 0x4d, 0xad, 0x95, 0x4f, 0x6a, 0xd0, 0x53, 0x13, 0xa0, 0xa7,
		0x3e, 0x1b, 0x4c, 0x92, 0xcb, 0x80, 0xd8, 0x82, 0xd8, 0x4a, 0x8b, 0xd8, 0x3a, 0xac, 0x32, 0x88,
		0xad, 0xa3, 0xcc, 0x8a, 0xad, 0x32, 0xc4, 0x16, 0xb3, 0xc4, 0x6f, 0x1c, 0x1d, 0x1d, 0x55, 0x2b,
		0x10, 0x5d, 0x3b, 0x17, 0x5d, 0x11, 0xbb, 0xf6, 0x39, 0x3a, 0xa0, 0x1f, 0xae, 0xfe, 0xc0, 0x87,
		0x87, 0xf6, 0x4b, 0x0b, 0x97, 0xad, 0x9b, 0x12, 0x8b, 0x7b, 0x8f, 0x0b, 0xed, 0xf2, 0xb7, 0x1e,
		0xe4, 0xff, 0xe4, 0x6c, 0xb9, 0xfe, 0xb7, 0x38, 0xca, 0x23, 0x19, 0xc4, 0x7d, 0xe6, 0x54, 0x6e,
		0x1f, 0x06, 0xd2, 0x2c, 0xcb, 0x2d, 0xbd, 0x25, 0xcf, 0xba, 0x1c, 0x8b, 0x86, 0xf1, 0xe3, 0x29,
		0x28, 0xdf, 0xd2, 0xbd, 0x2b, 0x86, 0x4c, 0x4b, 0xfb, 0x49, 0x96, 0xb6, 0x99, 0xb8, 0x64, 0xcb,
		0xf9, 0x9b, 0x45, 0x95, 0x6f, 0x79, 0xd3, 0xba, 0xbd, 0xfd, 0x97, 0xf0, 0x67, 0xab, 0xf3, 0xb9,
		0x7d, 0x75, 0x7e, 0xf5, 0x25, 0x38, 0x8e, 0x64, 0x95, 0x20, 0x01, 0x61, 0x24, 0x5b, 0xa6, 0x8b,
		0xd6, 0xee, 0x88, 0x39, 0x92, 0x64, 0xf3, 0x74, 0xb2, 0x31, 0xc6, 0xc0, 0x60, 0x92, 0x9b, 0xeb,
		0x8b, 0xf3, 0xd3, 0xf3, 0xf6, 0x2d, 0x79, 0xfc, 0xc8, 0x9c, 0x22, 0x05, 0x21, 0x23, 0x04, 0x0b,
		0x81, 0xd5, 0x10, 0xdd, 0x73, 0xd4, 0x48, 0xf0, 0x42, 0x89, 0x46, 0xf1, 0x23, 0x0e, 0x1c, 0x19,
		0xd8, 0x1a, 0xb8, 0xd0, 0x57, 0x44, 0x96, 0xda, 0x97, 0x4b, 0xd4, 0x19, 0x80, 0x41, 0x28, 0x16,
		0x5e, 0xc6, 0x90, 0x10, 0xf2, 0x85, 0xb9, 0x1b, 0x30, 0x84, 0x1d, 0xd8, 0x78, 0xd0, 0x34, 0x45,
		0x12, 0x99, 0xce, 0xe3, 0xaa, 0xc4, 0x88, 0x2f, 0x4a, 0x3f, 0xc7, 0xb2, 0x4e, 0x6e, 0x56, 0x2c,
		0x75, 0xd1, 0x43, 0x8b, 0x4d, 0x86, 0x4d, 0xb6, 0x87, 0x4d, 0x06, 0xa7, 0xd7, 0x3a, 0x04, 0x06,
		0xf4, 0x90, 0x75, 0xe8, 0x0e, 0x1b, 0x88, 0xcd, 0xda, 0x39, 0x70, 0x48, 0x25, 0x93, 0x84, 0x1f,
		0xa2, 0xae, 0xca, 0xea, 0x63, 0x18, 0xd9, 0x34, 0x6f, 0x03, 0x32, 0x0a, 0x32, 0x6a, 0x4f, 0x32,
		0xea, 0x98, 0x41, 0x44, 0xd5, 0x21, 0xa2, 0x20, 0xa2, 0xd6, 0x44, 0x54, 0x19, 0x12, 0x2a, 0x01,
		0x12, 0xea, 0x49, 0x36, 0x4c, 0x4d, 0xff, 0x25, 0xf4, 0x6d, 0xe6, 0x44, 0x29, 0x9a, 0xbc, 0xc4,
		0x90, 0x49, 0x90, 0x49, 0x90, 0x49, 0x90, 0x49, 0xa9, 0x0e, 0xba, 0x28, 0x43, 0x28, 0x25, 0x41,
		0x28, 0x29, 0x92, 0x2a, 0x8c, 0x64, 0x06, 0x1c, 0x6f, 0x46, 0x08, 0x61, 0x04, 0x61, 0x04, 0x61,
		0x04, 0x61, 0x94, 0x6a, 0x03, 0xa9, 0x0a, 0x59, 0x94, 0x04, 0x59, 0xa4, 0xfd, 0x90, 0x74, 0x56,
		0xf7, 0xad, 0x97, 0x18, 0x32, 0x09, 0x32, 0x69, 0x0f, 0x32, 0x29, 0x25, 0xde, 0x5b, 0x5d, 0xfa,
		0xff, 0x4b, 0x7d, 0x53, 0x98, 0x18, 0x92, 0x2e, 0xd8, 0x83, 0x2d, 0x8c, 0x44, 0xb3, 0xff, 0x44,
		0xbf, 0xe5, 0x36, 0x35, 0x84, 0xed, 0x87, 0xed, 0x87, 0xed, 0xb7, 0xe9, 0x99, 0xc6, 0x58, 0xea,
		0xcb, 0xa2, 0xc2, 0x2a, 0xe7, 0x96, 0xc9, 0xb1, 0xd5, 0xb0, 0xd5, 0xb0, 0xd5, 0x36, 0x6e, 0x35,
		0x53, 0x34, 0x19, 0x2a, 0x75, 0x38, 0x64, 0x84, 0x83, 0xf8, 0x59, 0x1a, 0x8a, 0x13, 0xc5, 0xa4,
		0x32, 0x13, 0x73, 0x03, 0xd9, 0x10, 0x1f, 0x14, 0x89, 0x70, 0xe6, 0x7b, 0xd8, 0xe5, 0xd8, 0xe5,
		0x7b, 0xd8, 0xe5, 0x43, 0x49, 0x34, 0x27, 0xba, 0x24, 0xd0, 0xec, 0x87, 0xa5, 0xbd, 0x4e, 0x91,
		0x52, 0x97, 0x6b, 0xab, 0x93, 0x11, 0xfd, 0x54, 0x77, 0xb5, 0x5b, 0xa7, 0xd6, 0x16, 0x0b, 0x06,
		0x90, 0x2b, 0xdb, 0x41, 0x1f, 0xaa, 0xb3, 0x15, 0x19, 0xc0, 0x87, 0x8a, 0x13, 0x37, 0x4c, 0xb3,
		0x97, 0x19, 0xb1, 0x8e, 0x5c, 0x57, 0x3b, 0xa7, 0x70, 0x1b, 0xfa, 0x33, 0x1b, 0x26, 0x8c, 0x68,
		0x3e, 0x3e, 0x4d, 0xae, 0xbc, 0x23, 0x8c, 0x61, 0x1a, 0xa3, 0x48, 0x98, 0x8c, 0xc7, 0xec, 0x18,
		0x83, 0x97, 0x18, 0x3c, 0x19, 0x3c, 0xf9, 0x8d, 0x6a, 0x5e, 0xfb, 0x4f, 0x49, 0x75, 0xd2, 0xee,
		0x96, 0xbf, 0xac, 0x24, 0x81, 0x95, 0x08, 0x93, 0x84, 0xb8, 0x0d, 0x59, 0x84, 0x37, 0x76, 0xab,
		0x82, 0xf7, 0xf3, 0xca, 0x13, 0x84, 0xf9, 0x13, 0x92, 0x9f, 0x60, 0x4a, 0x30, 0x60, 0x94, 0x39,
		0xa5, 0xc1, 0xe3, 0xb3, 0xc7, 0x44, 0x52, 0x9f, 0xee, 0x12, 0x26, 0x8f, 0xae, 0x77, 0x8b, 0x22,
		0x65, 0xf4, 0x21, 0x38, 0x5f, 0xf4, 0x21, 0x9e, 0x64, 0xd1, 0x87, 0xa7, 0x04, 0xe6, 0x89, 0x3e,
		0x3c, 0x45, 0x97, 0x22, 0xfa, 0xe9, 0x4f, 0xe1, 0xcf, 0xd6, 0xed, 0x9f, 0x04, 0xb9, 0xa1, 0xb3,
		0x3b, 0x93, 0x90, 0x14, 0xfa, 0xf0, 0x94, 0xc2, 0x7c, 0x50, 0xbf, 0x69, 0x63, 0x63, 0x61, 0xc1,
		0xa9, 0xa0, 0xee, 0x64, 0x51, 0xd6, 0x13, 0x5f, 0x26, 0x4b, 0x43, 0x52, 0xe8, 0xc3, 0x53, 0x06,
		0xf3, 0x41, 0xb7, 0x2d, 0x94, 0x68, 0x94, 0x07, 0xe2, 0x54, 0xd0, 0x27, 0xd1, 0x78, 0x12, 0x86,
		0xb2, 0xa4, 0x0c, 0x04, 0x45, 0x36, 0x58, 0xe2, 0x2d, 0x57, 0x1a, 0xc8, 0x82, 0xba, 0xff, 0xf0,
		0xf4, 0x06, 0x35, 0x7d, 0x92, 0x45, 0x99, 0x34, 0x25, 0x3f, 0xee, 0x6a, 0xad, 0xe3, 0x87, 0xa7,
		0xe6, 0x5c, 0x3f, 0xb1, 0xbf, 0xcd, 0x39, 0xea, 0xd9, 0x79, 0xfb, 0xe2, 0xb3, 0xcf, 0x25, 0xa7,
		0x44, 0xab, 0x75, 0xdd, 0xb3, 0x53, 0x28, 0x8a, 0xb4, 0x12, 0x8e, 0x21, 0x55, 0xc9, 0x9e, 0x39,
		0xd5, 0x72, 0xe9, 0x1e, 0x0a, 0xd0, 0x23, 0x92, 0x12, 0x3e, 0xf3, 0xc6, 0xa8, 0x4a, 0xf9, 0x44,
		0x0b, 0x73, 0xd8, 0x93, 0xc2, 0x56, 0xa7, 0x7a, 0x41, 0x0a, 0x9e, 0x07, 0x9e, 0x17, 0x1b, 0xcf,
		0xc3, 0x99, 0x09, 0x1e, 0x62, 0xc4, 0xf4, 0xe1, 0xcc, 0x84, 0xb7, 0x52, 0xd0, 0x8f, 0x54, 0xde,
		0xa0, 0x7c, 0x1f, 0x23, 0x56, 0xfa, 0xf0, 0xe4, 0xf9, 0x34, 0xd3, 0xe2, 0x4a, 0x34, 0x36, 0xf3,
		0x46, 0xb0, 0xec, 0x61, 0x86, 0x94, 0x3d, 0x3c, 0x09, 0xf3, 0x06, 0x97, 0x5b, 0x4e, 0x01, 0x36,
		0xea, 0x3b, 0x40, 0xb4, 0x70, 0xa8, 0xdf, 0x50, 0x84, 0x39, 0x4d, 0x6f, 0x59, 0xdd, 0x26, 0xc7,
		0xb9, 0xdc, 0xfb, 0x81, 0x76, 0xa5, 0x08, 0xed, 0x5a, 0x58, 0x54, 0x0c, 0x98, 0x97, 0x87, 0x18,
		0xc8, 0x17, 0x90, 0xaf, 0x85, 0x39, 0x1e, 0x06, 0xf4, 0x82, 0xed, 0x07, 0xdb, 0x8f, 0xd6, 0xf6,
		0x8b, 0xb7, 0x06, 0xbc, 0xb5, 0x56, 0x0b, 0x34, 0x6b, 0x95, 0x4b, 0x5d, 0x64, 0xd2, 0xf9, 0xd5,
		0x55, 0xbb, 0x23, 0x9c, 0xdf, 0x08, 0x37, 0x9d, 0xeb, 0xee, 0xf5, 0xe9, 0xf5, 0x05, 0x73, 0x8c,
		0x92, 0xd3, 0xd2, 0x45, 0x4d, 0xf8, 0x7c, 0xdb, 0x15, 0x6e, 0xae, 0x3b, 0x5d, 0x96, 0x96, 0xaa,
		0x4b, 0x2d, 0xdd, 0x76, 0x4e, 0x99, 0x5b, 0x3a, 0x5c, 0xb4, 0x64, 0xbd, 0xd0, 0xf9, 0xcd, 0xb7,
		0x1a, 0x4b, 0x33, 0xb5, 0x45, 0x33, 0xd6, 0xdb, 0xb0, 0x36, 0x53, 0x5f, 0x7b, 0x9b, 0x06, 0x4b,
		0x33, 0x8d, 0xb5, 0xb7, 0x69, 0x24, 0x36, 0x24, 0x6c, 0x65, 0xec, 0x9b, 0xdc, 0xe1, 0x41, 0xc8,
		0x46, 0x1a, 0x74, 0xb9, 0x95, 0x2b, 0x8d, 0x78, 0xd7, 0x38, 0x93, 0xbd, 0xed, 0xb3, 0xc2, 0xd9,
		0xa2, 0xdd, 0xd6, 0xd7, 0x77, 0x93, 0xab, 0x32, 0xb7, 0x33, 0x5f, 0x96, 0x4d, 0xae, 0x16, 0xb6,
		0x11, 0x6b, 0x84, 0x1b, 0x19, 0x88, 0xc0, 0x5b, 0xf5, 0x17, 0x84, 0x71, 0xcd, 0x01, 0xa6, 0x86,
		0xaa, 0x02, 0x98, 0x1a, 0x30, 0x35, 0x60, 0x6a, 0xc0, 0xd4, 0xe1, 0xa4, 0x92, 0x3c, 0x16, 0x46,
		0xa2, 0xf1, 0x9d, 0x5e, 0x1a, 0xcd, 0x08, 0x21, 0x85, 0x20, 0x85, 0x12, 0x6d, 0x30, 0xcb, 0xe3,
		0x82, 0x38, 0x18, 0xe8, 0x92, 0x61, 0x14, 0x54, 0xad, 0xf0, 0x8f, 0xa6, 0x32, 0xa5, 0xf4, 0x9c,
		0x50, 0xd0, 0xb8, 0xef, 0xba, 0x73, 0x19, 0xb6, 0xe8, 0xe1, 0x73, 0x2d, 0x44, 0x1f, 0xc3, 0x48,
		0xec, 0xc5, 0xfe, 0x13, 0x4d, 0x53, 0xd2, 0x55, 0xea, 0x6e, 0xcf, 0x1b, 0xc8, 0xe7, 0xef, 0xca,
		0x85, 0x93, 0xde, 0xeb, 0x5d, 0xa5, 0x70, 0xd2, 0x73, 0x3e, 0x56, 0xec, 0x7f, 0x9c, 0xcf, 0xd5,
		0xbb, 0x72, 0xa1, 0x36, 0xfb, 0x5c, 0xbf, 0x2b, 0x17, 0xea, 0x3d, 0xfe, 0xfe, 0xbe, 0xc8, 0xbf,
		0x1c, 0x4e, 0xe9, 0x09, 0xf3, 0xbf, 0xdf, 0xdd, 0xdf, 0x8f, 0x5f, 0xae, 0xa6, 0xd6, 0xdf, 0x8b,
		0x69, 0xef, 0x03, 0xff, 0x31, 0xc7, 0x28, 0x44, 0xac, 0x86, 0xef, 0xef, 0x8b, 0xbd, 0xf7, 0x39,
		0x6a, 0xfa, 0xde, 0x2e, 0xad, 0xe4, 0x70, 0xcb, 0xa9, 0x91, 0x81, 0xe5, 0xd4, 0x7c, 0xb5, 0xe6,
		0x46, 0x2c, 0x0c, 0x5b, 0x85, 0xb3, 0xde, 0x4b, 0xf9, 0xa0, 0x36, 0xe5, 0x9b, 0x7c, 0x7e, 0xf5,
		0x5a, 0x93, 0x7f, 0x29, 0x1f, 0xd4, 0xa7, 0xf9, 0xbc, 0xcf, 0x2f, 0x1f, 0xfd, 0xda, 0xe0, 0x5f,
		0xf3, 0xf9, 0xbc, 0xbb, 0x90, 0x96, 0x16, 0xd7, 0x5d, 0xb9, 0xd2, 0xfb, 0x68, 0x7f, 0x74, 0xfe,
		0xce, 0x97, 0x27, 0xd1, 0xcd, 0x7c, 0x94, 0x8b, 0x32, 0x9f, 0xbf, 0xfb, 0x6f, 0xb3, 0xf7, 0xa1,
		0xc9, 0xbf, 0x34, 0xa6, 0xb3, 0xcf, 0xf6, 0x5f, 0xfe, 0x35, 0x5f, 0x7c, 0x7f, 0x7f, 0x5f, 0x2c,
		0xbe, 0xe7, 0x9d, 0x8e, 0xb8, 0xf7, 0xbd, 0x77, 0x7e, 0xfd, 0xd8, 0x6c, 0xae, 0x5d, 0xe2, 0xf3,
		0xbf, 0x17, 0x43, 0xee, 0x0f, 0x67, 0xfc, 0x9a, 0xf1, 0x6c, 0x93, 0xa8, 0xb5, 0x2c, 0x42, 0xf9,
		0x24, 0xfd, 0x34, 0x75, 0xb1, 0x30, 0x51, 0x0d, 0x53, 0x7c, 0x50, 0x28, 0x25, 0xd5, 0x68, 0x62,
		0x98, 0x71, 0xca, 0x8b, 0xbc, 0x9b, 0x4c, 0x95, 0x2f, 0x16, 0x4b, 0x0b, 0x50, 0xe1, 0xae, 0xf8,
		0xc7, 0xbb, 0x65, 0x7c, 0xec, 0x1d, 0xa7, 0xe9, 0xdc, 0xfc, 0xea, 0x0c, 0xd3, 0x79, 0xd7, 0xe3,
		0x39, 0x51, 0x1d, 0x70, 0x7d, 0x4d, 0x35, 0x45, 0x59, 0x35, 0xf2, 0xfd, 0x89, 0xae, 0x4b, 0xaa,
		0x99, 0xe7, 0x0f, 0xb8, 0x77, 0xc5, 0x77, 0x3c, 0x7f, 0xaf, 0x6a, 0x3a, 0x47, 0xf8, 0x8c, 0x86,
		0xef, 0x33, 0x1a, 0x5b, 0x9f, 0xd1, 0x7c, 0xc7, 0xf3, 0xb9, 0x5d, 0x2d, 0x0a, 0x0a, 0x31, 0xff,
		0xe3, 0x49, 0x52, 0xe3, 0x9c, 0xb6, 0x70, 0xb3, 0xb6, 0x74, 0x35, 0x70, 0xf4, 0x59, 0xf8, 0x3d,
		0xa3, 0x5e, 0xec, 0xa7, 0x1f, 0xdb, 0x43, 0xcb, 0xc8, 0x71, 0xc2, 0x6a, 0xc9, 0xbe, 0xda, 0x72,
		0xac, 0x63, 0xff, 0x26, 0x0d, 0x51, 0x43, 0xfa, 0xdf, 0x44, 0x52, 0xfb, 0x92, 0xc0, 0x72, 0x84,
		0xb7, 0x97, 0x18, 0x06, 0x29, 0x0c, 0xd2, 0x44, 0x1b, 0xa4, 0x38, 0xc5, 0x7b, 0x0d, 0x0d, 0xc4,
		0x29, 0xde, 0xcc, 0x43, 0x57, 0xab, 0x9e, 0xd4, 0x4e, 0x1a, 0x47, 0xd5, 0x13, 0xe0, 0xa9, 0x3b,
		0x17, 0x63, 0x91, 0x85, 0xfd, 0x12, 0x7b, 0xf1, 0x10, 0xfc, 0x1b, 0xac, 0x38, 0x90, 0xc7, 0xb6,
		0xba, 0x59, 0x5d, 0xf4, 0x21, 0x84, 0x1c, 0x55, 0x20, 0xb0, 0xd3, 0xac, 0xdf, 0x53, 0xd2, 0x1a,
		0x14, 0xbc, 0x35, 0xb8, 0x96, 0x61, 0x70, 0xc2, 0x06, 0x08, 0x77, 0xbe, 0x5e, 0xb4, 0xc9, 0x42,
		0x83, 0xed, 0x3b, 0x11, 0x14, 0x9c, 0x8e, 0xa0, 0x60, 0x6b, 0xb2, 0x18, 0xc2, 0x81, 0x17, 0x64,
		0x08, 0x04, 0x46, 0x20, 0xb0, 0x64, 0x3e, 0x49, 0xba, 0x60, 0xd2, 0xa8, 0xe7, 0x8b, 0x83, 0xf0,
		0x16, 0xb4, 0x30, 0x23, 0x61, 0x46, 0x52, 0x9a, 0x91, 0x49, 0x8f, 0xae, 0x61, 0x75, 0xaa, 0xe4,
		0xf2, 0xe5, 0x9f, 0xfc, 0x4b, 0x65, 0x7a, 0xe7, 0x00, 0xf9, 0xe5, 0xc2, 0x49, 0xef, 0xa5, 0x72,
		0x50, 0x9b, 0xe6, 0x12, 0x09, 0x24, 0x0d, 0x15, 0xed, 0x87, 0xd0, 0xd7, 0x26, 0xaa, 0x29, 0xe9,
		0xf4, 0x1c, 0x60, 0x89, 0x7a, 0x97, 0xa5, 0x50, 0x3f, 0x9f, 0xdf, 0xb6, 0x3e, 0x5d, 0xb4, 0x3f,
		0xbf, 0xa1, 0x52, 0xa8, 0x60, 0x47, 0x29, 0x61, 0x47, 0xd6, 0x26, 0x28, 0xd0, 0x6d, 0x02, 0x2e,
		0x75, 0x59, 0x06, 0xf3, 0x0d, 0xc8, 0x9a, 0x5c, 0xd0, 0xbe, 0xa2, 0xd8, 0xc0, 0x8c, 0x38, 0x51,
		0x98, 0x60, 0xf7, 0x79, 0x07, 0xd9, 0x22, 0xcb, 0x67, 0xdd, 0x6b, 0x72, 0x95, 0x0c, 0x44, 0x5f,
		0x3f, 0xea, 0x92, 0xf0, 0xdd, 0x46, 0x60, 0x28, 0x05, 0xc2, 0x8c, 0x10, 0x0c, 0x18, 0x0c, 0x18,
		0xfa, 0xe0, 0x16, 0x7d, 0xf0, 0x78, 0x5a, 0xda, 0x70, 0x3d, 0x99, 0x7a, 0xe2, 0x93, 0x68, 0x3c,
		0xb1, 0x25, 0x61, 0x80, 0x17, 0x80, 0x17, 0xd0, 0xf2, 0x82, 0x78, 0x5d, 0x8c, 0xc9, 0x29, 0xa4,
		0xb6, 0x5c, 0x42, 0x6d, 0xb9, 0x78, 0x1a, 0x45, 0xd9, 0xb4, 0x68, 0x62, 0xdd, 0x55, 0x55, 0xd2,
		0x85, 0x30, 0xf8, 0xd0, 0x5a, 0x0b, 0xe0, 0x04, 0xe0, 0x04, 0xd0, 0x0a, 0x52, 0x88, 0x12, 0xc9,
		0x63, 0x61, 0xac, 0x6b, 0xa6, 0xd6, 0xd7, 0x14, 0xa6, 0xdc, 0x97, 0x39, 0x31, 0x38, 0x00, 0x38,
		0x00, 0x38, 0xc0, 0x16, 0x0e, 0x50, 0x4d, 0x2c, 0x07, 0x78, 0x6e, 0x08, 0xaa, 0xf4, 0xd3, 0x14,
		0x9e, 0x24, 0x71, 0xc0, 0x82, 0x15, 0xaf, 0xb5, 0x00, 0x5e, 0x00, 0x5e, 0x00, 0x5e, 0x90, 0x42,
		0x5e, 0xa0, 0xd4, 0x84, 0x81, 0x61, 0x0a, 0x63, 0x4d, 0x67, 0x28, 0x99, 0xee, 0x25, 0x06, 0x07,
		0x00, 0x07, 0x00, 0x07, 0x48, 0xa1, 0x3d, 0x30, 0x16, 0xfb, 0xdf, 0x25, 0x53, 0x70, 0x42, 0x61,
		0xe9, 0x79, 0xc0, 0x32, 0xf9, 0x2e, 0xfd, 0xc6, 0xb7, 0xed, 0xae, 0xd0, 0x3e, 0xbd, 0xbc, 0xd9,
		0x52, 0x68, 0x73, 0x6d, 0x1c, 0xc1, 0x95, 0xc0, 0x95, 0x62, 0xe3, 0x4a, 0xce, 0x56, 0x28, 0x50,
		0x6d, 0x05, 0x2e, 0x75, 0xde, 0xe3, 0xe5, 0x6d, 0xc8, 0xea, 0x42, 0xb6, 0x5a, 0xb9, 0x68, 0x7d,
		0xa1, 0xd8, 0xcb, 0x94, 0xf3, 0xe8, 0xe9, 0x32, 0xb3, 0x1f, 0x79, 0xb9, 0xab, 0x6c, 0xce, 0xe4,
		0xa5, 0x8e, 0x66, 0xc3, 0xa3, 0x3c, 0xd6, 0x65, 0x4d, 0x97, 0x4d, 0x06, 0x97, 0xf2, 0x9c, 0x12,
		0x7c, 0x19, 0x7c, 0x99, 0x92, 0x2f, 0x23, 0x55, 0xcd, 0xfd, 0x0f, 0xa9, 0x6a, 0x48, 0x55, 0x43,
		0xaa, 0x5a, 0x18, 0x01, 0xa6, 0x4f, 0x14, 0x89, 0xb1, 0x14, 0xe5, 0x82, 0x14, 0x22, 0x0c, 0x22,
		0x2c, 0x63, 0x80, 0x07, 0x8a, 0x50, 0xbe, 0x15, 0x81, 0x84, 0x22, 0x94, 0xc9, 0x90, 0x44, 0x76,
		0xcd, 0x24, 0x46, 0x51, 0xe4, 0xa1, 0x85, 0x2c, 0x82, 0x2c, 0x8a, 0x4d, 0x16, 0x25, 0x23, 0xc4,
		0xae, 0xdb, 0xfa, 0x74, 0xd1, 0x5e, 0xfe, 0xb6, 0x08, 0xb2, 0xf3, 0x6c, 0x8d, 0x24, 0x55, 0x40,
		0x58, 0xbc, 0x16, 0x47, 0xaa, 0x47, 0xa2, 0x0c, 0x42, 0xe0, 0xc3, 0x09, 0xb3, 0xf9, 0x3b, 0x5f,
		0x2f, 0xda, 0x25, 0x9a, 0xa4, 0x69, 0x8e, 0x34, 0xbb, 0xdf, 0x6e, 0x70, 0xb9, 0xe5, 0x34, 0x96,
		0x3b, 0xd8, 0x52, 0x30, 0x80, 0x6a, 0x28, 0xc2, 0x96, 0x38, 0xb0, 0xf7, 0x32, 0x59, 0x8d, 0x03,
		0xe7, 0x56, 0x14, 0x39, 0x48, 0x47, 0x91, 0x83, 0x05, 0x93, 0xa6, 0xab, 0x72, 0xe0, 0xa1, 0x43,
		0x99, 0x03, 0x94, 0x39, 0x18, 0x48, 0x46, 0x5f, 0x97, 0xc7, 0x6c, 0xee, 0x6a, 0x2f, 0x31, 0xb4,
		0x66, 0x68, 0xcd, 0x94, 0x5a, 0x73, 0xbc, 0x4e, 0x08, 0xa0, 0x3e, 0x40, 0x7d, 0x80, 0xfa, 0x64,
		0x0f, 0xf5, 0x91, 0x55, 0x53, 0xd2, 0x87, 0x62, 0x5f, 0x12, 0x14, 0xd9, 0x30, 0x59, 0x92, 0xb1,
		0x96, 0xe8, 0x21, 0xc7, 0x20, 0xc7, 0x62, 0x43, 0x7f, 0x26, 0x2a, 0x63, 0x70, 0x53, 0x92, 0xcf,
		0x11, 0xa1, 0x87, 0xb4, 0xc2, 0x40, 0x5b, 0x3e, 0x10, 0x97, 0xa6, 0x9b, 0x33, 0x8c, 0x4b, 0xd3,
		0x4d, 0xe7, 0xfb, 0xcd, 0x75, 0xa7, 0xbb, 0xf8, 0xe4, 0x82, 0x5b, 0xd6, 0x57, 0x72, 0x5c, 0x8b,
		0x51, 0xe2, 0xa4, 0x78, 0x24, 0x15, 0xf1, 0xd1, 0x33, 0x90, 0xfd, 0x27, 0x51, 0x55, 0x25, 0xc5,
		0xbe, 0x6a, 0x0d, 0xe2, 0xe9, 0x9f, 0xad, 0xab, 0xab, 0xf6, 0xc5, 0xea, 0x77, 0x67, 0x6c, 0xad,
		0x8b, 0x0c, 0x43, 0xbb, 0xa7, 0x63, 0x17, 0xa8, 0x70, 0xc1, 0x0d, 0xf8, 0x20, 0x85, 0x2a, 0x15,
		0x09, 0x4e, 0xc8, 0x86, 0x17, 0x46, 0x2b, 0x7b, 0xe1, 0x71, 0x81, 0xcc, 0x4d, 0x9b, 0xcc, 0x85,
		0x1d, 0x08, 0x3b, 0x10, 0x76, 0x60, 0xca, 0xec, 0xc0, 0x68, 0x1d, 0x86, 0x70, 0x13, 0xae, 0x71,
		0xf5, 0xdd, 0xb8, 0x09, 0x1d, 0xbf, 0x32, 0x95, 0xdb, 0x81, 0x23, 0xf5, 0x8e, 0x39, 0x2d, 0xae,
		0xb4, 0x9d, 0x46, 0x57, 0xe1, 0x36, 0xbf, 0x1b, 0xdd, 0x68, 0x10, 0x3b, 0x0b, 0x7f, 0xdb, 0xd2,
		0xcd, 0xa0, 0xee, 0x11, 0x74, 0xcb, 0xa7, 0x33, 0x41, 0x9d, 0x58, 0x7e, 0xf5, 0xc5, 0x0b, 0x7a,
		0x5e, 0x2e, 0xe7, 0xb6, 0x2f, 0x49, 0x7a, 0xc1, 0xf8, 0x21, 0x9b, 0xfd, 0xf5, 0xba, 0x5b, 0x0b,
		0x21, 0xbf, 0x76, 0xeb, 0x4a, 0x27, 0xfd, 0x9d, 0x5b, 0x1b, 0x75, 0xc6, 0x6d, 0xba, 0xe1, 0x42,
		0x07, 0x94, 0x24, 0x5d, 0xf0, 0x7d, 0x1c, 0x89, 0xce, 0x47, 0xac, 0xdb, 0x11, 0xeb, 0x70, 0xcb,
		0xba, 0x9a, 0xe7, 0xe5, 0x28, 0x17, 0xc4, 0x26, 0x67, 0x52, 0xee, 0xa6, 0xdd, 0xee, 0x08, 0xb7,
		0xff, 0x3a, 0xef, 0x9e, 0xfe, 0x49, 0xe0, 0x62, 0xf6, 0xdc, 0x9c, 0x04, 0x27, 0xf3, 0xd6, 0xc9,
		0xa2, 0x55, 0xd4, 0xe3, 0x76, 0x36, 0x6f, 0x9b, 0x4c, 0x36, 0xa6, 0x16, 0xec, 0x74, 0x5e, 0xcc,
		0x1f, 0xad, 0xdb, 0x79, 0x95, 0x32, 0x0d, 0x8e, 0x67, 0xa2, 0xe5, 0xc1, 0x6a, 0xcf, 0xed, 0xdb,
		0x01, 0x4d, 0xb2, 0x7c, 0xa2, 0xd1, 0xbd, 0x88, 0x1d, 0xd1, 0xee, 0x49, 0xb1, 0x82, 0x3c, 0x7e,
		0xae, 0xd1, 0x83, 0x09, 0x4b, 0xd4, 0x59, 0x80, 0x13, 0xa8, 0x96, 0x5f, 0xd6, 0x60, 0x05, 0x9a,
		0xe5, 0x99, 0x34, 0x78, 0xc1, 0x7b, 0x8a, 0x76, 0x72, 0x6b, 0x2a, 0xec, 0xf9, 0x94, 0xec, 0x64,
		0xd6, 0x6e, 0xf0, 0x2c, 0x3b, 0xfa, 0x64, 0x5c, 0xea, 0x0d, 0x0b, 0xfe, 0x03, 0xfe, 0xb3, 0x03,
		0xfe, 0xf3, 0xa4, 0x19, 0x26, 0x05, 0xa8, 0x0e, 0x80, 0x13, 0x00, 0x67, 0xc0, 0xd0, 0x35, 0x0e,
		0x81, 0x6f, 0xa6, 0x01, 0xdf, 0x24, 0xe7, 0xd9, 0x71, 0x03, 0x9c, 0xe9, 0x44, 0x33, 0x17, 0xe0,
		0x91, 0xcf, 0x15, 0x8f, 0x4d, 0x5b, 0xa2, 0xb4, 0x6f, 0x37, 0xc2, 0x61, 0x92, 0xa4, 0xdf, 0xda,
		0xad, 0x0b, 0xab, 0xdf, 0xbd, 0x4f, 0x58, 0x7b, 0x5a, 0x0a, 0x30, 0x4f, 0xd2, 0xa1, 0xa4, 0x45,
		0x41, 0x89, 0x46, 0x6c, 0x9f, 0xa8, 0xe8, 0xb6, 0x8e, 0x93, 0xa2, 0xa4, 0x1b, 0x3b, 0x49, 0x81,
		0x99, 0xfa, 0x55, 0x24, 0x5c, 0x05, 0x4b, 0xd7, 0x0b, 0x0f, 0xee, 0x06, 0x25, 0xf5, 0x2f, 0x70,
		0xb8, 0x6f, 0x78, 0xd4, 0x7a, 0xab, 0xc8, 0x70, 0xd1, 0xeb, 0x4e, 0x97, 0x00, 0x10, 0xb5, 0xee,
		0x4a, 0x02, 0x12, 0xba, 0xbd, 0xe2, 0x64, 0x52, 0x21, 0x50, 0xdf, 0x09, 0xdb, 0x15, 0xf6, 0x39,
		0x8b, 0x19, 0xa3, 0x00, 0x3d, 0xe7, 0x24, 0x69, 0x40, 0x3b, 0xc9, 0x8a, 0x8e, 0xa6, 0x0d, 0xe6,
		0xdc, 0xba, 0x44, 0x62, 0xc7, 0x37, 0x47, 0xb2, 0x2a, 0x18, 0xa6, 0x68, 0x4e, 0x0c, 0x16, 0x7c,
		0xd3, 0x43, 0x9d, 0x05, 0x7c, 0x81, 0xbc, 0xca, 0x6d, 0x96, 0x80, 0x05, 0xa2, 0x05, 0x99, 0x34,
		0x44, 0x81, 0x61, 0xed, 0x71, 0xa9, 0x2b, 0xc4, 0x38, 0x19, 0x33, 0x57, 0x5f, 0x1c, 0x68, 0x3f,
		0xd4, 0xc4, 0x56, 0x5d, 0xb4, 0x5f, 0x8e, 0x09, 0xfe, 0xb0, 0x86, 0xa4, 0xc9, 0x95, 0x33, 0x50,
		0x62, 0x51, 0x1c, 0x3c, 0x0b, 0x8b, 0x2c, 0x0f, 0xf3, 0xd7, 0x58, 0x62, 0xe2, 0xc0, 0xeb, 0x8d,
		0x80, 0x11, 0x83, 0x11, 0xc7, 0xc8, 0x88, 0x33, 0x99, 0x2d, 0xb2, 0xbc, 0xa7, 0xc2, 0xa4, 0x3a,
		0xd4, 0x58, 0x4e, 0x27, 0x65, 0x91, 0x37, 0xd1, 0xc8, 0x9d, 0x65, 0xf9, 0x73, 0xda, 0xc9, 0x1d,
		0xb0, 0x37, 0x51, 0x71, 0x9a, 0xa8, 0x86, 0x6a, 0xc3, 0x7e, 0x8f, 0x8b, 0xce, 0x71, 0xa8, 0x46,
		0xec, 0x37, 0xf9, 0x2b, 0x5c, 0x67, 0xaa, 0x4e, 0x1b, 0xb5, 0x50, 0x8d, 0x1c, 0x3a, 0x8d, 0x84,
		0xeb, 0x4d, 0xcd, 0x1e, 0xd7, 0xd6, 0xd7, 0xf3, 0x50, 0xad, 0xd4, 0xad, 0x56, 0xbe, 0x5c, 0x9e,
		0x87, 0x6b, 0xa5, 0x61, 0x23, 0x42, 0x67, 0xe1, 0x1a, 0x39, 0xb2, 0x1a, 0xf9, 0xfb, 0x22, 0x6c,
		0x8f, 0x8e, 0x9d, 0xc1, 0x0d, 0xb7, 0xde, 0x4e, 0x66, 0x83, 0x1b, 0x6a, 0xa2, 0xab, 0xce, 0xd2,
		0x0f, 0xd7, 0x86, 0xbd, 0xf4, 0xff, 0x0e, 0x39, 0x2a, 0x55, 0x7b, 0xed, 0xff, 0x1d, 0x6e, 0x86,
		0xaa, 0x76, 0x7f, 0xfe, 0x0e, 0xbb, 0x5a, 0xaa, 0xf6, 0xf2, 0x57, 0x35, 0x55, 0x0a, 0xd3, 0xca,
		0xa1, 0x33, 0xb6, 0xa1, 0xf6, 0x90, 0xbd, 0x85, 0x6e, 0x43, 0x31, 0x84, 0xba, 0xd3, 0x44, 0xa8,
		0xd5, 0xe6, 0xec, 0x9e, 0x70, 0xcb, 0xe4, 0xc8, 0x69, 0x23, 0xd4, 0x70, 0x1c, 0x3b, 0x4c, 0x36,
		0x4c, 0x13, 0x27, 0x4e, 0x13, 0xb5, 0x1c, 0x53, 0x13, 0xd3, 0x03, 0x56, 0x59, 0xc7, 0x6a, 0x83,
		0x2c, 0x14, 0x5b, 0x6b, 0x83, 0xb1, 0x09, 0xea, 0xa5, 0x36, 0x6a, 0x94, 0x3a, 0xcd, 0x7a, 0x23,
		0x1d, 0x76, 0x67, 0xa4, 0xdb, 0x40, 0x95, 0xdd, 0xa7, 0xec, 0xb6, 0x60, 0xf5, 0xa2, 0x1a, 0xaa,
		0x05, 0x6b, 0x2d, 0x1d, 0x86, 0x68, 0xc1, 0x66, 0x32, 0x4d, 0xae, 0x52, 0x0f, 0xd1, 0xc6, 0x5f,
		0xd6, 0x50, 0x56, 0x2a, 0xa1, 0x5a, 0xa8, 0x52, 0xc6, 0x1e, 0xf8, 0x34, 0x61, 0x2f, 0x89, 0x6a,
		0xa8, 0x26, 0xac, 0xd1, 0xac, 0x84, 0x19, 0xce, 0x0b, 0x6b, 0x28, 0x8e, 0x43, 0x35, 0x60, 0x75,
		0xe3, 0x24, 0x54, 0x0b, 0x76, 0x2f, 0xc2, 0x2c, 0x6d, 0x4b, 0xc3, 0x68, 0x72, 0x95, 0x46, 0x98,
		0x26, 0xac, 0x81, 0xa8, 0x85, 0x6a, 0xc0, 0x5a, 0x12, 0xf5, 0x50, 0x2d, 0x58, 0x43, 0x19, 0xae,
		0x13, 0xc7, 0x74, 0x05, 0xe8, 0xd7, 0x5a, 0xf8, 0xdb, 0x61, 0x77, 0xd5, 0x30, 0xb3, 0xf1, 0xb7,
		0x3d, 0x1b, 0xd5, 0x30, 0xfb, 0xeb, 0x6f, 0x77, 0x9b, 0x57, 0xc3, 0x6c, 0x0f, 0x47, 0x65, 0x64,
		0xcb, 0x27, 0x9f, 0x37, 0x62, 0xab, 0x23, 0x4d, 0xae, 0x7a, 0xc8, 0x26, 0xb8, 0x76, 0x1d, 0xf5,
		0x11, 0x5b, 0x5a, 0x3f, 0x75, 0x06, 0xea, 0x9a, 0xa9, 0x7b, 0xcc, 0x96, 0xd5, 0xcf, 0x14, 0x2c,
		0xba, 0x80, 0xd1, 0x14, 0x85, 0x5e, 0xe5, 0xe8, 0xbd, 0x99, 0xfc, 0xff, 0xf2, 0x1b, 0xcc, 0xff,
		0x17, 0x07, 0xcf, 0x82, 0x31, 0x96, 0xa4, 0x01, 0x23, 0xa0, 0xea, 0xd2, 0x02, 0x47, 0x25, 0xe7,
		0x00, 0xc0, 0x51, 0x97, 0x81, 0x4a, 0xe0, 0xa8, 0x8c, 0x67, 0xec, 0xac, 0xf6, 0x8e, 0xa5, 0x52,
		0x0c, 0xdb, 0x99, 0x3b, 0xec, 0xbd, 0xf5, 0xb2, 0xde, 0x50, 0xb6, 0x28, 0x17, 0x41, 0x6c, 0xf0,
		0xbc, 0x9d, 0xa8, 0xe2, 0x5c, 0x17, 0x73, 0x1a, 0x36, 0xde, 0x35, 0xa4, 0xb1, 0xcf, 0x85, 0x8d,
		0x1d, 0x5e, 0x1b, 0xe2, 0xe3, 0xb2, 0xf5, 0x5f, 0x76, 0xc7, 0x39, 0x26, 0x8d, 0xb6, 0x07, 0x8d,
		0x16, 0x1a, 0x2d, 0x34, 0xda, 0x5d, 0x6a, 0xb4, 0x8a, 0x2c, 0xb2, 0x28, 0xb3, 0x36, 0x19, 0xf4,
		0x58, 0xe8, 0xb1, 0x31, 0xea, 0xb1, 0xa8, 0x64, 0x15, 0x9d, 0x32, 0x87, 0x44, 0xaf, 0x26, 0x57,
		0xa9, 0x1e, 0x23, 0xd3, 0x2b, 0x9c, 0x74, 0x8e, 0x46, 0x06, 0x19, 0x72, 0x5f, 0xb0, 0x58, 0x12,
		0x63, 0x65, 0xc5, 0x15, 0x7a, 0x48, 0x25, 0x48, 0xa5, 0x74, 0x48, 0xa5, 0x38, 0xf7, 0xd8, 0xc4,
		0xd4, 0x54, 0xe9, 0x91, 0x61, 0x73, 0xb9, 0x84, 0xd8, 0x55, 0xd8, 0x55, 0x99, 0xd3, 0xf5, 0x98,
		0x0b, 0x8a, 0x68, 0xea, 0xab, 0x36, 0x1c, 0x26, 0xb3, 0xae, 0x07, 0x8e, 0xb8, 0xc1, 0x96, 0xc7,
		0x96, 0xcf, 0x88, 0x79, 0x87, 0x73, 0xf3, 0x99, 0x87, 0x0e, 0x85, 0x8a, 0x93, 0x21, 0x8f, 0x86,
		0x52, 0x9f, 0x5e, 0x0e, 0x59, 0x44, 0x90, 0x3f, 0x90, 0x3f, 0x50, 0x39, 0x67, 0x84, 0xba, 0xf1,
		0x3a, 0xec, 0xbf, 0xda, 0x31, 0x65, 0x09, 0x3d, 0x97, 0x6a, 0x20, 0xfd, 0x64, 0x39, 0x8e, 0xca,
		0x22, 0xc3, 0x56, 0xc7, 0x56, 0x8f, 0x71, 0xab, 0x4f, 0x64, 0xd5, 0xac, 0x34, 0x18, 0xb6, 0x3a,
		0x45, 0x84, 0x2d, 0x63, 0xb0, 0x08, 0x14, 0xcd, 0xf4, 0x15, 0x8c, 0xab, 0xd7, 0x0f, 0xa1, 0x6a,
		0x26, 0x43, 0x06, 0x2d, 0x25, 0xd7, 0x86, 0x38, 0x1b, 0x91, 0x22, 0x39, 0x17, 0x52, 0x09, 0x52,
		0x29, 0x12, 0xa9, 0xc4, 0x9c, 0x1a, 0x9e, 0xae, 0xd2, 0x23, 0x4c, 0xa9, 0xdf, 0x61, 0x52, 0xbe,
		0x43, 0xa5, 0x7a, 0x87, 0x49, 0xf1, 0x0e, 0x95, 0xda, 0x1d, 0x2a, 0xa5, 0x3b, 0x5c, 0x2a, 0x77,
		0xb8, 0x14, 0xee, 0x50, 0xa9, 0xdb, 0x21, 0x53, 0xb6, 0x43, 0xa5, 0x6a, 0x87, 0x4c, 0xd1, 0x0e,
		0x93, 0x9a, 0x1d, 0x2e, 0x25, 0x3b, 0x54, 0x2a, 0x76, 0xc8, 0x14, 0xec, 0x70, 0xa9, 0xd7, 0x61,
		0x52, 0xae, 0x43, 0xa4, 0x5a, 0x87, 0x49, 0xb1, 0x0e, 0x93, 0x5a, 0x1d, 0x26, 0xa5, 0x3a, 0x44,
		0x2a, 0x35, 0x63, 0x0a, 0x75, 0x8c, 0x65, 0x9b, 0x42, 0xa4, 0x4a, 0x87, 0x4a, 0x91, 0x66, 0x4e,
		0x8d, 0x66, 0x4f, 0x89, 0x66, 0x4f, 0x85, 0x66, 0x4f, 0x81, 0x0e, 0x93, 0xfa, 0xcc, 0x9e, 0xf2,
		0x1c, 0x22, 0xd5, 0x39, 0x44, 0x8a, 0x73, 0x88, 0xd4, 0x66, 0xe6, 0x94, 0x66, 0xf6, 0x54, 0xe6,
		0x10, 0x29, 0xcc, 0x21, 0x52, 0x97, 0x99, 0x53, 0x96, 0xd9, 0x53, 0x95, 0xd9, 0x53, 0x94, 0xd9,
		0x53, 0x93, 0xc3, 0xa4, 0x24, 0x87, 0x48, 0x45, 0x0e, 0x95, 0x82, 0x1c, 0x2a, 0xf5, 0x98, 0x31,
		0xe5, 0x38, 0x99, 0x65, 0xec, 0x14, 0x51, 0x65, 0x29, 0x5c, 0xe7, 0x90, 0xc1, 0x74, 0x87, 0xe9,
		0x4e, 0x6d, 0xba, 0x5f, 0x8a, 0xea, 0x40, 0x34, 0x35, 0xfd, 0x17, 0xb9, 0x64, 0x47, 0xbc, 0xc3,
		0x62, 0xf4, 0x10, 0xce, 0xce, 0x21, 0x9c, 0x1d, 0x20, 0xb4, 0x22, 0x1a, 0x92, 0x2e, 0x0c, 0x75,
		0xe9, 0x7f, 0x2c, 0xc2, 0x6b, 0x4e, 0x0b, 0x09, 0x06, 0x09, 0x46, 0x2d, 0xc1, 0x42, 0x81, 0xcf,
		0x54, 0xe9, 0xf4, 0xb3, 0x85, 0x77, 0x98, 0x59, 0x8f, 0x68, 0xb5, 0x52, 0x3b, 0xaa, 0x1d, 0x1f,
		0x36, 0x6a, 0x49, 0x62, 0xab, 0xd6, 0xda, 0x4c, 0x51, 0x08, 0xde, 0x6c, 0x08, 0x8f, 0x20, 0x99,
		0x92, 0x20, 0x99, 0x64, 0xf5, 0xbb, 0x60, 0xea, 0xa2, 0xac, 0xd2, 0x78, 0x70, 0x16, 0xc2, 0x69,
		0x89, 0x1c, 0xf2, 0x09, 0xf2, 0x29, 0x46, 0xf9, 0x84, 0x84, 0x10, 0xe6, 0x6d, 0x3f, 0x12, 0xfb,
		0x06, 0x4b, 0x0c, 0xae, 0x4b, 0x87, 0x8d, 0x8e, 0x8d, 0x1e, 0xe3, 0x46, 0x57, 0x24, 0x71, 0xa8,
		0x4b, 0x43, 0x96, 0x9d, 0x7e, 0x44, 0xb7, 0xd3, 0x9d, 0x93, 0xeb, 0x9c, 0x55, 0xde, 0x74, 0x0e,
		0x85, 0x73, 0xbe, 0xcc, 0xae, 0x5d, 0xb6, 0x4e, 0x6f, 0xdb, 0xa7, 0xc2, 0x4d, 0xe7, 0xfa, 0xec,
		0xfc, 0xa2, 0xed, 0x7f, 0xd5, 0x3e, 0xf3, 0x6a, 0xf6, 0x93, 0x9d, 0x7f, 0x1c, 0xe7, 0xce, 0x36,
		0x27, 0x0c, 0xdb, 0xda, 0x9c, 0x60, 0x4f, 0x63, 0x4f, 0xc7, 0xb9, 0xa7, 0x11, 0x6f, 0xbb, 0x66,
		0x1a, 0x35, 0x8e, 0x81, 0x74, 0xb2, 0x8e, 0xdd, 0x49, 0x95, 0xb5, 0x5e, 0x33, 0x0c, 0xca, 0x68,
		0xe5, 0xcf, 0xe4, 0xa7, 0xd0, 0x17, 0x1f, 0x14, 0x86, 0x50, 0xdb, 0x05, 0x29, 0x64, 0x11, 0x64,
		0x51, 0x8c, 0xb2, 0xe8, 0x41, 0xd3, 0x14, 0x49, 0x64, 0xaa, 0x87, 0x5a, 0x89, 0x71, 0x6b, 0xb1,
		0x95, 0xc2, 0x41, 0x01, 0x1c, 0x6c, 0xa8, 0x6c, 0x22, 0x33, 0xf0, 0x63, 0xbf, 0x15, 0xed, 0x0e,
		0x7e, 0xec, 0x64, 0x28, 0x77, 0xe3, 0x61, 0x5f, 0x10, 0x8d, 0x5f, 0x23, 0x7a, 0x29, 0x34, 0xa7,
		0x84, 0x24, 0x82, 0x24, 0xca, 0x9c, 0x24, 0xca, 0xa4, 0x8f, 0x40, 0xd7, 0x58, 0x8c, 0x38, 0x9b,
		0x8a, 0x70, 0x5a, 0x3f, 0x4b, 0x43, 0x71, 0xa2, 0x98, 0x54, 0xc3, 0x96, 0x6b, 0xff, 0x24, 0x5c,
		0x86, 0x3d, 0xb0, 0x1a, 0xb0, 0x1a, 0xb0, 0x1a, 0xcf, 0xbe, 0x79, 0x3d, 0x57, 0xad, 0xff, 0x3f,
		0xbc, 0x76, 0xa4, 0x7e, 0x32, 0x79, 0x8e, 0x7d, 0x1a, 0x0e, 0x3d, 0xd3, 0x71, 0xc8, 0xb0, 0xdf,
		0xb1, 0xdf, 0xa9, 0xf7, 0x7b, 0xbc, 0x01, 0xde, 0x13, 0xd6, 0x98, 0xba, 0xa3, 0xcc, 0x7a, 0x3d,
		0x60, 0x16, 0x33, 0x0f, 0x5d, 0x98, 0x23, 0x65, 0x60, 0x19, 0x47, 0x2a, 0xb8, 0xcc, 0xb1, 0xcc,
		0x20, 0xb7, 0x6c, 0x2a, 0x88, 0x2d, 0x88, 0xad, 0x18, 0xd5, 0x54, 0x6b, 0xcd, 0x31, 0x57, 0x13,
		0x89, 0x45, 0x53, 0x2d, 0xff, 0x3c, 0xae, 0x94, 0xcb, 0xaf, 0xe5, 0x9f, 0x27, 0xee, 0x3f, 0x55,
		0xfb, 0x9f, 0xe3, 0x63, 0xf1, 0xd8, 0xfe, 0xa7, 0x75, 0x9c, 0x4c, 0xe5, 0xd5, 0xfc, 0x29, 0x8c,
		0xb5, 0x1f, 0x92, 0xce, 0xc0, 0x07, 0x66, 0x94, 0xe0, 0x05, 0xe0, 0x05, 0x31, 0xf2, 0x82, 0x81,
		0xd4, 0x97, 0x47, 0xa2, 0xd2, 0xa8, 0xb1, 0xf0, 0x02, 0x8a, 0x4c, 0xe6, 0x75, 0x65, 0xa3, 0x92,
		0x59, 0x7d, 0xf6, 0xa4, 0x5a, 0x3d, 0x3c, 0x3c, 0xaa, 0x96, 0x0f, 0x1b, 0xc7, 0xf5, 0xda, 0xd1,
		0x51, 0xfd, 0xb8, 0x1c, 0x99, 0xef, 0xa2, 0xf2, 0xd6, 0x92, 0x45, 0xd6, 0xc7, 0xf2, 0x28, 0x41,
		0x63, 0x99, 0x51, 0x6d, 0xf7, 0xb7, 0x10, 0x4b, 0xc1, 0xe2, 0xca, 0x84, 0x41, 0x07, 0x74, 0xe7,
		0xf3, 0xd1, 0x9f, 0xcb, 0x17, 0xc9, 0x79, 0x7c, 0x74, 0xe7, 0xf0, 0x05, 0x0d, 0x8e, 0xf4, 0xd3,
		0xd4, 0xc5, 0xc2, 0x44, 0x35, 0x4c, 0xe2, 0x00, 0xa9, 0xdc, 0x68, 0x62, 0x90, 0x03, 0xe4, 0x0c,
		0x22, 0x20, 0xdf, 0xd7, 0x26, 0xaa, 0x99, 0x5f, 0x1c, 0x45, 0x7d, 0x67, 0x4a, 0x3f, 0xcd, 0x3c,
		0xff, 0xc7, 0x3b, 0x51, 0x51, 0xde, 0xf5, 0x78, 0xee, 0x0f, 0xae, 0xcc, 0x73, 0x9a, 0xce, 0xad,
		0xdd, 0x68, 0xfd, 0x54, 0xe1, 0x73, 0x51, 0x8a, 0xb2, 0x70, 0xef, 0xbf, 0x5c, 0x2c, 0x8f, 0xa4,
		0x23, 0x2b, 0x14, 0x54, 0x3d, 0xfa, 0x2d, 0xdc, 0x86, 0x0c, 0x5a, 0x2b, 0x2d, 0x55, 0xd5, 0x4c,
		0x91, 0xf8, 0xc4, 0x8e, 0x9c, 0xd1, 0x7f, 0x92, 0x46, 0xe2, 0x78, 0x16, 0xc2, 0xee, 0xc4, 0xae,
		0x5b, 0x5a, 0x89, 0xf7, 0xe3, 0xcd, 0x75, 0xa7, 0x6b, 0xff, 0xb1, 0x43, 0xd4, 0x73, 0x24, 0x80,
		0xac, 0xa9, 0x4f, 0xfa, 0xa6, 0x1b, 0x79, 0x94, 0xbb, 0xb5, 0x9a, 0xba, 0xd1, 0x74, 0x53, 0x58,
		0x7c, 0xb2, 0x9b, 0x5b, 0xb4, 0xf9, 0x1b, 0xdb, 0xa0, 0xf9, 0xff, 0xb2, 0x61, 0x90, 0x48, 0x07,
		0x87, 0x7c, 0x50, 0xb6, 0x0c, 0x05, 0xe1, 0x10, 0xf8, 0x77, 0x7c, 0xbd, 0x5b, 0xcb, 0x57, 0x56,
		0x3a, 0x18, 0xd4, 0x31, 0xa2, 0x0e, 0xf9, 0xf4, 0x25, 0xb8, 0x0f, 0xcb, 0xaf, 0xbf, 0x78, 0x49,
		0xcf, 0x0b, 0xe6, 0x16, 0x8f, 0xe8, 0x3f, 0x89, 0xaa, 0x2a, 0x29, 0x6b, 0xef, 0xb8, 0x00, 0xe4,
		0xd7, 0x6e, 0x5d, 0xe9, 0xe8, 0x4c, 0x89, 0x5c, 0xb9, 0xbc, 0xc9, 0x52, 0xd9, 0x66, 0x91, 0x78,
		0x32, 0xe5, 0xfd, 0xbc, 0x2f, 0x41, 0x06, 0x06, 0xb1, 0x21, 0x41, 0x6c, 0x30, 0x2c, 0x19, 0x06,
		0xd6, 0x4b, 0x51, 0x2e, 0x82, 0xcf, 0xb2, 0xbf, 0x4c, 0xcc, 0x59, 0xeb, 0xec, 0xf4, 0xcf, 0xd6,
		0xd5, 0x55, 0xfb, 0x62, 0x73, 0x77, 0x66, 0xa3, 0xe1, 0xbd, 0x79, 0xc3, 0x7b, 0xfa, 0x4f, 0x02,
		0xb1, 0xd9, 0x48, 0x62, 0x26, 0x06, 0x4c, 0x0e, 0xad, 0x15, 0x48, 0x6d, 0xf5, 0x51, 0x5b, 0x79,
		0xc1, 0x93, 0xc7, 0xc6, 0xb2, 0x36, 0x4d, 0xaa, 0xdf, 0xe4, 0x3a, 0x9c, 0x34, 0x70, 0x2c, 0x7c,
		0x66, 0x9a, 0x84, 0xaf, 0x07, 0x4c, 0x3b, 0x35, 0x6a, 0x40, 0x83, 0x16, 0x10, 0x2e, 0x07, 0x56,
		0x70, 0x80, 0x19, 0x14, 0x60, 0x06, 0x03, 0xc8, 0x97, 0x4b, 0x34, 0xfa, 0x75, 0xd0, 0x32, 0x9a,
		0xdf, 0x28, 0x0e, 0x46, 0xb2, 0x2a, 0x18, 0xa6, 0x68, 0x4e, 0x58, 0x0e, 0x73, 0xf6, 0x52, 0x67,
		0x00, 0x94, 0x22, 0x5b, 0x6e, 0x19, 0xc3, 0xa4, 0x88, 0x96, 0xe3, 0x6e, 0x20, 0xa9, 0x78, 0xbd,
		0xaa, 0x0c, 0xab, 0x95, 0x4b, 0x5d, 0x8d, 0xec, 0xc9, 0x98, 0xb9, 0x46, 0xf6, 0x40, 0xfb, 0xa1,
		0x26, 0xb6, 0xce, 0xab, 0xfd, 0x72, 0x6c, 0x65, 0x53, 0x27, 0x63, 0x8b, 0x7d, 0x64, 0xa0, 0xae,
		0x21, 0xce, 0x67, 0x04, 0xab, 0x46, 0xc0, 0xdb, 0x06, 0x98, 0x10, 0x59, 0x1e, 0x31, 0x03, 0xd4,
		0x38, 0x9d, 0xf1, 0xad, 0x57, 0x2b, 0xec, 0x8f, 0x85, 0xef, 0x36, 0x90, 0x4f, 0x5d, 0xab, 0xd0,
		0xa5, 0x84, 0x1c, 0x82, 0x1c, 0x8a, 0x4d, 0x0e, 0x4d, 0x54, 0x72, 0xd5, 0x67, 0x49, 0x0c, 0x51,
		0x14, 0x67, 0x9f, 0xbd, 0xde, 0xce, 0x85, 0x10, 0xb3, 0x70, 0x0d, 0x23, 0x64, 0x17, 0x1b, 0x86,
		0x31, 0x66, 0x67, 0x01, 0x3b, 0x4c, 0x4c, 0x2d, 0x47, 0x4d, 0xda, 0xdb, 0xa5, 0x71, 0x12, 0x62,
		0x12, 0xa8, 0x8b, 0x94, 0xac, 0x4e, 0x02, 0x4b, 0x6d, 0x7b, 0xb6, 0x70, 0x07, 0xf6, 0xde, 0x46,
		0xa2, 0xff, 0x44, 0xa5, 0x07, 0x45, 0x2e, 0xd2, 0xa3, 0x13, 0xed, 0x21, 0xf4, 0xa3, 0x48, 0xf4,
		0xa4, 0xb5, 0x21, 0x0e, 0x71, 0xc8, 0x60, 0x1a, 0x86, 0xf9, 0xb7, 0x78, 0xa8, 0x7a, 0x59, 0x28,
		0xba, 0x22, 0x8d, 0x1e, 0x24, 0x9d, 0x01, 0xe7, 0x9d, 0x11, 0xee, 0x32, 0x61, 0xef, 0xed, 0x64,
		0xeb, 0x41, 0x65, 0x84, 0xca, 0xb8, 0x47, 0x95, 0x91, 0xbe, 0x4c, 0xe2, 0x5a, 0xf7, 0x8e, 0xd8,
		0x74, 0x46, 0x27, 0x1a, 0x61, 0xac, 0xe9, 0x66, 0xd3, 0x13, 0x92, 0x60, 0x7f, 0xb7, 0x43, 0x4e,
		0xe6, 0x9f, 0x9c, 0xd2, 0x88, 0xf6, 0x57, 0xf2, 0xc2, 0x88, 0xf1, 0xeb, 0x7d, 0x29, 0x55, 0xbe,
		0x73, 0x69, 0x13, 0x7e, 0x84, 0xfb, 0x9c, 0x2a, 0x52, 0xd0, 0xab, 0xce, 0xd2, 0x45, 0x0c, 0x7a,
		0xb5, 0xb4, 0xd0, 0x91, 0x83, 0xf3, 0xc6, 0xa8, 0x22, 0x08, 0x23, 0x56, 0x0b, 0x64, 0x55, 0x50,
		0x64, 0xf5, 0x3b, 0x8b, 0x62, 0x30, 0x27, 0x85, 0x5c, 0x86, 0x5c, 0x8e, 0x4f, 0x2e, 0xa3, 0x2a,
		0x68, 0x44, 0x86, 0x34, 0x1c, 0x0a, 0x4d, 0xae, 0x52, 0xae, 0xd6, 0xe0, 0x51, 0x48, 0x82, 0x7d,
		0xfa, 0x86, 0x8b, 0x52, 0x43, 0xf8, 0x40, 0xf8, 0x40, 0xf8, 0xa0, 0x22, 0x35, 0x84, 0xcf, 0x9e,
		0x84, 0xcf, 0xdb, 0x2e, 0x9b, 0x0b, 0xf1, 0x93, 0x16, 0xf1, 0x83, 0x70, 0x2a, 0x08, 0xa0, 0x48,
		0xad, 0x1f, 0x14, 0xcd, 0xdd, 0x2c, 0x7f, 0xe2, 0xa8, 0x63, 0x72, 0xa3, 0xe9, 0xe6, 0xa9, 0x93,
		0xfe, 0x76, 0x57, 0x2e, 0x9c, 0xf4, 0x5e, 0x2a, 0x07, 0xb5, 0x69, 0x0e, 0xe5, 0x8b, 0x20, 0x23,
		0x21, 0x23, 0x51, 0xbc, 0x28, 0x4e, 0x0e, 0x80, 0x92, 0x0e, 0x9e, 0x46, 0x22, 0x2d, 0xe9, 0x10,
		0x59, 0x9a, 0xbe, 0x9b, 0x27, 0xed, 0x73, 0xc5, 0x93, 0xde, 0x59, 0xa2, 0x4c, 0xf5, 0xe4, 0xb6,
		0xe4, 0x7e, 0xbb, 0xcd, 0x0b, 0x6b, 0x17, 0xbc, 0xcf, 0x58, 0x7b, 0x5e, 0x3a, 0xd2, 0xfb, 0x89,
		0x06, 0x93, 0x21, 0xe7, 0x9f, 0x64, 0xcc, 0x88, 0x0b, 0x01, 0x1c, 0x6c, 0x4d, 0xf0, 0x16, 0xce,
		0xaf, 0xba, 0xed, 0xce, 0x59, 0xeb, 0xb4, 0x4d, 0x95, 0xea, 0xed, 0x21, 0x43, 0xd2, 0x77, 0xba,
		0x92, 0xbe, 0xe7, 0x33, 0x27, 0x9c, 0xdf, 0xdc, 0x74, 0xda, 0x67, 0xe7, 0x7f, 0x87, 0xc8, 0x03,
		0xdf, 0xd4, 0x18, 0x52, 0xc3, 0x91, 0x1a, 0x2e, 0x8f, 0x85, 0x31, 0x9d, 0xb6, 0x3c, 0x9f, 0x9b,
		0x05, 0x29, 0xd4, 0x7e, 0xa8, 0xfd, 0xf1, 0x41, 0x63, 0xb6, 0x1c, 0x97, 0xc7, 0x05, 0xea, 0x01,
		0x4c, 0x47, 0xae, 0x87, 0xdb, 0xbd, 0x5a, 0x81, 0x69, 0x81, 0x70, 0x7b, 0x0f, 0x3c, 0xcb, 0xe7,
		0x6d, 0x80, 0xe3, 0xf5, 0xae, 0x52, 0x38, 0xe9, 0x39, 0x1f, 0x2b, 0xf6, 0x3f, 0xce, 0xe7, 0xea,
		0x5d, 0xb9, 0x50, 0x9b, 0x7d, 0xae, 0xdf, 0x95, 0x0b, 0xf5, 0x1e, 0x7f, 0x7f, 0x5f, 0xe4, 0x5f,
		0x0e, 0xa7, 0xf4, 0x84, 0x25, 0xf7, 0x61, 0xfc, 0x6b, 0xfe, 0xae, 0x52, 0xa8, 0xf6, 0x66, 0x5f,
		0x0e, 0xef, 0xca, 0x85, 0x6a, 0x8f, 0xe7, 0xb3, 0x93, 0x7d, 0x32, 0x5b, 0x16, 0x8d, 0xf4, 0x2e,
		0x8b, 0xe6, 0xab, 0x35, 0x3d, 0x62, 0x61, 0xd8, 0x2a, 0x9c, 0xf5, 0x5e, 0xca, 0x07, 0xb5, 0x29,
		0xdf, 0xe4, 0xf3, 0xab, 0xd7, 0x9a, 0xfc, 0x4b, 0xf9, 0xa0, 0x3e, 0xcd, 0xe7, 0x7d, 0x7e, 0xf9,
		0xe8, 0xd7, 0x06, 0xff, 0x9a, 0xcf, 0xe7, 0xdd, 0x05, 0xb1, 0xb4, 0x48, 0xee, 0xca, 0x95, 0xde,
		0x47, 0xfb, 0xa3, 0xf3, 0x77, 0xbe, 0xcc, 0x88, 0x6e, 0xe6, 0xf9, 0xbc, 0x77, 0x75, 0xd9, 0x98,
		0x5d, 0x75, 0xca, 0xbf, 0xe6, 0xad, 0x35, 0x59, 0x99, 0xaf, 0xb4, 0x8a, 0xd5, 0xc8, 0xb1, 0x75,
		0x7b, 0xee, 0x80, 0x79, 0xbf, 0xfc, 0xb7, 0xd9, 0xfb, 0xd0, 0xe4, 0x5f, 0x1a, 0xd3, 0xd9, 0x67,
		0xfb, 0x2f, 0xff, 0x9a, 0x2f, 0xbe, 0xbf, 0xbf, 0x2f, 0x16, 0xdf, 0xf3, 0x4e, 0x27, 0xdd, 0xfb,
		0xde, 0x3b, 0xbf, 0x7e, 0x6c, 0x36, 0xd7, 0x2e, 0xf1, 0xf9, 0x52, 0xf1, 0x03, 0x9f, 0x7b, 0x93,
		0x79, 0x0f, 0x70, 0xed, 0x41, 0x7f, 0x49, 0x83, 0xfe, 0x42, 0x1f, 0x99, 0xcf, 0x12, 0x91, 0xbf,
		0x88, 0xc4, 0x57, 0xc4, 0xc7, 0xe6, 0x3a, 0xf6, 0x61, 0x5d, 0xf5, 0x82, 0x49, 0x2b, 0xdf, 0x9d,
		0xd8, 0x7c, 0xeb, 0x22, 0x79, 0x68, 0x7e, 0x8c, 0xd8, 0x23, 0x47, 0x6a, 0x7b, 0x00, 0x85, 0xdc,
		0x31, 0x0a, 0xb9, 0x00, 0x17, 0x4a, 0xe1, 0x21, 0x87, 0xd0, 0x10, 0xe5, 0xe2, 0xb1, 0x24, 0x2f,
		0xc3, 0x8a, 0x5f, 0x1e, 0xd0, 0x62, 0x38, 0x51, 0x40, 0x37, 0x40, 0x6c, 0x80, 0xd8, 0xd8, 0x37,
		0x2a, 0x9a, 0x36, 0x7e, 0x10, 0xfb, 0xdf, 0x05, 0xc7, 0x2f, 0xcf, 0x50, 0x98, 0x63, 0xa5, 0x01,
		0x68, 0x3f, 0xd0, 0x7e, 0xe2, 0xd3, 0x7e, 0x98, 0x16, 0x1f, 0x17, 0xbb, 0xeb, 0x76, 0xa0, 0x6b,
		0xe3, 0xd7, 0xa1, 0xa6, 0xff, 0x10, 0xf5, 0x41, 0x32, 0xc3, 0x34, 0x46, 0x63, 0x85, 0x25, 0x97,
		0xcb, 0xa2, 0xc2, 0x8e, 0xc7, 0x8e, 0x8f, 0x6d, 0xc7, 0x4b, 0xea, 0x64, 0x24, 0xe9, 0x22, 0xeb,
		0x6e, 0x4f, 0x45, 0x3d, 0x4e, 0x49, 0xb5, 0x0f, 0x71, 0x60, 0xae, 0xc9, 0x29, 0x1b, 0x36, 0x7d,
		0x62, 0xcb, 0x72, 0xba, 0xef, 0xc7, 0x56, 0x99, 0xd3, 0x1d, 0x9c, 0x6c, 0x54, 0xe7, 0x04, 0xca,
		0x04, 0xae, 0x0b, 0x94, 0x29, 0xd9, 0x28, 0x13, 0xd1, 0x36, 0x36, 0x85, 0x7f, 0x34, 0x95, 0x69,
		0x2b, 0xbb, 0x94, 0xbb, 0x2c, 0x93, 0x53, 0x46, 0x9d, 0x1c, 0xb0, 0x94, 0xa4, 0xb1, 0x94, 0x89,
		0xac, 0x9a, 0xc7, 0x0c, 0x0c, 0xa5, 0x9e, 0xd9, 0x8c, 0xc8, 0x32, 0x12, 0x52, 0x58, 0x87, 0xee,
		0x10, 0xe9, 0x28, 0x09, 0xc0, 0x10, 0x9e, 0xf5, 0xa1, 0xc0, 0xa6, 0xd1, 0xce, 0x29, 0x21, 0x82,
		0x20, 0x82, 0x32, 0xab, 0xd5, 0x3e, 0xeb, 0x43, 0x57, 0xab, 0x7d, 0xd6, 0x87, 0xf6, 0xb7, 0x6f,
		0x9d, 0xb3, 0xd9, 0xbf, 0x8e, 0xf6, 0x6a, 0x7d, 0x49, 0xa4, 0x8f, 0x14, 0x9e, 0xd1, 0xb5, 0xe5,
		0x9f, 0x2c, 0xcf, 0x68, 0x12, 0x1c, 0xa2, 0x59, 0xcb, 0xe3, 0x08, 0x4c, 0x79, 0x88, 0x6e, 0x44,
		0xa3, 0xca, 0xed, 0xb8, 0x6c, 0x5f, 0x7e, 0x6a, 0x77, 0xe8, 0x12, 0x3b, 0x5c, 0x1a, 0x64, 0x75,
		0xa4, 0x2b, 0xab, 0xc3, 0x99, 0xb6, 0x10, 0xe1, 0x00, 0xde, 0x06, 0x10, 0x0b, 0x80, 0x58, 0x00,
		0xa0, 0xd1, 0xd0, 0xdb, 0xa1, 0xb7, 0xa7, 0x1e, 0x8d, 0xb6, 0x4f, 0x6a, 0xa6, 0xde, 0xc6, 0x1b,
		0xce, 0x77, 0xc6, 0x36, 0xc6, 0x36, 0xce, 0xc8, 0x36, 0xde, 0x55, 0x11, 0xf1, 0x38, 0x23, 0x95,
		0x09, 0x76, 0x29, 0x4c, 0xf1, 0x5d, 0x9b, 0xe2, 0x8e, 0xde, 0x5c, 0x62, 0x53, 0xa5, 0x43, 0x9b,
		0x8c, 0xee, 0xa3, 0x36, 0x3d, 0x3d, 0x4b, 0xe6, 0xf7, 0x56, 0xc3, 0x34, 0xa2, 0x81, 0x24, 0x36,
		0xbc, 0xb7, 0x1e, 0xac, 0x1f, 0x30, 0x20, 0x0c, 0x03, 0xe1, 0xd3, 0x6b, 0xda, 0xde, 0x2e, 0x77,
		0x6d, 0xd1, 0x01, 0xcf, 0xcb, 0xbb, 0x99, 0x80, 0xba, 0x64, 0x98, 0xe2, 0x58, 0x5e, 0x7b, 0xf7,
		0x95, 0x84, 0xc1, 0xd9, 0x6d, 0x2b, 0x9d, 0xf7, 0x37, 0x0e, 0x37, 0x8a, 0xfd, 0x6d, 0xe2, 0x7d,
		0xfe, 0x40, 0xff, 0x47, 0x91, 0x88, 0x6c, 0x62, 0xd1, 0x4c, 0x2c, 0x82, 0x97, 0x44, 0xed, 0xec,
		0xc5, 0x28, 0x17, 0xc8, 0x26, 0x23, 0x2c, 0xd7, 0x69, 0xdf, 0x76, 0x5b, 0x37, 0xe7, 0xc1, 0x88,
		0xcd, 0xec, 0xc6, 0x04, 0xc0, 0x34, 0x9b, 0x27, 0x27, 0xe1, 0x50, 0xcd, 0xc6, 0xc9, 0xdb, 0x11,
		0x5c, 0xd3, 0x97, 0x74, 0xd3, 0x20, 0x07, 0x67, 0x9c, 0xdb, 0x53, 0x00, 0xc5, 0x04, 0x2f, 0x80,
		0x94, 0xc2, 0x31, 0x81, 0x0b, 0x24, 0x66, 0x48, 0xa6, 0x2f, 0x0a, 0x7d, 0x16, 0x6b, 0xce, 0xa5,
		0xcb, 0x80, 0x3d, 0x47, 0xbe, 0xd4, 0x32, 0x66, 0xd3, 0x11, 0x2f, 0xc5, 0xa4, 0xd9, 0x75, 0xf1,
		0x54, 0x9b, 0x65, 0xce, 0xc5, 0xc8, 0x97, 0xee, 0xc4, 0xc2, 0x3f, 0xad, 0xc2, 0x7f, 0xca, 0x85,
		0x13, 0xa1, 0xd0, 0xfb, 0xc0, 0xbf, 0x2f, 0xe5, 0x57, 0xae, 0x14, 0xed, 0x0b, 0x3d, 0x9a, 0xdc,
		0xf7, 0x38, 0xe3, 0x2c, 0xfa, 0x8a, 0x2c, 0xa9, 0xa6, 0xb5, 0xc1, 0x85, 0x3e, 0x1b, 0x66, 0xbb,
		0xd6, 0x02, 0x18, 0x05, 0x18, 0x05, 0x18, 0xc5, 0x0a, 0xa3, 0xf0, 0x70, 0x85, 0xfb, 0xfb, 0xc2,
		0xfd, 0x7d, 0xb1, 0xf7, 0xe1, 0x80, 0x7f, 0xef, 0x77, 0x39, 0xa1, 0x8c, 0xc2, 0x90, 0xf4, 0x67,
		0x49, 0x67, 0xd3, 0x20, 0x3c, 0xb4, 0x60, 0x0e, 0x60, 0x0e, 0x60, 0x0e, 0xf4, 0x5a, 0x84, 0xb5,
		0x77, 0x92, 0xcc, 0x17, 0xbe, 0xdb, 0xc0, 0x32, 0x1b, 0x5f, 0xb0, 0x68, 0xc1, 0x17, 0xc0, 0x17,
		0xc0, 0x17, 0xe8, 0xf9, 0x82, 0xb5, 0x77, 0x52, 0x56, 0xa9, 0x3b, 0x12, 0x0f, 0x8b, 0xbb, 0xe6,
		0x56, 0xbe, 0xb9, 0xb8, 0x66, 0x89, 0x04, 0xfc, 0xda, 0x84, 0x82, 0x77, 0x9c, 0xb6, 0x84, 0xa5,
		0x2f, 0x6e, 0xc3, 0xc2, 0xa9, 0xdd, 0xf0, 0x0e, 0xca, 0xb3, 0xf4, 0x67, 0x9c, 0x8a, 0x14, 0xde,
		0x73, 0xee, 0x07, 0xbe, 0x07, 0x7c, 0x6f, 0x76, 0xa3, 0xa8, 0x28, 0xda, 0x0f, 0x41, 0x56, 0x0d,
		0xa9, 0x3f, 0xd1, 0x19, 0x0c, 0xf9, 0x15, 0xfa, 0x5d, 0x66, 0x11, 0xda, 0x79, 0x2d, 0x6f, 0x27,
		0x93, 0x10, 0x9a, 0x41, 0xda, 0x34, 0x83, 0x07, 0x4d, 0x53, 0x24, 0x91, 0xa9, 0x2c, 0x44, 0x25,
		0x7e, 0xf4, 0x4e, 0x9c, 0xd8, 0xb2, 0x91, 0x0d, 0xb8, 0xb3, 0x89, 0x77, 0xb9, 0xd9, 0xad, 0x35,
		0x84, 0xbd, 0x8e, 0xbd, 0x8e, 0xbd, 0x1e, 0x6a, 0xaf, 0x2b, 0xda, 0xa3, 0xa0, 0x48, 0xcf, 0x92,
		0xc2, 0x52, 0x57, 0x6d, 0x46, 0x8a, 0x0d, 0x86, 0x0d, 0x06, 0x33, 0x7b, 0x55, 0x3e, 0x89, 0x7d,
		0xe9, 0x55, 0x56, 0x87, 0x1a, 0x2c, 0xe9, 0x75, 0x4b, 0x9a, 0xc4, 0xce, 0x64, 0x33, 0xa5, 0x9d,
		0x96, 0x93, 0x1f, 0x63, 0xb8, 0x75, 0x80, 0x28, 0x03, 0x0a, 0xb7, 0x8d, 0xc8, 0x1e, 0xa3, 0x07,
		0x7d, 0xbb, 0x48, 0x18, 0x35, 0xe8, 0xd7, 0x25, 0x8a, 0x68, 0x41, 0x6d, 0x62, 0x4a, 0x85, 0xbe,
		0x36, 0x1a, 0xf9, 0xbc, 0xf0, 0x6a, 0xc8, 0xa0, 0xf7, 0xde, 0x38, 0xe2, 0x06, 0xcd, 0xfe, 0x48,
		0x4d, 0x60, 0xd4, 0xa0, 0xfd, 0x5a, 0x91, 0xc5, 0x0c, 0x5e, 0x7f, 0xed, 0xb6, 0x85, 0x4e, 0xfb,
		0xf3, 0xf9, 0x6d, 0xb7, 0x73, 0xfe, 0xe9, 0x6b, 0x97, 0xe0, 0x24, 0x2f, 0x1f, 0x9a, 0x24, 0x44,
		0x12, 0x6e, 0x98, 0x2e, 0x5a, 0x35, 0x20, 0xee, 0x38, 0x42, 0xff, 0xe9, 0x64, 0x63, 0x74, 0x81,
		0x51, 0x84, 0xeb, 0x53, 0x47, 0x99, 0xf4, 0xb9, 0xa9, 0x81, 0x34, 0x20, 0x91, 0x01, 0x0b, 0x24,
		0xad, 0x38, 0xe4, 0xf6, 0x05, 0x14, 0x37, 0x0a, 0x39, 0x18, 0xe8, 0xc2, 0x50, 0x1c, 0xc9, 0x0a,
		0x83, 0x43, 0xd0, 0x4b, 0x9c, 0x05, 0x53, 0x85, 0x70, 0xc1, 0x65, 0xcd, 0x50, 0x21, 0x5b, 0x90,
		0x19, 0x32, 0x53, 0x62, 0x84, 0x01, 0x06, 0x86, 0x29, 0x8c, 0x75, 0xcd, 0xd4, 0xfa, 0x1a, 0x03,
		0x12, 0xb0, 0x44, 0x8d, 0x1d, 0x86, 0x1d, 0x86, 0x1d, 0xb6, 0xf6, 0xcc, 0x91, 0x64, 0xea, 0x72,
		0x9f, 0xa1, 0x80, 0xb9, 0x43, 0x87, 0x5d, 0x85, 0x5d, 0x15, 0xeb, 0xae, 0x9a, 0xc8, 0xaa, 0x79,
		0x58, 0x65, 0xd8, 0x55, 0x47, 0x28, 0x7f, 0xb9, 0x42, 0x8f, 0xf2, 0x97, 0x5c, 0xad, 0x7a, 0x52,
		0x3b, 0x69, 0x1c, 0x55, 0x4f, 0xea, 0xa8, 0x83, 0xb9, 0x6b, 0xf0, 0x97, 0x40, 0x18, 0xd9, 0x98,
		0x97, 0x30, 0x12, 0xc7, 0xf4, 0xf2, 0x68, 0x41, 0x0a, 0x91, 0x04, 0x91, 0x14, 0xab, 0x48, 0x8a,
		0xbb, 0x1c, 0x87, 0x3e, 0x12, 0xc7, 0x4d, 0x2f, 0x48, 0x3c, 0x12, 0xc7, 0xce, 0x45, 0x07, 0xae,
		0xba, 0x6c, 0xdd, 0x08, 0xb7, 0xed, 0xae, 0xcf, 0x25, 0xa7, 0x4a, 0x87, 0x7d, 0x9d, 0xa2, 0x4a,
		0x07, 0xe1, 0x00, 0x52, 0x55, 0xcf, 0xf0, 0x4a, 0x40, 0xba, 0x2a, 0x1a, 0x5e, 0x01, 0xe0, 0xad,
		0xa6, 0x41, 0x41, 0x49, 0x55, 0x42, 0x23, 0x5a, 0x0e, 0x67, 0xe8, 0xfd, 0x10, 0x06, 0xed, 0x12,
		0x35, 0xf8, 0x1c, 0xf8, 0x1c, 0x0c, 0xda, 0xb5, 0x67, 0xa2, 0x96, 0x36, 0x76, 0x56, 0xea, 0x8c,
		0x5a, 0x95, 0xf1, 0x54, 0xae, 0x13, 0x0a, 0x1a, 0xf7, 0xf5, 0xee, 0x62, 0x3b, 0x2a, 0x9f, 0x96,
		0x5d, 0xac, 0xb3, 0x8d, 0x7d, 0x1c, 0x90, 0x3f, 0x70, 0xa3, 0x3e, 0x77, 0x7d, 0x78, 0xfb, 0x41,
		0x5c, 0xf3, 0x40, 0xaf, 0x9e, 0x86, 0x51, 0x53, 0xd7, 0xd5, 0xd5, 0xc8, 0x8b, 0xb7, 0xef, 0xd1,
		0x86, 0x8d, 0xa2, 0x1c, 0xdd, 0x4c, 0xcc, 0x70, 0x5e, 0x6d, 0x8e, 0xf3, 0xfa, 0x2a, 0x38, 0x72,
		0xcf, 0x20, 0x6a, 0xd6, 0x05, 0xab, 0xdc, 0xbe, 0x31, 0x40, 0x9e, 0xe8, 0x1a, 0xbf, 0x4b, 0xeb,
		0x8e, 0xff, 0x12, 0x5b, 0x2c, 0x00, 0xb7, 0x29, 0x90, 0xc8, 0x7a, 0xda, 0xa9, 0xfd, 0x30, 0x61,
		0xed, 0x82, 0xcf, 0xa3, 0x36, 0x3d, 0x3d, 0x05, 0x11, 0x65, 0xd4, 0x43, 0x4d, 0x1b, 0x66, 0x46,
		0x37, 0x94, 0xfb, 0x8c, 0x3c, 0xdb, 0x3e, 0x14, 0xa4, 0x31, 0x68, 0x5b, 0xfa, 0x4b, 0x1b, 0x8b,
		0xe6, 0x87, 0xb5, 0xf9, 0x06, 0xa2, 0xad, 0x23, 0x6b, 0xbb, 0x89, 0x42, 0xf3, 0x47, 0xf0, 0xf6,
		0x1d, 0x84, 0x66, 0xbd, 0x55, 0xb4, 0x31, 0x68, 0x97, 0xad, 0x1b, 0xd2, 0xd0, 0x33, 0xeb, 0xd6,
		0x24, 0x44, 0x9c, 0x6d, 0x07, 0x57, 0x93, 0x1a, 0x70, 0xe6, 0x3b, 0x75, 0x6c, 0x6c, 0x90, 0x30,
		0xde, 0xec, 0xb2, 0x75, 0xc3, 0x14, 0x66, 0x36, 0xa7, 0x4b, 0x43, 0x74, 0x19, 0x19, 0xd2, 0x9e,
		0xb6, 0xe0, 0xb2, 0xad, 0x8b, 0x25, 0x1a, 0x2d, 0x90, 0xa2, 0x82, 0x9d, 0xa2, 0x08, 0x21, 0x3c,
		0x22, 0x2b, 0xf4, 0x59, 0x00, 0x35, 0xc8, 0xfb, 0x91, 0x25, 0x4c, 0x83, 0x68, 0x51, 0xbe, 0x71,
		0xa7, 0x48, 0xb1, 0x58, 0x72, 0xfe, 0xb7, 0xec, 0x02, 0xf1, 0xf1, 0x7e, 0xc4, 0x7d, 0xa8, 0xc0,
		0x48, 0x34, 0xfb, 0x4f, 0x82, 0x68, 0x08, 0xae, 0x2e, 0x48, 0x1b, 0x67, 0xb3, 0x44, 0x8e, 0x4d,
		0x8c, 0x4d, 0x9c, 0xdd, 0x4d, 0x5c, 0xd2, 0xc7, 0x9a, 0x62, 0x48, 0xa6, 0xe1, 0xf1, 0x6e, 0xca,
		0xea, 0x63, 0x61, 0xac, 0x29, 0x72, 0xff, 0x57, 0xc1, 0xfa, 0x65, 0x71, 0x4b, 0xeb, 0x56, 0xb8,
		0x69, 0x75, 0xff, 0x74, 0x3c, 0x9d, 0x3e, 0x17, 0x5d, 0x5f, 0xe7, 0xec, 0x97, 0xfd, 0x6c, 0x7b,
		0xcb, 0xae, 0x9b, 0xa8, 0xb2, 0xf9, 0x8b, 0x75, 0xe3, 0x2f, 0x1a, 0xc0, 0xd6, 0xc7, 0xd6, 0xc7,
		0xd6, 0xb7, 0x6f, 0x39, 0xbd, 0xbe, 0xbc, 0xfc, 0x7a, 0x75, 0xde, 0xfd, 0xf7, 0xf2, 0xe6, 0x5f,
		0xba, 0x9c, 0x88, 0xed, 0x2f, 0xfd, 0x34, 0xc3, 0xb3, 0x80, 0xe5, 0x46, 0xc0, 0x06, 0xc0, 0x06,
		0xc0, 0x06, 0xec, 0x5b, 0xda, 0x7f, 0x77, 0xdb, 0x57, 0x9f, 0xdb, 0x9f, 0x85, 0x0d, 0xfc, 0xc0,
		0xff, 0xf7, 0x44, 0x30, 0x06, 0x59, 0x35, 0x25, 0x7d, 0x28, 0xf6, 0x25, 0x56, 0xa6, 0xb0, 0x68,
		0x00, 0x0c, 0x01, 0x0c, 0x21, 0x46, 0x86, 0x30, 0xf7, 0x06, 0x14, 0x64, 0xd5, 0x1c, 0x66, 0x2d,
		0x66, 0x61, 0xdf, 0xbe, 0xf2, 0x5d, 0x9d, 0xb4, 0x46, 0xb9, 0x3e, 0x32, 0x30, 0x92, 0xb1, 0x1d,
		0x3d, 0x19, 0xff, 0xd0, 0xa6, 0x34, 0xb0, 0xe6, 0x9b, 0x22, 0xaa, 0xf9, 0xbb, 0x72, 0xe1, 0xa4,
		0xf7, 0x52, 0x39, 0x38, 0x9c, 0xbe, 0xde, 0x55, 0x0a, 0x87, 0x3d, 0xe7, 0xbb, 0xf5, 0xad, 0xd6,
		0xbb, 0x2b, 0x5b, 0x5f, 0x8f, 0x9d, 0x6b, 0xb3, 0x0b, 0x27, 0xd6, 0xd7, 0x5a, 0x8f, 0xdf, 0x79,
		0x3c, 0x4e, 0x22, 0x13, 0x22, 0x5c, 0x61, 0x3f, 0x7e, 0x6e, 0x08, 0x8e, 0xc4, 0x12, 0x0c, 0xc9,
		0x64, 0xd6, 0x19, 0x56, 0x9a, 0x81, 0xe6, 0x00, 0xcd, 0x01, 0xa6, 0x84, 0x7d, 0xcb, 0x4d, 0xa7,
		0x7d, 0x76, 0xfe, 0xf7, 0xb2, 0xf9, 0xb0, 0xb8, 0x96, 0x08, 0x93, 0x41, 0xd1, 0xfa, 0xa2, 0x62,
		0x6f, 0x5f, 0xd6, 0xfd, 0xef, 0x69, 0x01, 0x5b, 0x1f, 0x5b, 0x3f, 0xc6, 0xad, 0x8f, 0xa4, 0xdd,
		0x85, 0x16, 0x84, 0xa4, 0x5d, 0x24, 0xed, 0x32, 0x68, 0x9d, 0x49, 0xd7, 0x51, 0x47, 0xd2, 0x80,
		0x55, 0x2e, 0x59, 0xa4, 0x10, 0x48, 0x10, 0x48, 0x10, 0x48, 0x10, 0x48, 0x10, 0x48, 0x10, 0x48,
		0xd1, 0x08, 0x24, 0x55, 0x92, 0x1f, 0x9f, 0x1e, 0x34, 0x9d, 0x55, 0x2a, 0xcd, 0xe9, 0x21, 0x9a,
		0x20, 0x9a, 0xe2, 0x14, 0x4d, 0x59, 0xcc, 0x05, 0x95, 0xc7, 0x05, 0x71, 0x30, 0xd0, 0x25, 0xc3,
		0x08, 0x03, 0x5b, 0x9f, 0x30, 0xd0, 0x32, 0xf5, 0x94, 0xbd, 0xc7, 0x3e, 0x3d, 0x7f, 0xae, 0x85,
		0xe8, 0xfb, 0xda, 0x18, 0x1c, 0x87, 0x68, 0x23, 0x2c, 0x84, 0x3f, 0x6f, 0x28, 0x9f, 0x77, 0x31,
		0xfa, 0x4a, 0xe1, 0xc4, 0x85, 0xeb, 0x2b, 0xf6, 0x3f, 0xce, 0xe7, 0xaa, 0x0d, 0xd9, 0xbb, 0x9f,
		0xeb, 0x77, 0xe5, 0x42, 0xbd, 0xc7, 0xdf, 0xdf, 0x17, 0xf9, 0x97, 0xc3, 0x29, 0x3d, 0x61, 0xfe,
		0xf7, 0xbb, 0xfb, 0xfb, 0xf1, 0xcb, 0xd5, 0xd4, 0xfa, 0x7b, 0x31, 0xed, 0x7d, 0xe0, 0x3f, 0xe6,
		0x98, 0xdf, 0xbe, 0xc7, 0x44, 0x39, 0x3d, 0xd8, 0xe3, 0xea, 0x69, 0x64, 0x70, 0xf5, 0x34, 0x5f,
		0xad, 0x39, 0x16, 0x0b, 0xc3, 0x56, 0xe1, 0xac, 0xf7, 0x52, 0x3e, 0xa8, 0x4d, 0xf9, 0x26, 0x9f,
		0x5f, 0xbd, 0xd6, 0xe4, 0x5f, 0xca, 0x07, 0xf5, 0x69, 0x3e, 0xef, 0xf3, 0xcb, 0x47, 0xbf, 0x36,
		0xf8, 0xd7, 0x7c, 0x3e, 0xef, 0xae, 0x9b, 0xa5, 0xb5, 0x74, 0x57, 0xae, 0xf4, 0x3e, 0xda, 0x1f,
		0x9d, 0xbf, 0xf3, 0xd5, 0x48, 0x74, 0x33, 0xef, 0xbb, 0x06, 0x0f, 0x42, 0x6f, 0xa1, 0xff, 0x36,
		0x7b, 0x1f, 0x9a, 0xfc, 0x4b, 0x63, 0x3a, 0xfb, 0x6c, 0xff, 0xe5, 0x5f, 0xf3, 0xc5, 0xf7, 0xf7,
		0xf7, 0xc5, 0xe2, 0x7b, 0xde, 0xe9, 0x90, 0x7b, 0xdf, 0x7b, 0xe7, 0xd7, 0x8f, 0xcd, 0xe6, 0xda,
		0x25, 0x3e, 0xff, 0x7b, 0x71, 0x1f, 0xdb, 0x02, 0x29, 0xf2, 0x70, 0xfb, 0x27, 0x6c, 0x24, 0xe1,
		0xf6, 0x8f, 0x96, 0xfb, 0xc3, 0xed, 0x4f, 0x69, 0xc1, 0xa2, 0x58, 0x5a, 0xf4, 0x86, 0xfc, 0x4f,
		0x53, 0x78, 0xd2, 0xc6, 0x61, 0x42, 0x1f, 0x96, 0xda, 0x80, 0x41, 0x0f, 0x83, 0x3e, 0x46, 0x83,
		0x1e, 0x71, 0x0f, 0xa1, 0xb6, 0xbf, 0xa6, 0xcb, 0x8f, 0x14, 0xf8, 0xf6, 0xca, 0xc6, 0x77, 0xa9,
		0xb1, 0xe5, 0xb1, 0xe5, 0x63, 0xdc, 0xf2, 0x29, 0x29, 0xfd, 0x6f, 0xef, 0x90, 0xf0, 0x71, 0x85,
		0x08, 0x29, 0xc4, 0x3e, 0x83, 0x68, 0x4d, 0xa1, 0x68, 0x65, 0x2f, 0x44, 0xbc, 0x42, 0x8f, 0x6d,
		0x8f, 0x6d, 0x0f, 0xf1, 0xea, 0xbb, 0xc7, 0x0c, 0xbd, 0x2f, 0x3c, 0xeb, 0xcc, 0x31, 0xbb, 0x33,
		0x72, 0xec, 0x30, 0xec, 0xb0, 0x18, 0x77, 0x18, 0x0a, 0x12, 0x27, 0x07, 0x40, 0x45, 0x41, 0xe2,
		0x50, 0xda, 0xdb, 0xba, 0x16, 0x97, 0xa5, 0x82, 0xc4, 0xc4, 0x72, 0xc8, 0x14, 0x1f, 0x59, 0x65,
		0x90, 0x45, 0x0a, 0xf9, 0x03, 0xf9, 0x13, 0xa7, 0xfc, 0x41, 0x7c, 0xee, 0x8c, 0x18, 0xf1, 0xb9,
		0x88, 0xcf, 0x65, 0x11, 0x31, 0x1c, 0xbc, 0x9b, 0x04, 0x94, 0x7b, 0xf4, 0x6e, 0xb2, 0x1d, 0x52,
		0x93, 0x99, 0x03, 0x6a, 0x20, 0x8d, 0x81, 0xb7, 0x44, 0xba, 0x9f, 0x9c, 0x52, 0xc7, 0xda, 0x58,
		0xd2, 0xc9, 0x0f, 0x87, 0xe0, 0xd6, 0x8f, 0x90, 0x5c, 0x34, 0x80, 0x5d, 0x86, 0x5d, 0x16, 0xe3,
		0x2e, 0x5b, 0xf1, 0x26, 0x38, 0x1a, 0x47, 0xc1, 0xb4, 0xda, 0x63, 0xd8, 0x79, 0x35, 0x0a, 0x9a,
		0xb6, 0x3a, 0x19, 0xd1, 0xcf, 0x79, 0x57, 0xbb, 0x75, 0xf8, 0x02, 0x8b, 0x7e, 0x96, 0x2b, 0xdb,
		0x6b, 0x45, 0xd2, 0x47, 0xb2, 0xc9, 0x02, 0x04, 0x54, 0xec, 0xf3, 0xfd, 0x25, 0xf5, 0xd7, 0x4e,
		0xa3, 0xf5, 0x72, 0x5d, 0xed, 0x5c, 0x35, 0xd9, 0x3a, 0x68, 0xbf, 0x1c, 0x95, 0x32, 0x32, 0x27,
		0x75, 0x87, 0xa5, 0xc9, 0x95, 0x77, 0xa4, 0xed, 0x4d, 0xe3, 0x3c, 0xf1, 0x52, 0x32, 0x05, 0xd1,
		0x60, 0x60, 0xc7, 0x33, 0x42, 0xb0, 0x61, 0xb0, 0x61, 0x40, 0x0f, 0x80, 0x1e, 0x00, 0x3d, 0x20,
		0x35, 0x38, 0x22, 0x61, 0x24, 0x28, 0xb2, 0x61, 0x32, 0x4b, 0x24, 0x87, 0x1a, 0x62, 0x09, 0x62,
		0x09, 0x36, 0xb8, 0xcf, 0xfe, 0x9a, 0xd7, 0x2a, 0x17, 0x64, 0x55, 0x91, 0x55, 0x89, 0x6d, 0x9f,
		0xad, 0xb5, 0x82, 0xfd, 0x86, 0xfd, 0x96, 0xa5, 0xfd, 0x96, 0x0e, 0x28, 0x9d, 0xe9, 0xbc, 0xd7,
		0x79, 0x63, 0x7b, 0x44, 0xd7, 0x97, 0x79, 0x08, 0x53, 0xd5, 0xc4, 0xf5, 0x26, 0xc0, 0x83, 0xc0,
		0x83, 0x62, 0xe4, 0x41, 0x38, 0x83, 0x25, 0x34, 0x0b, 0x58, 0x3a, 0x3c, 0x25, 0x94, 0x42, 0xe2,
		0xdb, 0x12, 0x18, 0x02, 0x18, 0x02, 0x94, 0x12, 0x28, 0x25, 0xcc, 0x1c, 0x89, 0x59, 0x31, 0x59,
		0x6f, 0x06, 0xbc, 0x08, 0xbc, 0x08, 0xca, 0x49, 0x7a, 0x4f, 0x86, 0xb2, 0x76, 0xb5, 0x7d, 0x44,
		0xc3, 0xbc, 0x58, 0xc1, 0xa3, 0xa2, 0x3d, 0x88, 0x0a, 0x1b, 0x7f, 0xf0, 0x6d, 0x09, 0x2c, 0x02,
		0x2c, 0x02, 0x98, 0x65, 0xe0, 0xbe, 0xb3, 0x26, 0x5c, 0xd2, 0x23, 0xdc, 0x7e, 0xcb, 0x0d, 0x62,
		0x17, 0x62, 0x17, 0xc6, 0xb8, 0x0b, 0x1f, 0x34, 0x4d, 0x91, 0x44, 0xa6, 0x6c, 0xae, 0x4a, 0xcc,
		0xdb, 0x30, 0xcc, 0x19, 0x27, 0x2b, 0xf4, 0xd8, 0x64, 0xd8, 0x64, 0x31, 0x6e, 0x32, 0x44, 0x8d,
		0xcc, 0x89, 0x11, 0x35, 0x82, 0xa8, 0x11, 0xda, 0x0d, 0x4a, 0x7f, 0x77, 0xdc, 0x51, 0x23, 0x4c,
		0xe7, 0x9b, 0xcc, 0x08, 0x21, 0x8c, 0x20, 0x8c, 0x20, 0x8c, 0x20, 0x8c, 0x20, 0x8c, 0x20, 0x8c,
		0xa2, 0x11, 0x46, 0xa6, 0x2e, 0xf7, 0x59, 0xe5, 0x91, 0x4d, 0x0b, 0x91, 0x04, 0x91, 0x04, 0x91,
		0x04, 0x91, 0x04, 0x91, 0x04, 0x91, 0x14, 0x9d, 0x48, 0x12, 0x9c, 0x61, 0x0d, 0x23, 0x99, 0x66,
		0x4d, 0x40, 0x40, 0x41, 0x40, 0xc5, 0x28, 0xa0, 0x9c, 0xc5, 0xf7, 0x26, 0xb2, 0x6e, 0x2f, 0xdb,
		0xdd, 0xce, 0xf9, 0xa9, 0xed, 0xf1, 0xfe, 0xd6, 0xba, 0xf8, 0xda, 0x66, 0xce, 0xbf, 0x75, 0x1b,
		0x6a, 0x7d, 0xfe, 0xcc, 0xde, 0x50, 0xd5, 0xfb, 0x46, 0x5f, 0x3f, 0x75, 0x3b, 0xad, 0xd3, 0x10,
		0xaf, 0x75, 0xb8, 0xd2, 0xbf, 0x4e, 0xb7, 0xcb, 0xd2, 0x4c, 0x6d, 0xa5, 0x77, 0x8c, 0xcd, 0xd4,
		0xfd, 0xfa, 0x66, 0xb5, 0x95, 0xd4, 0x9c, 0xe5, 0x95, 0x2e, 0x37, 0xb9, 0xda, 0x41, 0xa8, 0x46,
		0x9c, 0x79, 0x64, 0x4b, 0x82, 0x5e, 0x99, 0xc5, 0x26, 0x77, 0x18, 0xae, 0x91, 0xd9, 0xbb, 0x94,
		0x43, 0x34, 0xe3, 0x9d, 0xc3, 0x26, 0x57, 0x8f, 0xa0, 0xa5, 0xd9, 0x5b, 0x55, 0x33, 0x92, 0xe9,
		0x3d, 0x73, 0x79, 0xb3, 0x69, 0x00, 0x73, 0x6a, 0x08, 0x7f, 0x08, 0xff, 0x18, 0x85, 0x7f, 0x7a,
		0x02, 0x55, 0x58, 0x4f, 0xc3, 0xf0, 0xd0, 0x62, 0x6f, 0x61, 0x6f, 0x61, 0x6f, 0xf9, 0xec, 0x2d,
		0x5d, 0x1a, 0x4b, 0x62, 0x88, 0x62, 0x25, 0x1e, 0x7a, 0xec, 0x31, 0xec, 0xb1, 0x98, 0xd1, 0xd5,
		0x63, 0x86, 0x2d, 0x56, 0x07, 0xb8, 0x0a, 0x70, 0x75, 0x75, 0xe8, 0xaa, 0x75, 0xa0, 0xaa, 0x49,
		0x41, 0x55, 0x99, 0xaa, 0x76, 0xcf, 0x08, 0x21, 0x84, 0x20, 0x84, 0x62, 0x16, 0x42, 0x70, 0xf1,
		0x41, 0x0a, 0xc1, 0xc5, 0x97, 0x45, 0x61, 0x64, 0x8e, 0x4c, 0x81, 0xad, 0x62, 0xf5, 0x82, 0x14,
		0x02, 0x09, 0x02, 0x29, 0x66, 0x81, 0x54, 0x69, 0x30, 0x08, 0xa4, 0x46, 0x66, 0x05, 0x52, 0x05,
		0x02, 0x89, 0x75, 0xe8, 0x1a, 0xf5, 0xfa, 0x21, 0x64, 0xd1, 0xce, 0x65, 0xd1, 0x6f, 0x21, 0x26,
		0xdf, 0xe2, 0x9a, 0xb3, 0x33, 0x12, 0x38, 0x52, 0xb1, 0x43, 0x57, 0xcc, 0x82, 0xbe, 0x88, 0x45,
		0x24, 0xc5, 0x2b, 0xe8, 0x8a, 0x56, 0x04, 0x0d, 0x53, 0x4b, 0x55, 0x35, 0x93, 0xbc, 0x48, 0x7e,
		0xce, 0xe8, 0x3f, 0x49, 0x23, 0x71, 0x3c, 0xcb, 0xc4, 0x5f, 0x24, 0xe0, 0x4b, 0x85, 0x91, 0x38,
		0x5e, 0xfb, 0xde, 0xb9, 0xfe, 0xda, 0x6d, 0x0b, 0x97, 0xad, 0x9b, 0xc5, 0x27, 0x3b, 0xb5, 0x3e,
		0x47, 0xa4, 0x67, 0xe8, 0x93, 0xbe, 0xe9, 0x2a, 0x1a, 0xb9, 0x5b, 0xab, 0xe5, 0x8e, 0xd5, 0xf0,
		0xa5, 0x38, 0x16, 0x96, 0xbf, 0x2d, 0xda, 0x5e, 0x79, 0xca, 0x6f, 0x6c, 0xeb, 0xcb, 0xff, 0x97,
		0x0d, 0x43, 0x49, 0x3a, 0x84, 0xcc, 0x43, 0xb7, 0x65, 0xac, 0x58, 0xc6, 0xc8, 0x7f, 0x50, 0xd6,
		0xbb, 0xec, 0xd3, 0xdd, 0xdc, 0x62, 0x78, 0x6f, 0xdb, 0xdd, 0x8d, 0xbd, 0x9d, 0x4b, 0xdd, 0xe5,
		0xdb, 0x37, 0x0c, 0xdf, 0x0c, 0xe2, 0xdf, 0xf0, 0x73, 0x90, 0x4a, 0x47, 0xa2, 0xc2, 0x91, 0xaa,
		0x6c, 0xa4, 0x2a, 0x1a, 0xb5, 0x4a, 0x46, 0xad, 0x82, 0x51, 0xa8, 0x5c, 0x74, 0x8b, 0xf5, 0xb3,
		0xbc, 0x9d, 0xb9, 0x2d, 0xcf, 0x99, 0xb3, 0x8b, 0x02, 0x87, 0xc3, 0x77, 0xbe, 0x49, 0xf6, 0x79,
		0xc0, 0xe4, 0x53, 0xeb, 0xf5, 0x34, 0xfa, 0x3c, 0xad, 0x1e, 0x4f, 0xab, 0xbf, 0x33, 0xeb, 0xed,
		0xcc, 0xfa, 0x3a, 0x83, 0x9e, 0x1e, 0x4e, 0xc6, 0x06, 0x2d, 0xa6, 0xf9, 0x8d, 0x38, 0xdf, 0x08,
		0x86, 0x62, 0x3a, 0x0c, 0xc5, 0x04, 0xb8, 0xa8, 0xa3, 0x52, 0x7b, 0xa1, 0xec, 0xee, 0x4b, 0xd9,
		0xb5, 0x2b, 0x4c, 0x51, 0x0b, 0x43, 0x66, 0xa5, 0xd7, 0x8e, 0x8b, 0x5c, 0x7f, 0x5a, 0x26, 0x94,
		0xdf, 0x2d, 0x9a, 0x63, 0x98, 0xf1, 0x22, 0x56, 0x82, 0x7f, 0xdb, 0x32, 0x08, 0x41, 0x9d, 0xa7,
		0xec, 0xb4, 0x4f, 0x37, 0xc9, 0xbb, 0xb7, 0xdc, 0xa1, 0xc5, 0x6b, 0x7b, 0x5e, 0x39, 0xb7, 0xb1,
		0x5a, 0xda, 0xda, 0xdb, 0x2f, 0xd8, 0xe1, 0x46, 0x92, 0x95, 0xa1, 0xf0, 0x57, 0xe4, 0x36, 0xca,
		0xd9, 0x6d, 0xf2, 0x74, 0x21, 0x37, 0xdd, 0xf2, 0x6b, 0x7e, 0x03, 0x13, 0x20, 0x23, 0x89, 0x65,
		0x21, 0xb1, 0xcc, 0x5b, 0x96, 0x6d, 0xb3, 0x37, 0xa3, 0x5c, 0x30, 0x9b, 0x14, 0xa6, 0x5c, 0xeb,
		0x56, 0xb8, 0x69, 0x75, 0xff, 0x24, 0x33, 0xab, 0xbc, 0x37, 0x27, 0xc1, 0xa8, 0xda, 0x3c, 0x4d,
		0x49, 0x37, 0xac, 0x36, 0x4e, 0xe3, 0x8e, 0x8c, 0x2b, 0xcf, 0xcc, 0x51, 0x9a, 0x56, 0x6b, 0x94,
		0x69, 0x30, 0xac, 0x82, 0x17, 0x46, 0x5a, 0x8d, 0xab, 0xc0, 0x85, 0x13, 0xb3, 0x81, 0xc5, 0x9a,
		0x6b, 0x97, 0xa1, 0x04, 0x3b, 0xf2, 0xc5, 0x96, 0x35, 0x43, 0x8b, 0x78, 0x31, 0x26, 0xcd, 0xd8,
		0xc2, 0x31, 0x97, 0x14, 0xe4, 0x38, 0xe6, 0x32, 0x8c, 0x53, 0x2a, 0xce, 0xe4, 0x27, 0xd1, 0x10,
		0x2c, 0x9d, 0x5f, 0x70, 0x12, 0x99, 0x47, 0x0f, 0x92, 0xce, 0xc0, 0x98, 0xd7, 0xdb, 0x00, 0x93,
		0x06, 0x93, 0xce, 0x22, 0x22, 0x86, 0x83, 0x06, 0x76, 0xca, 0x8d, 0xde, 0x38, 0xf6, 0x0e, 0x8e,
		0x03, 0x8e, 0x03, 0x0c, 0x3e, 0x83, 0x18, 0xfc, 0xea, 0x89, 0x0f, 0x9b, 0x7f, 0xf1, 0x60, 0x27,
		0x25, 0x4a, 0x1c, 0x65, 0x1b, 0x08, 0x2b, 0xab, 0x8f, 0x37, 0xf6, 0x53, 0x6e, 0x25, 0xd3, 0x10,
		0x36, 0x5c, 0xf6, 0x3e, 0x6f, 0xed, 0xd9, 0xe9, 0x40, 0xe8, 0x99, 0x06, 0x9a, 0x01, 0xb3, 0xa7,
		0x1d, 0xcf, 0x30, 0x81, 0x2c, 0x4b, 0x87, 0x7d, 0x04, 0x23, 0xae, 0xcb, 0xb7, 0x03, 0x73, 0x4d,
		0x13, 0xe6, 0xba, 0x7e, 0xae, 0x0b, 0x39, 0xea, 0xea, 0x43, 0x0b, 0xdc, 0x15, 0xb8, 0x2b, 0x70,
		0x57, 0x28, 0xd8, 0xc0, 0x5d, 0x81, 0xbb, 0x02, 0x77, 0x4d, 0x14, 0xee, 0xba, 0x38, 0x03, 0x91,
		0x15, 0x75, 0x5d, 0x6b, 0x01, 0x0c, 0x1a, 0x0c, 0x1a, 0x98, 0x2b, 0x30, 0x57, 0x4a, 0x4e, 0x34,
		0x12, 0xcd, 0xfe, 0x13, 0x73, 0x01, 0xdc, 0x25, 0x6a, 0x70, 0x20, 0x70, 0xa0, 0x3d, 0x70, 0x20,
		0x49, 0x9d, 0x8c, 0x24, 0x5d, 0xa4, 0x58, 0x82, 0xe9, 0xd3, 0x09, 0x5b, 0x57, 0xff, 0x66, 0x56,
		0x08, 0x5b, 0x17, 0x17, 0x89, 0xd5, 0x07, 0xad, 0x77, 0x63, 0x53, 0x07, 0xad, 0x11, 0xc9, 0x86,
		0x2e, 0x08, 0xaf, 0x17, 0x38, 0x2e, 0x74, 0xbe, 0xe8, 0xf7, 0x95, 0x5d, 0x50, 0x8a, 0xa6, 0x8f,
		0xcb, 0xa5, 0xa8, 0xc8, 0x21, 0x06, 0xec, 0x2f, 0xec, 0x2f, 0x68, 0x34, 0x94, 0x1a, 0xcd, 0x6d,
		0xb7, 0x75, 0xf5, 0xb9, 0xd5, 0xf9, 0xcc, 0xac, 0xd6, 0xb4, 0xff, 0xbe, 0x69, 0x5d, 0x7d, 0x6e,
		0x7f, 0x4e, 0xac, 0x6e, 0x33, 0x7f, 0x41, 0x36, 0x05, 0x67, 0x3e, 0x40, 0x29, 0xd0, 0x72, 0x10,
		0x83, 0xc0, 0x6a, 0xcc, 0x27, 0x30, 0x06, 0x61, 0xc9, 0x93, 0x58, 0xa2, 0xf6, 0x2b, 0x72, 0x61,
		0xfd, 0xe6, 0xcb, 0x4f, 0xf4, 0x79, 0x7e, 0xd6, 0x62, 0x11, 0x48, 0x5c, 0xf6, 0xd1, 0x8e, 0x6a,
		0x98, 0x78, 0x84, 0xf6, 0xdf, 0xdd, 0xb6, 0xc5, 0xd6, 0x04, 0xca, 0xc0, 0x84, 0x0d, 0x74, 0x88,
		0x50, 0x48, 0x53, 0x84, 0x82, 0xff, 0x24, 0x52, 0x86, 0x2a, 0x6c, 0x6b, 0x04, 0x31, 0x0b, 0x88,
		0x59, 0x58, 0xdc, 0x88, 0x98, 0x05, 0x98, 0x6f, 0x88, 0x59, 0x40, 0xcc, 0xc2, 0x5e, 0xed, 0x38,
		0xc4, 0x2c, 0x38, 0x9d, 0x41, 0xcc, 0x02, 0x18, 0x34, 0xf0, 0xeb, 0x28, 0x7b, 0x80, 0x98, 0x05,
		0x36, 0x4e, 0x84, 0x98, 0x05, 0x70, 0x20, 0x20, 0xfc, 0x49, 0xd7, 0x09, 0x11, 0xb3, 0xb0, 0x46,
		0x89, 0x98, 0x05, 0xf8, 0x54, 0xc1, 0x71, 0xb3, 0xa9, 0xf3, 0x21, 0x66, 0x01, 0xfb, 0x0b, 0x1a,
		0x0d, 0x62, 0x16, 0xb6, 0xa9, 0x35, 0x88, 0x59, 0x48, 0x8e, 0x96, 0x83, 0x98, 0x05, 0x56, 0x63,
		0x3e, 0x81, 0x31, 0x0b, 0xfe, 0x2e, 0xc5, 0x12, 0xbb, 0xa7, 0x91, 0x0b, 0xeb, 0x6f, 0xdf, 0xf0,
		0xe8, 0x6d, 0x6f, 0x94, 0xb5, 0xb8, 0x06, 0x2a, 0x8f, 0xff, 0x8e, 0x06, 0x3c, 0x4c, 0xa4, 0xc3,
		0x4d, 0xa7, 0x7d, 0x76, 0xfe, 0x77, 0x70, 0x64, 0x83, 0x7b, 0x1f, 0x22, 0x19, 0xd2, 0x14, 0xc9,
		0xe0, 0x4c, 0x1a, 0x65, 0xe4, 0x82, 0x97, 0x08, 0x91, 0x0a, 0x88, 0x54, 0x58, 0xdc, 0x88, 0x48,
		0x05, 0x18, 0x6d, 0x88, 0x54, 0x40, 0xa4, 0xc2, 0x5e, 0xad, 0x37, 0x44, 0x2a, 0x38, 0x9d, 0x91,
		0xc7, 0xc2, 0x98, 0x8e, 0x93, 0xcd, 0x77, 0xc4, 0x82, 0x14, 0x2c, 0x19, 0x2c, 0x79, 0x0f, 0x2c,
		0x59, 0x1e, 0x17, 0xa8, 0xc7, 0x6f, 0xce, 0x81, 0x4f, 0x28, 0x68, 0xdc, 0x57, 0xdc, 0xf9, 0x09,
		0xc0, 0x8b, 0x8e, 0x3d, 0xd7, 0x0a, 0x4c, 0x4b, 0x63, 0x19, 0x8d, 0x67, 0xa0, 0xbd, 0x11, 0x4d,
		0x53, 0xd2, 0x55, 0xea, 0xde, 0xce, 0x1b, 0xc8, 0xe7, 0xef, 0xca, 0x85, 0x93, 0xde, 0xeb, 0x5d,
		0xa5, 0x70, 0xd2, 0x73, 0x3e, 0x56, 0xec, 0x7f, 0x9c, 0xcf, 0xd5, 0xbb, 0x72, 0xa1, 0x36, 0xfb,
		0x5c, 0xbf, 0x2b, 0x17, 0xea, 0x3d, 0xfe, 0xfe, 0xbe, 0xc8, 0xbf, 0x1c, 0x4e, 0xe9, 0x09, 0x4b,
		0xee, 0xc3, 0xf8, 0xd7, 0xfc, 0x5d, 0xa5, 0x50, 0xed, 0xcd, 0xbe, 0x1c, 0xde, 0x95, 0x0b, 0xd5,
		0x1e, 0xcf, 0xe7, 0xa8, 0xbb, 0xd0, 0xdb, 0xa5, 0xbc, 0x0a, 0xb7, 0x22, 0x1a, 0xe9, 0x5d, 0x11,
		0xcd, 0x57, 0x6b, 0x66, 0xc4, 0xc2, 0xb0, 0x55, 0x38, 0xeb, 0xbd, 0x94, 0x0f, 0x6a, 0x53, 0xbe,
		0xc9, 0xe7, 0x57, 0xaf, 0x35, 0xf9, 0x97, 0xf2, 0x41, 0x7d, 0x9a, 0xcf, 0xfb, 0xfc, 0xf2, 0xd1,
		0xaf, 0x0d, 0xfe, 0x35, 0x9f, 0xcf, 0xbb, 0x6b, 0x61, 0x69, 0x7d, 0xdc, 0x95, 0x2b, 0xbd, 0x8f,
		0xf6, 0x47, 0xe7, 0xef, 0x7c, 0x85, 0x11, 0xdd, 0xcc, 0xf3, 0x79, 0xef, 0xc2, 0xb2, 0xfe, 0x7d,
		0xa9, 0x4e, 0xf9, 0xd7, 0xbc, 0xb5, 0x1c, 0x2b, 0xf3, 0x45, 0x56, 0xb1, 0x1a, 0x39, 0xb6, 0x6e,
		0xcf, 0x1d, 0x30, 0x6f, 0x95, 0xff, 0x36, 0x7b, 0x1f, 0x9a, 0xfc, 0x4b, 0x63, 0x3a, 0xfb, 0x6c,
		0xff, 0xe5, 0x5f, 0xf3, 0xc5, 0xf7, 0xf7, 0xf7, 0xc5, 0xe2, 0x7b, 0xde, 0xe9, 0xa4, 0x7b, 0xdf,
		0x7b, 0xe7, 0xd7, 0x8f, 0xcd, 0xe6, 0xda, 0x25, 0x3e, 0x5f, 0x2a, 0x7e, 0xd8, 0xfd, 0x82, 0x8f,
		0xff, 0xb8, 0x68, 0xa2, 0x18, 0x27, 0xe3, 0xbb, 0x22, 0xa9, 0x8f, 0xe6, 0x93, 0xa0, 0xbb, 0x87,
		0xb5, 0x53, 0xc7, 0x39, 0xad, 0xb4, 0x00, 0x8d, 0x06, 0x1a, 0xcd, 0x1e, 0x34, 0x9a, 0x74, 0x78,
		0xde, 0x11, 0xd1, 0x82, 0x7d, 0x95, 0xae, 0x7d, 0xa5, 0x48, 0xe2, 0x50, 0x97, 0x86, 0x2c, 0x1b,
		0xeb, 0x88, 0x82, 0xe6, 0xc6, 0x75, 0x01, 0x15, 0x8b, 0x25, 0xe7, 0x7f, 0x2e, 0x08, 0x7e, 0xdb,
		0xee, 0x7a, 0x3e, 0xda, 0x98, 0x78, 0xc9, 0xde, 0x0e, 0xb1, 0x86, 0xcb, 0xfc, 0x6f, 0x22, 0xa9,
		0x7d, 0x49, 0x50, 0x27, 0x6c, 0x19, 0x09, 0xab, 0x0d, 0x60, 0x2b, 0x63, 0x2b, 0xef, 0x61, 0x2b,
		0x4f, 0x64, 0xd5, 0x3c, 0xac, 0x32, 0xec, 0x64, 0x9a, 0x8d, 0xdc, 0x71, 0xd5, 0xc8, 0x9d, 0x5b,
		0xfc, 0x97, 0xb2, 0xca, 0x84, 0x5f, 0xda, 0xc4, 0xdf, 0x44, 0x65, 0x22, 0xb1, 0x81, 0x98, 0x36,
		0xfd, 0x99, 0xee, 0xa0, 0xd8, 0x9f, 0xe5, 0x47, 0x99, 0x36, 0x41, 0x62, 0x79, 0x6e, 0xa4, 0x47,
		0xd1, 0x94, 0x9f, 0xad, 0x77, 0x19, 0x8a, 0x8a, 0x21, 0x51, 0xb7, 0x32, 0x65, 0xb0, 0x4b, 0x2f,
		0xc5, 0x9f, 0xe1, 0x87, 0xae, 0x56, 0x3d, 0xa9, 0x9d, 0x34, 0x8e, 0xaa, 0x27, 0xf5, 0xf4, 0x8f,
		0x61, 0xd2, 0x2d, 0xb9, 0xa8, 0xa2, 0x88, 0xb8, 0x15, 0x49, 0xc4, 0xcd, 0x81, 0x68, 0x8e, 0xd2,
		0x8e, 0x43, 0xc0, 0x51, 0xb0, 0xda, 0x10, 0x3e, 0xb6, 0xc5, 0xd1, 0x7c, 0x4a, 0xe4, 0x01, 0x01,
		0x5c, 0xd8, 0xf8, 0x16, 0xf7, 0x51, 0xde, 0x27, 0x66, 0x2d, 0x60, 0x68, 0x6b, 0x20, 0x4d, 0x44,
		0x03, 0x18, 0x3e, 0x20, 0x88, 0xac, 0xdc, 0x89, 0xe7, 0x5e, 0x04, 0x06, 0xa5, 0x30, 0x30, 0x88,
		0xbe, 0xac, 0xc9, 0x2a, 0x21, 0x02, 0x84, 0x10, 0x20, 0xe4, 0xc1, 0x73, 0xb5, 0x01, 0x0b, 0x86,
		0x6b, 0x51, 0xc1, 0x28, 0x85, 0x51, 0xba, 0x07, 0xa3, 0xf4, 0x2d, 0x64, 0x74, 0x9c, 0xdf, 0x3c,
		0xd7, 0x98, 0x63, 0x81, 0xce, 0x6f, 0x9e, 0x1b, 0x89, 0x8d, 0x05, 0xb2, 0x7b, 0xc6, 0x64, 0xb9,
		0x39, 0xfd, 0x6a, 0x72, 0x15, 0xe4, 0xa9, 0x82, 0xeb, 0x82, 0xeb, 0xc6, 0xcc, 0x75, 0x71, 0xa2,
		0x2c, 0x80, 0x8a, 0xe8, 0x6d, 0x6a, 0x3f, 0x6f, 0x4d, 0x4c, 0x80, 0x85, 0xf5, 0xb8, 0xd5, 0x27,
		0x67, 0x13, 0xb8, 0xd8, 0x65, 0x76, 0x93, 0xe7, 0x09, 0xa4, 0x00, 0xc6, 0x6f, 0x5b, 0x06, 0x29,
		0x68, 0x70, 0x22, 0x18, 0x14, 0x9f, 0x91, 0x08, 0x33, 0x02, 0xcb, 0xdd, 0x5e, 0x74, 0xce, 0xd3,
		0xb1, 0x9c, 0xf3, 0x2e, 0xd6, 0xab, 0x0f, 0x26, 0x8a, 0x8f, 0x3b, 0x70, 0xc1, 0x64, 0x57, 0x6e,
		0x5c, 0x19, 0x1c, 0x7f, 0xd3, 0x7c, 0xa3, 0xec, 0xde, 0x26, 0xa3, 0x17, 0x8f, 0xec, 0x3f, 0xf9,
		0x8d, 0x48, 0x80, 0xb8, 0x25, 0x16, 0xab, 0xc4, 0xe2, 0x73, 0x49, 0x4c, 0x5a, 0x2f, 0x45, 0xb9,
		0x70, 0x36, 0x19, 0xbc, 0xb9, 0xdb, 0xd3, 0x3f, 0xdb, 0x9f, 0xbf, 0x5e, 0xb4, 0x3b, 0xc1, 0xd8,
		0xd8, 0xe2, 0xd6, 0x04, 0x40, 0x63, 0xfe, 0x13, 0x93, 0x70, 0x54, 0xcc, 0x77, 0xe2, 0x76, 0x04,
		0x88, 0xcd, 0x67, 0x8b, 0x12, 0x0f, 0x5b, 0xa1, 0x4b, 0x01, 0x1c, 0xb6, 0x7d, 0x29, 0xa4, 0x14,
		0x09, 0xdb, 0xba, 0x54, 0x62, 0x06, 0xc1, 0xfa, 0x0f, 0x06, 0x43, 0xd5, 0xc8, 0x07, 0x23, 0x0b,
		0xc6, 0x18, 0xd9, 0xe2, 0xca, 0x98, 0x1d, 0x46, 0xb4, 0xf8, 0x92, 0x66, 0x82, 0x21, 0x1a, 0x63,
		0x4e, 0x3c, 0x0b, 0x29, 0x28, 0x23, 0x1a, 0x83, 0x75, 0xe8, 0x10, 0x8d, 0x11, 0xf8, 0x5f, 0x2f,
		0xd2, 0x8d, 0x2f, 0xfd, 0x34, 0x75, 0xb1, 0x30, 0x51, 0x0d, 0x53, 0x7c, 0x50, 0x28, 0x59, 0xc0,
		0x68, 0x62, 0x98, 0x71, 0x26, 0x45, 0xe5, 0xf3, 0xfd, 0x89, 0xae, 0x4b, 0xaa, 0x99, 0xe7, 0x4b,
		0xc5, 0x62, 0xa9, 0x2f, 0xeb, 0x3c, 0x27, 0xaa, 0x03, 0x6e, 0xed, 0x32, 0x77, 0x3f, 0x29, 0x97,
		0x0f, 0x25, 0xae, 0xcc, 0x94, 0x99, 0x91, 0x6b, 0xeb, 0xba, 0xa6, 0x5f, 0x4a, 0x86, 0x21, 0x3e,
		0x4a, 0xec, 0x4b, 0xda, 0x23, 0x91, 0xb9, 0xbe, 0xa8, 0xbe, 0x33, 0xb9, 0x07, 0x89, 0xeb, 0xdb,
		0x42, 0x74, 0xa2, 0x4b, 0x03, 0xee, 0x87, 0x6c, 0x3e, 0x69, 0x13, 0x93, 0xeb, 0xcb, 0x7a, 0x91,
		0x35, 0x7f, 0x84, 0x51, 0xee, 0x6d, 0x92, 0x81, 0x92, 0xd5, 0xf1, 0xc2, 0xc8, 0xed, 0xf9, 0x01,
		0x7b, 0x9b, 0x61, 0xc5, 0xe2, 0x46, 0x11, 0x49, 0x34, 0x98, 0x4c, 0x8f, 0x9a, 0x66, 0x2f, 0xdc,
		0x8a, 0xa4, 0x4c, 0xb9, 0xcc, 0x52, 0x99, 0x5c, 0xd6, 0xa1, 0x63, 0x42, 0xc7, 0x8c, 0x57, 0xc7,
		0x6c, 0xd4, 0x18, 0x74, 0xcc, 0x63, 0xe8, 0x98, 0xd0, 0x31, 0x57, 0x87, 0x2e, 0x5c, 0x29, 0x77,
		0x68, 0x9b, 0x3b, 0x13, 0x46, 0x23, 0xc9, 0x94, 0x74, 0xc6, 0x8a, 0xae, 0x1e, 0x5a, 0x42, 0x76,
		0xf4, 0x59, 0x1a, 0x8a, 0x13, 0x85, 0x4e, 0x81, 0xcd, 0x3d, 0xfc, 0x32, 0x25, 0x42, 0x3f, 0x69,
		0x0f, 0x22, 0x12, 0x22, 0x32, 0x36, 0x11, 0xf9, 0x16, 0xe2, 0x8f, 0xc6, 0x62, 0xff, 0x3b, 0x5d,
		0x80, 0xc6, 0x9c, 0xde, 0x0e, 0x41, 0xa2, 0xd8, 0xbc, 0x8c, 0x42, 0x2a, 0x4c, 0x0c, 0x92, 0xf3,
		0x76, 0x8c, 0x05, 0x89, 0xdc, 0x91, 0x41, 0xbd, 0x7c, 0xf0, 0x5c, 0xf0, 0xdc, 0xb8, 0x78, 0x6e,
		0x3a, 0x72, 0xf5, 0xc7, 0x2c, 0x6e, 0xa4, 0x31, 0xdc, 0x48, 0xd8, 0x4b, 0x71, 0x9b, 0xf8, 0x70,
		0x23, 0xc1, 0xc4, 0x87, 0x1b, 0x29, 0x59, 0x86, 0x7d, 0xf6, 0xdd, 0x48, 0x63, 0x7f, 0x37, 0xd2,
		0x38, 0x61, 0x6e, 0xa4, 0x71, 0x80, 0xe7, 0x63, 0x0c, 0x37, 0x12, 0xb9, 0x88, 0x24, 0x1a, 0xcc,
		0x64, 0xba, 0x91, 0x0e, 0xe2, 0xdb, 0x26, 0xaa, 0x66, 0xae, 0xb8, 0x56, 0x1f, 0x0c, 0x9e, 0xe7,
		0x34, 0xdd, 0xb3, 0x55, 0xdc, 0x3d, 0xf2, 0x07, 0xb7, 0x7e, 0x63, 0x32, 0xf6, 0x8c, 0xc5, 0x5d,
		0xac, 0x59, 0x7e, 0xd4, 0x25, 0xd1, 0x94, 0x74, 0xce, 0x7c, 0x12, 0x55, 0xab, 0x0b, 0xd2, 0xff,
		0x26, 0xa2, 0xc2, 0x99, 0x1a, 0x47, 0x1e, 0x31, 0x85, 0x7d, 0x43, 0x3c, 0xa0, 0x70, 0xc1, 0x92,
		0xdb, 0x67, 0x2c, 0x2e, 0xd8, 0x31, 0x5c, 0xb0, 0xb0, 0xcf, 0xe2, 0xb6, 0xcf, 0xe0, 0x82, 0x85,
		0x7d, 0x06, 0x17, 0x2c, 0x2c, 0x35, 0x04, 0xfc, 0x05, 0xc9, 0x66, 0x04, 0xfc, 0x45, 0xa6, 0x71,
		0x92, 0x0c, 0xe6, 0x5b, 0xb7, 0xd4, 0x82, 0xac, 0x31, 0x59, 0x4f, 0xc8, 0xb6, 0x08, 0xb6, 0x1d,
		0x88, 0xf5, 0x5a, 0x6c, 0x0d, 0xe2, 0x01, 0x85, 0x31, 0x46, 0x6e, 0x8c, 0xe9, 0xb2, 0xa6, 0xcb,
		0xe6, 0x2f, 0x06, 0x8b, 0x6c, 0x46, 0x09, 0xb3, 0x0c, 0x66, 0x59, 0xac, 0x66, 0xd9, 0x31, 0x83,
		0x55, 0x56, 0x87, 0x55, 0x06, 0xab, 0x6c, 0x75, 0xe8, 0x4e, 0x60, 0x82, 0x25, 0x40, 0x04, 0xb1,
		0xc5, 0xbf, 0xee, 0x3c, 0xf2, 0xf5, 0x5f, 0x9d, 0x0e, 0xe2, 0x5e, 0x21, 0x00, 0x93, 0x26, 0x00,
		0xdf, 0x42, 0xdc, 0xeb, 0x67, 0x6b, 0xef, 0xb1, 0x06, 0xbd, 0x32, 0xd2, 0x56, 0xed, 0xa2, 0x14,
		0xdd, 0xce, 0xf9, 0x69, 0x37, 0xb1, 0x11, 0xb3, 0xf6, 0xb8, 0xb0, 0x55, 0xed, 0x73, 0x7b, 0xd6,
		0xe4, 0xaa, 0x0c, 0xc4, 0xce, 0x63, 0xb3, 0x50, 0xf1, 0xef, 0x87, 0x24, 0x3f, 0x3e, 0x99, 0xf4,
		0xd2, 0xc6, 0xa5, 0xdb, 0xa5, 0xbc, 0xa9, 0x40, 0xda, 0x40, 0xda, 0xc0, 0xdc, 0x4a, 0xba, 0xb9,
		0x85, 0x93, 0x47, 0xd8, 0x87, 0xae, 0x5c, 0x86, 0xc1, 0xb5, 0x6b, 0x83, 0x0b, 0xe5, 0x39, 0x3d,
		0x8d, 0x24, 0xaf, 0x3c, 0xe7, 0xbc, 0xaa, 0xe0, 0xda, 0xf7, 0x79, 0x41, 0xb4, 0x12, 0x55, 0x69,
		0x34, 0x6e, 0x43, 0xe5, 0xc4, 0xdb, 0x59, 0xc3, 0xc2, 0xea, 0xd7, 0x79, 0xeb, 0x2b, 0xcf, 0x49,
		0x7e, 0xd9, 0x4d, 0x82, 0xc1, 0xa3, 0xac, 0xb0, 0x19, 0x3c, 0x4a, 0x7b, 0x2c, 0xa8, 0xb9, 0xb1,
		0xbb, 0x84, 0xc5, 0x33, 0x37, 0x75, 0x8e, 0xa2, 0x58, 0xe6, 0x50, 0xd1, 0x7e, 0x04, 0x16, 0xca,
		0xb4, 0x6f, 0x8a, 0xa3, 0x48, 0xa6, 0xcf, 0x83, 0xb8, 0x04, 0x94, 0xc9, 0xb4, 0x5f, 0x2b, 0xb2,
		0x42, 0x99, 0x67, 0x17, 0xd7, 0xff, 0x22, 0x28, 0x92, 0x69, 0xdf, 0x96, 0x84, 0x02, 0x99, 0x1b,
		0x26, 0x85, 0x56, 0x7b, 0x8f, 0xbb, 0x44, 0xa6, 0xff, 0xa4, 0xb1, 0x31, 0xb5, 0xc0, 0x22, 0x99,
		0x8f, 0x8a, 0xf6, 0x20, 0x2a, 0xe4, 0xc5, 0x31, 0xdd, 0xfb, 0xd3, 0x50, 0x14, 0x33, 0x60, 0xfa,
		0x59, 0x8d, 0xb8, 0x7d, 0x97, 0xc5, 0xdc, 0xbe, 0x3c, 0xa2, 0xd1, 0xb6, 0x88, 0x0b, 0x63, 0x8a,
		0x83, 0x91, 0xac, 0x0a, 0x86, 0x29, 0x9a, 0x0c, 0x40, 0xb9, 0x97, 0x78, 0x97, 0xf8, 0xc5, 0x40,
		0xfb, 0xa1, 0xbe, 0x21, 0x08, 0x83, 0x70, 0xdd, 0x67, 0x0d, 0xc4, 0x20, 0xdb, 0x17, 0x49, 0x83,
		0x31, 0x16, 0x7b, 0x60, 0x62, 0x64, 0x16, 0x35, 0x9f, 0x8c, 0x99, 0x31, 0x73, 0xf2, 0xbd, 0xbb,
		0x07, 0xd4, 0xdb, 0x7e, 0x39, 0xb6, 0x32, 0x11, 0x93, 0x71, 0x46, 0x2a, 0x44, 0x88, 0x8f, 0x92,
		0x6a, 0x0a, 0xf2, 0x80, 0x81, 0xfd, 0xcf, 0x28, 0xc1, 0x74, 0xc1, 0x74, 0xe3, 0xc5, 0x8e, 0x55,
		0x46, 0x1f, 0x25, 0x45, 0x58, 0xc6, 0xec, 0xf5, 0x62, 0x8b, 0xd0, 0xa6, 0x3f, 0x56, 0x7f, 0xad,
		0x7b, 0x47, 0x0c, 0xb4, 0xb3, 0x63, 0xf6, 0x4b, 0x63, 0x4d, 0x37, 0x9b, 0x8e, 0xdd, 0x6d, 0x7d,
		0x74, 0xbe, 0xdf, 0x5c, 0x77, 0xba, 0x8b, 0x4f, 0xce, 0x61, 0xfb, 0xf6, 0x57, 0xf2, 0x13, 0xf7,
		0x19, 0xf9, 0x7a, 0x8a, 0x47, 0x52, 0x11, 0x1f, 0x3d, 0x03, 0xd9, 0x7f, 0x12, 0x55, 0x55, 0x52,
		0xec, 0xab, 0xd6, 0x20, 0x9e, 0xfe, 0xd9, 0xba, 0xba, 0x6a, 0x5f, 0xac, 0x7e, 0x77, 0xc6, 0xd6,
		0xba, 0x88, 0xa1, 0xdd, 0x3c, 0xb4, 0xa3, 0xc7, 0x91, 0x59, 0xf0, 0xac, 0x54, 0xeb, 0xbb, 0x60,
		0x2f, 0xd7, 0xc5, 0x2f, 0x97, 0x5f, 0x2e, 0xbb, 0x82, 0xbd, 0x70, 0x7d, 0xae, 0x39, 0xc3, 0xbc,
		0xf8, 0x21, 0xc9, 0x83, 0x4d, 0x5d, 0x14, 0x67, 0x6d, 0xac, 0x8f, 0xd9, 0xc6, 0xda, 0x94, 0x74,
		0x95, 0x9a, 0xf5, 0x2d, 0x9c, 0x32, 0x8a, 0xa8, 0xe6, 0xef, 0xca, 0x85, 0x93, 0xde, 0x4b, 0xe5,
		0xe0, 0x70, 0xfa, 0x7a, 0x57, 0x29, 0x1c, 0xf6, 0x9c, 0xef, 0xd6, 0xb7, 0x5a, 0xef, 0xae, 0x6c,
		0x7d, 0x3d, 0x76, 0xae, 0xcd, 0x2e, 0x9c, 0x58, 0x5f, 0x6b, 0x3d, 0x9e, 0x3e, 0xc4, 0xba, 0x97,
		0x85, 0x60, 0x69, 0x4d, 0x51, 0x64, 0xf5, 0x51, 0x90, 0x55, 0x53, 0xd2, 0x9f, 0x09, 0x00, 0x9d,
		0xb5, 0xc5, 0xb2, 0xd6, 0xc2, 0x2e, 0x2d, 0xf2, 0x6a, 0x19, 0xf6, 0x38, 0x54, 0xc3, 0x44, 0xaa,
		0x86, 0xb2, 0x6a, 0x56, 0x1a, 0x0c, 0xba, 0x61, 0x03, 0x61, 0xdc, 0x2b, 0xf4, 0x88, 0x2b, 0xe0,
		0xde, 0x5c, 0x54, 0xc1, 0x41, 0x2a, 0x56, 0x74, 0x1d, 0x2b, 0x9a, 0x75, 0xe8, 0x0e, 0x11, 0x29,
		0xb3, 0x7b, 0x85, 0x2f, 0x01, 0xc1, 0x20, 0x96, 0xf4, 0x5e, 0xfa, 0x6c, 0xbb, 0x75, 0x4b, 0x44,
		0xee, 0x3f, 0x6e, 0x93, 0xd7, 0xdf, 0x6a, 0x48, 0xf0, 0x7e, 0xb4, 0xda, 0x14, 0xbe, 0x38, 0x6d,
		0xa6, 0x20, 0xc8, 0xc3, 0x7f, 0x50, 0x68, 0x03, 0x3b, 0x7c, 0x47, 0x81, 0x38, 0x98, 0xe3, 0x60,
		0x83, 0x63, 0x5e, 0x38, 0xbd, 0xbe, 0xb8, 0x68, 0x9f, 0x76, 0xaf, 0x3b, 0x84, 0x2e, 0x7a, 0x0f,
		0x01, 0x9c, 0xf5, 0xe9, 0x70, 0xd6, 0xaf, 0xcc, 0x1b, 0xed, 0xb9, 0x96, 0x7e, 0xd4, 0x70, 0xe4,
		0xc3, 0x91, 0x6f, 0x9f, 0x3e, 0xa4, 0x29, 0x8a, 0xd4, 0x37, 0x35, 0x5d, 0x90, 0xc7, 0x0c, 0xc7,
		0x10, 0x79, 0xa9, 0x61, 0xb3, 0xc3, 0x66, 0x67, 0xb0, 0xd9, 0x2f, 0x45, 0x75, 0x20, 0x9a, 0x9a,
		0xfe, 0x8b, 0xdc, 0xa3, 0x1a, 0xc2, 0xce, 0x97, 0xc7, 0x05, 0x71, 0x30, 0xd0, 0x25, 0xc3, 0xc8,
		0x9a, 0x1f, 0x48, 0x1e, 0x3f, 0xd7, 0x18, 0xfa, 0x96, 0x0c, 0xec, 0x37, 0x9f, 0x77, 0x41, 0xdd,
		0x4a, 0xe1, 0xc4, 0xc5, 0x77, 0x2b, 0xf6, 0x3f, 0xce, 0xe7, 0xaa, 0x8d, 0xf1, 0xba, 0x9f, 0xeb,
		0x77, 0xe5, 0x42, 0xbd, 0xc7, 0xdf, 0xdf, 0x17, 0xf9, 0x97, 0xc3, 0x29, 0x3d, 0x61, 0xfe, 0xf7,
		0xbb, 0xfb, 0xfb, 0xf1, 0xcb, 0xd5, 0xd4, 0xfa, 0x7b, 0x31, 0xed, 0x7d, 0xe0, 0x3f, 0xee, 0x1c,
		0x3c, 0x3e, 0x88, 0x71, 0x15, 0x34, 0x52, 0xbc, 0x0a, 0x9a, 0xaf, 0xd6, 0x5c, 0x89, 0x85, 0x61,
		0xab, 0x70, 0xd6, 0x7b, 0x29, 0x1f, 0xd4, 0xa6, 0x7c, 0x93, 0xcf, 0xaf, 0x5e, 0x6b, 0xf2, 0x2f,
		0xe5, 0x83, 0xfa, 0x34, 0x9f, 0xf7, 0xf9, 0xe5, 0xa3, 0x5f, 0x1b, 0xfc, 0x6b, 0x3e, 0x9f, 0x77,
		0xe7, 0x7f, 0x69, 0x4d, 0xdc, 0x95, 0x2b, 0xbd, 0x8f, 0xf6, 0x47, 0xe7, 0xef, 0x7c, 0x55, 0x11,
		0xdd, 0xcc, 0xfb, 0xae, 0xa5, 0x03, 0xe6, 0x2d, 0xf0, 0xdf, 0x66, 0xef, 0x43, 0x93, 0x7f, 0x69,
		0x4c, 0x67, 0x9f, 0xed, 0xbf, 0xfc, 0x6b, 0xbe, 0xf8, 0xfe, 0xfe, 0xbe, 0x58, 0x7c, 0xcf, 0x3b,
		0x1d, 0x71, 0xef, 0x7b, 0xef, 0xfc, 0xfa, 0xb1, 0xd9, 0x5c, 0xbb, 0xc4, 0xe7, 0x7f, 0x2f, 0xc6,
		0xb1, 0xac, 0x93, 0x79, 0xa0, 0xe2, 0x5c, 0x29, 0x19, 0x6b, 0xba, 0x19, 0x46, 0xa9, 0xb1, 0xe9,
		0x77, 0xe9, 0x0f, 0x69, 0x1c, 0xd6, 0x0e, 0xe1, 0x11, 0x81, 0x76, 0xb5, 0x3b, 0xed, 0x8a, 0x5d,
		0x53, 0xb2, 0x16, 0x7f, 0x41, 0x9d, 0x8c, 0x1e, 0x24, 0x1d, 0x6e, 0x11, 0xb8, 0x45, 0xa2, 0x00,
		0x91, 0x1b, 0xf5, 0xfa, 0x21, 0x8a, 0x8c, 0x26, 0x4b, 0x46, 0x3e, 0xeb, 0xc3, 0x30, 0x22, 0xd2,
		0x22, 0x87, 0x68, 0x82, 0x68, 0x8a, 0x55, 0x34, 0x85, 0x38, 0xf5, 0x8b, 0x82, 0x86, 0xd5, 0x9c,
		0xc9, 0x8d, 0x1e, 0x47, 0xe6, 0xeb, 0xc0, 0xd5, 0x07, 0x51, 0x63, 0x38, 0x70, 0x3a, 0x3d, 0xc5,
		0x53, 0xff, 0xef, 0x0f, 0xee, 0x9d, 0x35, 0x7c, 0xef, 0x9c, 0x33, 0x2e, 0x4a, 0xa3, 0x67, 0x7d,
		0xe8, 0x0d, 0xd9, 0x7b, 0xd6, 0x87, 0xce, 0x35, 0x3b, 0x30, 0xef, 0x5b, 0xe7, 0x4c, 0x38, 0xbd,
		0xbe, 0x3a, 0x3b, 0xff, 0xe2, 0x5c, 0x7c, 0xd6, 0x87, 0x82, 0xe3, 0xa9, 0x72, 0xbe, 0x5b, 0x24,
		0xdf, 0xf4, 0x61, 0x5b, 0xb5, 0xc6, 0x60, 0xc0, 0xfd, 0xc1, 0xbd, 0xb3, 0xf6, 0xcb, 0xbb, 0x04,
		0x54, 0x62, 0xbd, 0x9c, 0x18, 0x26, 0xd7, 0xd7, 0xd4, 0x81, 0x6c, 0xc9, 0x34, 0x4e, 0xd5, 0x4c,
		0xce, 0x10, 0x4d, 0xd9, 0x18, 0xca, 0xd2, 0xa0, 0xc8, 0x75, 0xf5, 0x5f, 0x9c, 0x64, 0xbf, 0x34,
		0x77, 0x29, 0xaa, 0xe2, 0xa3, 0x9d, 0x74, 0xce, 0x7d, 0xeb, 0x9c, 0xa1, 0x68, 0x31, 0x29, 0x67,
		0x63, 0x1e, 0x60, 0x54, 0x6a, 0x25, 0x56, 0x22, 0xde, 0xf8, 0x21, 0xa1, 0x50, 0x19, 0xa0, 0x32,
		0xac, 0xd0, 0x5c, 0x48, 0xea, 0xa3, 0x1d, 0x3a, 0x80, 0xca, 0x41, 0x59, 0x37, 0x65, 0x6b, 0xb0,
		0x63, 0x77, 0x2d, 0x82, 0xb2, 0x59, 0x38, 0xa8, 0x9a, 0xce, 0x2a, 0x41, 0xfe, 0x31, 0x50, 0x8b,
		0xb0, 0x92, 0x12, 0x43, 0x98, 0x09, 0x47, 0x17, 0x30, 0xb6, 0x68, 0xdb, 0xf7, 0x59, 0xa9, 0x0d,
		0x24, 0x0b, 0x8c, 0xc8, 0x62, 0x1d, 0xa7, 0xf0, 0xc1, 0x65, 0xb7, 0xed, 0xdb, 0xdb, 0xf3, 0xeb,
		0x2b, 0xd2, 0xd0, 0xb2, 0xd9, 0xed, 0x08, 0x2c, 0x4b, 0x53, 0x60, 0x99, 0x3b, 0x6b, 0x4c, 0x61,
		0x65, 0x4b, 0xb4, 0x08, 0x2a, 0x43, 0x50, 0x59, 0x6a, 0xaa, 0xc3, 0x4c, 0xc6, 0xf0, 0xbc, 0xc2,
		0x56, 0x4d, 0xa2, 0xad, 0x8a, 0xda, 0x30, 0x1b, 0x49, 0x51, 0x1b, 0x86, 0xd5, 0x2a, 0x9b, 0xc6,
		0x9a, 0x95, 0xcc, 0x12, 0x77, 0x43, 0x13, 0x6d, 0x03, 0x66, 0x0b, 0x66, 0x1b, 0x0d, 0xb3, 0x45,
		0x4d, 0x18, 0xff, 0xee, 0xa1, 0x26, 0x4c, 0x9a, 0x6b, 0x69, 0x88, 0x8a, 0xf2, 0x36, 0x83, 0x3f,
		0x0d, 0x71, 0x34, 0x56, 0x24, 0x41, 0x67, 0x32, 0x3d, 0xbc, 0xc4, 0x10, 0x44, 0x10, 0x44, 0xf1,
		0x0a, 0x22, 0x59, 0x35, 0x0f, 0xab, 0x0c, 0x92, 0xe8, 0x28, 0xb3, 0xa1, 0x96, 0xd5, 0x7a, 0x03,
		0x1e, 0x2a, 0xd6, 0xc1, 0x3b, 0x3e, 0x3c, 0x3e, 0x6e, 0x94, 0x8f, 0xe1, 0xa6, 0x0a, 0x27, 0x95,
		0x32, 0x18, 0x6f, 0x55, 0x2c, 0xda, 0x7a, 0x97, 0x1d, 0x6c, 0x25, 0x2a, 0xca, 0xbb, 0xdc, 0x5b,
		0x70, 0x04, 0x12, 0x58, 0x97, 0x38, 0x41, 0x24, 0x58, 0xbd, 0xa2, 0x71, 0x6b, 0xb9, 0xbe, 0x81,
		0x12, 0xb5, 0xa7, 0x80, 0xa3, 0xf3, 0x77, 0xcd, 0x5a, 0xf6, 0x79, 0x4e, 0x7a, 0x7d, 0x82, 0xdb,
		0x5d, 0x69, 0x6c, 0x23, 0xb4, 0xcf, 0x93, 0x43, 0x56, 0xbb, 0x49, 0x7a, 0x62, 0xc8, 0x4a, 0x87,
		0x28, 0x4e, 0x0a, 0x51, 0x47, 0xe3, 0xc0, 0x83, 0x42, 0xac, 0x7b, 0xe2, 0x38, 0x27, 0xc4, 0xe7,
		0x41, 0x5c, 0x02, 0xce, 0x09, 0xb1, 0x5f, 0x2b, 0xb2, 0x73, 0x42, 0xae, 0x2e, 0x6f, 0x08, 0x1c,
		0xc5, 0xd6, 0x5d, 0x49, 0xf0, 0x0f, 0x6f, 0x98, 0x12, 0x5a, 0x63, 0x28, 0x6e, 0xff, 0xb0, 0xff,
		0x94, 0xb1, 0x31, 0xae, 0x40, 0xff, 0xf0, 0xe9, 0xf5, 0x55, 0xb7, 0x75, 0x4a, 0xe1, 0x14, 0x9e,
		0x11, 0xa4, 0xc1, 0x13, 0x1c, 0xb0, 0x00, 0x58, 0xad, 0xe2, 0x7d, 0x7b, 0x82, 0xb7, 0x2f, 0x90,
		0x68, 0x74, 0x2a, 0x62, 0x4f, 0xf0, 0xa9, 0xa6, 0x9a, 0x62, 0x9f, 0xc1, 0x19, 0x30, 0x23, 0xcc,
		0x02, 0x0c, 0x43, 0xb8, 0xd0, 0xb2, 0x06, 0xc3, 0x90, 0x2d, 0xc4, 0xa4, 0xc1, 0x30, 0x08, 0x14,
		0xf6, 0xc1, 0x12, 0x10, 0x28, 0x1c, 0x02, 0xc3, 0x42, 0xc6, 0x6b, 0xb2, 0x01, 0x82, 0x68, 0x6c,
		0x60, 0x75, 0x34, 0xf6, 0x7e, 0xb4, 0xd4, 0xdc, 0x12, 0x99, 0x36, 0xb4, 0xd1, 0xf4, 0x51, 0x47,
		0x63, 0xc1, 0xf3, 0xe9, 0xea, 0xf2, 0x46, 0x98, 0xb5, 0xc8, 0x6a, 0xd7, 0x6e, 0xd1, 0x77, 0x2f,
		0xae, 0x4f, 0x5b, 0xdd, 0x6d, 0xb1, 0x9e, 0x6b, 0xac, 0x72, 0x4e, 0x01, 0x6d, 0x0f, 0xda, 0x9e,
		0xbd, 0x84, 0xb4, 0x3e, 0xf9, 0x3e, 0x5a, 0x5e, 0x4a, 0x33, 0x4a, 0xe8, 0x7b, 0xd0, 0xf7, 0xa0,
		0xef, 0x41, 0xdf, 0x83, 0xbe, 0x07, 0x7d, 0x2f, 0x75, 0xfa, 0x1e, 0xa1, 0x42, 0x44, 0xa3, 0xf0,
		0xcd, 0x9b, 0x4c, 0x81, 0x27, 0xc3, 0x67, 0x48, 0x68, 0xdd, 0x17, 0xeb, 0x23, 0x10, 0x2a, 0x87,
		0xc9, 0x51, 0x99, 0x2f, 0x2f, 0xbf, 0x5e, 0x9d, 0x77, 0xff, 0x4d, 0x86, 0x4d, 0x7b, 0xee, 0x07,
		0x4a, 0x9d, 0x0e, 0x94, 0x7a, 0x79, 0xda, 0x68, 0xd3, 0x98, 0x7c, 0x88, 0x61, 0xcf, 0xc0, 0x9e,
		0xb1, 0xb5, 0xca, 0x7f, 0xdf, 0xb4, 0xe9, 0x6d, 0x19, 0x9b, 0x0a, 0x76, 0x0c, 0xec, 0x98, 0x58,
		0xed, 0x18, 0x49, 0x9d, 0x8c, 0x24, 0x9d, 0xc6, 0x88, 0xe6, 0x52, 0x97, 0x33, 0xd4, 0xb9, 0x66,
		0xce, 0x19, 0xea, 0xfc, 0x2b, 0xb1, 0x19, 0x43, 0x9d, 0x6b, 0x36, 0x5d, 0xdf, 0xea, 0x53, 0x93,
		0xab, 0x64, 0x20, 0x5f, 0xe8, 0x8d, 0x17, 0x12, 0x02, 0x9f, 0x05, 0x5e, 0x94, 0x6e, 0xbc, 0xa8,
		0x06, 0xbc, 0x88, 0x75, 0xe8, 0x0e, 0xab, 0x80, 0x8b, 0x36, 0xc1, 0x45, 0x71, 0x14, 0xeb, 0xbc,
		0xfb, 0x2f, 0xf7, 0xff, 0x3b, 0xb8, 0xbf, 0xbf, 0xbf, 0x7f, 0xd7, 0x7b, 0x9f, 0x43, 0x8d, 0xa3,
		0x39, 0x53, 0x40, 0x68, 0xf3, 0x26, 0x4c, 0x6b, 0x81, 0x16, 0x94, 0xe8, 0xc1, 0x03, 0x8e, 0xca,
		0xd9, 0x3b, 0x6b, 0xd8, 0xef, 0x39, 0xe9, 0x04, 0x04, 0x03, 0xe1, 0x35, 0xa6, 0x01, 0xda, 0x67,
		0x60, 0xf3, 0x72, 0x27, 0x49, 0xc3, 0x9a, 0x97, 0x7a, 0x43, 0x11, 0xd4, 0x6c, 0xbd, 0x5f, 0xbf,
		0xa0, 0x6b, 0x13, 0x9f, 0xfc, 0xc6, 0xd5, 0xe0, 0x66, 0xef, 0xbd, 0x71, 0x04, 0x39, 0xfb, 0x3d,
		0x89, 0x4b, 0x40, 0x94, 0xb3, 0xf3, 0x5e, 0x91, 0x85, 0x39, 0x77, 0x5b, 0xdd, 0xf3, 0x53, 0xa1,
		0x73, 0xfd, 0xb5, 0xdb, 0x26, 0x80, 0x94, 0xbd, 0x77, 0x27, 0x01, 0x50, 0xde, 0x34, 0x49, 0x49,
		0x47, 0x94, 0x37, 0x4c, 0xe2, 0xae, 0x20, 0x65, 0xcf, 0xb4, 0xd1, 0x02, 0xca, 0x6b, 0xa4, 0x69,
		0x80, 0x93, 0x83, 0x96, 0x45, 0x5a, 0xf1, 0xe4, 0x80, 0x65, 0x13, 0x33, 0xa0, 0xfc, 0xa0, 0x88,
		0xfd, 0xef, 0x4f, 0x9a, 0xc2, 0x80, 0x76, 0x2c, 0x48, 0x77, 0x59, 0x14, 0xcb, 0x36, 0x00, 0xde,
		0x50, 0x5d, 0x2c, 0xd2, 0x65, 0x9f, 0x35, 0xec, 0x85, 0x70, 0x5b, 0xbc, 0x4d, 0xf0, 0x85, 0xd9,
		0x96, 0xcc, 0xe7, 0xad, 0x79, 0x79, 0xb5, 0x37, 0x11, 0x7f, 0xc0, 0xbf, 0xf7, 0x7e, 0xcd, 0x25,
		0xb2, 0x5c, 0xc6, 0x40, 0x36, 0x4c, 0x51, 0xed, 0x33, 0xf0, 0xa3, 0x39, 0xe5, 0x2e, 0xd9, 0x51,
		0x19, 0xac, 0x08, 0xac, 0x08, 0xac, 0x88, 0x89, 0x15, 0xf9, 0x9f, 0x60, 0x59, 0x98, 0x1d, 0x61,
		0xe9, 0x9c, 0x63, 0x69, 0x73, 0x29, 0xb2, 0x3b, 0x93, 0xc9, 0xc0, 0xe4, 0x21, 0x9b, 0xf3, 0xc8,
		0xa5, 0x03, 0xe3, 0x00, 0xe3, 0x48, 0x0f, 0xe3, 0x88, 0xd3, 0x25, 0x2b, 0xfd, 0x34, 0x9f, 0x34,
		0x86, 0x23, 0xe1, 0x67, 0x84, 0xd8, 0x59, 0xd8, 0x59, 0xd8, 0x59, 0x9b, 0x77, 0x56, 0x81, 0xe9,
		0xe0, 0x45, 0x2f, 0x31, 0x76, 0x18, 0x76, 0x18, 0x94, 0xde, 0x65, 0xa5, 0x37, 0xff, 0x4d, 0x1f,
		0xde, 0x89, 0x85, 0x7f, 0x5a, 0x85, 0xff, 0x94, 0x0b, 0x27, 0x42, 0xc1, 0x3e, 0x3d, 0xdd, 0x3d,
		0x8a, 0x91, 0x7f, 0xcd, 0x8f, 0x1e, 0x47, 0x26, 0x6f, 0xeb, 0xbc, 0x44, 0x37, 0x26, 0x53, 0xe5,
		0x1d, 0xd3, 0x6d, 0xb8, 0x45, 0x7d, 0x65, 0x2a, 0xf8, 0x15, 0x6c, 0x03, 0x6c, 0x23, 0x2a, 0xb6,
		0x21, 0x8f, 0x0b, 0xd4, 0xa3, 0x97, 0x8a, 0x3a, 0xcb, 0xf2, 0xf8, 0xb9, 0x56, 0x60, 0x5a, 0x18,
		0xdc, 0xde, 0x4b, 0x04, 0xe7, 0xf3, 0xae, 0xa5, 0x5f, 0x99, 0xd9, 0xf8, 0xaf, 0x95, 0x85, 0xbd,
		0xbf, 0x04, 0x06, 0xb8, 0x00, 0x01, 0x7f, 0x7f, 0x5f, 0xe4, 0x5f, 0x0e, 0xa7, 0xf4, 0x84, 0x25,
		0xf7, 0x61, 0xfc, 0x6b, 0xfe, 0xae, 0x52, 0xa8, 0xf6, 0x66, 0x5f, 0x0e, 0xef, 0xca, 0x85, 0x6a,
		0x8f, 0x86, 0xd1, 0xd2, 0x31, 0x5c, 0xca, 0x25, 0x1e, 0xcd, 0x8a, 0x68, 0xa4, 0x77, 0x45, 0x34,
		0x5f, 0xad, 0x99, 0x11, 0x0b, 0xc3, 0x56, 0xe1, 0xac, 0xf7, 0x52, 0x3e, 0xa8, 0x4d, 0xf9, 0x26,
		0x9f, 0x5f, 0xbd, 0xd6, 0xe4, 0x5f, 0xca, 0x07, 0xf5, 0x69, 0x3e, 0xef, 0xf3, 0xcb, 0x47, 0xbf,
		0x36, 0xf8, 0xd7, 0xfc, 0x26, 0x3c, 0x6a, 0x06, 0x32, 0x39, 0x7f, 0xe7, 0x2b, 0x8c, 0xe8, 0x66,
		0x9e, 0xcf, 0x7b, 0x17, 0x96, 0xf5, 0xef, 0x4b, 0x75, 0xca, 0xbf, 0xe6, 0x2b, 0x36, 0x7a, 0x35,
		0xfb, 0xa1, 0x62, 0x35, 0x72, 0x6c, 0xdd, 0xce, 0x7a, 0x7a, 0x6e, 0x3e, 0x7f, 0xf7, 0xdf, 0x66,
		0xef, 0x43, 0x93, 0x7f, 0x69, 0x4c, 0x67, 0x9f, 0xed, 0xbf, 0xfc, 0x6b, 0xbe, 0xf8, 0xfe, 0xfe,
		0xbe, 0x58, 0x7c, 0xcf, 0x3b, 0x9d, 0x74, 0xef, 0x7b, 0xef, 0xfc, 0xfa, 0xb1, 0xd9, 0x5c, 0xbb,
		0xc4, 0xe7, 0x4b, 0xc5, 0x0f, 0xfc, 0xdb, 0x2c, 0xce, 0xfd, 0xac, 0x0f, 0x05, 0x36, 0xb8, 0x6e,
		0x4e, 0x09, 0xed, 0x05, 0xda, 0x4b, 0xcc, 0xda, 0x4b, 0x26, 0x4f, 0x88, 0x48, 0xe9, 0xb9, 0x06,
		0xd4, 0xa7, 0xea, 0x27, 0x5d, 0x5f, 0x48, 0xe9, 0x3c, 0x58, 0xf6, 0x31, 0x26, 0x61, 0xcf, 0x93,
		0xb0, 0x06, 0x61, 0x64, 0x50, 0xab, 0x88, 0x22, 0x3e, 0x7e, 0xa6, 0x3c, 0x70, 0x64, 0x71, 0x8a,
		0x08, 0x95, 0x0f, 0x7a, 0xb8, 0x7f, 0x20, 0xb4, 0x27, 0xdc, 0xd8, 0xef, 0x92, 0x37, 0x2e, 0xb2,
		0x44, 0x1b, 0x24, 0xc9, 0x6d, 0x8a, 0xa3, 0xb6, 0x9f, 0xd0, 0xb1, 0x1e, 0x20, 0xac, 0x5f, 0xf0,
		0x3e, 0x64, 0xfd, 0x89, 0x3b, 0xa8, 0xa1, 0xb6, 0xf4, 0x90, 0x6e, 0xfb, 0xf2, 0xe6, 0xa2, 0x15,
		0x2e, 0x7e, 0x74, 0xb9, 0x0d, 0x04, 0x92, 0x22, 0x90, 0xd4, 0xb9, 0x51, 0x1c, 0x3c, 0x4b, 0xba,
		0x29, 0x1b, 0x4c, 0xe7, 0xab, 0xce, 0x48, 0x11, 0x48, 0x0a, 0x9b, 0x0e, 0x8e, 0xac, 0xdd, 0x69,
		0x7a, 0x6f, 0x29, 0x90, 0x14, 0x71, 0x58, 0x60, 0x01, 0x6f, 0x86, 0x05, 0x20, 0x0e, 0x0b, 0x3b,
		0x0b, 0x3b, 0x2b, 0xe5, 0x3b, 0x0b, 0x61, 0x14, 0xd8, 0x57, 0xe9, 0xda, 0x57, 0x08, 0xa3, 0x48,
		0x20, 0x08, 0x8b, 0x30, 0x8a, 0x1d, 0xad, 0x08, 0x84, 0x51, 0x20, 0x8c, 0xe2, 0x0d, 0x86, 0x51,
		0x44, 0x72, 0xd6, 0x29, 0xfc, 0x1c, 0x49, 0xf4, 0x73, 0xd0, 0x80, 0xf9, 0x11, 0x3b, 0x3c, 0x96,
		0x1f, 0x9d, 0x82, 0xd2, 0x41, 0x14, 0x83, 0x4c, 0x5b, 0x48, 0x88, 0x74, 0x04, 0xf7, 0x59, 0x54,
		0x68, 0x7b, 0xf7, 0x49, 0x8b, 0x0c, 0x6d, 0xe9, 0x29, 0x4d, 0xc9, 0x21, 0x4d, 0x1f, 0x15, 0xfa,
		0x9a, 0x6a, 0xea, 0x9a, 0x12, 0x5c, 0x73, 0xc8, 0x7b, 0x73, 0x2c, 0x27, 0xab, 0xf6, 0x93, 0x78,
		0xae, 0x6a, 0x3f, 0xb2, 0x72, 0x43, 0x37, 0xd7, 0x9d, 0xae, 0x70, 0xdb, 0xbd, 0xee, 0x5c, 0xda,
		0x87, 0x3f, 0x75, 0xae, 0x2f, 0x82, 0x8b, 0x0e, 0xf9, 0xd0, 0x24, 0xa2, 0x96, 0x7d, 0x3f, 0x8d,
		0x95, 0xec, 0xfb, 0xb1, 0x15, 0x1d, 0x5a, 0x9f, 0x36, 0x4a, 0xd7, 0xf1, 0xa6, 0x06, 0x52, 0x51,
		0xcf, 0xbe, 0x9f, 0xc5, 0x6a, 0xf6, 0xfd, 0xc4, 0x78, 0x8c, 0xe1, 0xa0, 0x21, 0x5b, 0x62, 0x59,
		0xc3, 0xba, 0x48, 0x96, 0x60, 0xd2, 0x80, 0x2e, 0x45, 0x12, 0x87, 0xba, 0x34, 0x64, 0x81, 0xb9,
		0x8e, 0xe8, 0xdc, 0xb3, 0x8e, 0xd2, 0x35, 0xd6, 0xcd, 0xa6, 0xa3, 0xbf, 0x8c, 0x35, 0xdd, 0xb4,
		0xbf, 0x5a, 0xac, 0x74, 0xfe, 0xc1, 0xe6, 0xa2, 0xf6, 0x37, 0x7b, 0x2f, 0xc4, 0x08, 0x52, 0x7f,
		0x7f, 0x18, 0x1b, 0xf4, 0x7b, 0xd6, 0xa6, 0xc2, 0x8e, 0xc5, 0x8e, 0x8d, 0x6d, 0xc7, 0x4e, 0x64,
		0xd5, 0x6c, 0xd4, 0x18, 0x36, 0x2c, 0x4d, 0x38, 0x45, 0x47, 0x54, 0x1f, 0xa5, 0xd4, 0xd4, 0x44,
		0x2f, 0xa3, 0x26, 0x3a, 0xeb, 0xd0, 0x55, 0xca, 0xee, 0x7f, 0x28, 0x8d, 0xbe, 0x6b, 0xb8, 0x91,
		0x08, 0x85, 0xd2, 0xf4, 0x91, 0x60, 0xd2, 0xf0, 0x06, 0x8f, 0x2b, 0x78, 0x4e, 0x0b, 0x79, 0x04,
		0x79, 0x14, 0x9b, 0x3c, 0x7a, 0x0b, 0xa7, 0x21, 0x3d, 0xe8, 0x9a, 0x38, 0xe8, 0x8b, 0x86, 0xc9,
		0x7c, 0x28, 0xd2, 0x44, 0xfd, 0xae, 0x6a, 0x3f, 0xd4, 0xc2, 0x44, 0x95, 0x59, 0xdb, 0xa9, 0x7a,
		0xdb, 0x19, 0x4d, 0x14, 0xd3, 0x69, 0x29, 0xa9, 0x67, 0x2d, 0x2d, 0xc6, 0x8c, 0xed, 0xc8, 0xa5,
		0xf5, 0x9e, 0x36, 0xb9, 0x6a, 0x88, 0x76, 0x66, 0x23, 0x9f, 0x82, 0x73, 0x9c, 0xa2, 0x70, 0x4c,
		0x39, 0x60, 0x02, 0x47, 0x2c, 0x15, 0xe0, 0xa3, 0x0a, 0x96, 0xce, 0xfe, 0xfe, 0x03, 0x0f, 0x0c,
		0xef, 0x7b, 0x6d, 0x1d, 0x2a, 0x2c, 0xb1, 0xa1, 0x87, 0x9b, 0x9d, 0x0f, 0x9a, 0x3e, 0x3a, 0x75,
		0x9e, 0x26, 0xac, 0x5f, 0xf1, 0x79, 0xd8, 0xa6, 0xe7, 0xa7, 0xc1, 0x5b, 0x45, 0x3f, 0xdc, 0xd4,
		0x5e, 0x2b, 0xca, 0xe1, 0xdc, 0xab, 0xf7, 0x2a, 0x60, 0x38, 0x88, 0xfd, 0x57, 0xdb, 0xfa, 0x4c,
		0xee, 0xc1, 0x32, 0x25, 0x6b, 0x8b, 0x9b, 0xfa, 0xaf, 0x20, 0xef, 0xd5, 0xe2, 0xc6, 0x18, 0x3c,
		0x57, 0x9b, 0x1e, 0xc6, 0xed, 0xdf, 0x7f, 0xb5, 0x78, 0xb5, 0xa8, 0xbc, 0x58, 0xdd, 0xf6, 0x45,
		0xfb, 0xb2, 0xdd, 0xed, 0x10, 0x1c, 0xc2, 0xbc, 0xb8, 0x35, 0x01, 0x3e, 0xab, 0x6d, 0x93, 0x44,
		0xab, 0xe7, 0xc7, 0xec, 0xb9, 0xda, 0x32, 0x89, 0x6c, 0x2c, 0x32, 0xd0, 0x7f, 0xd5, 0x97, 0x74,
		0xd3, 0x20, 0xf7, 0x56, 0x39, 0xb7, 0xa7, 0xc0, 0x37, 0x45, 0xb2, 0x08, 0x58, 0x8d, 0xbe, 0x3d,
		0x7b, 0xa8, 0x08, 0x16, 0x49, 0x34, 0x0a, 0x20, 0xb1, 0x9f, 0xaa, 0x2f, 0x0a, 0x7d, 0xdd, 0xa4,
		0x47, 0x1a, 0x5c, 0xba, 0x0c, 0xa0, 0x0c, 0x34, 0xcb, 0x2d, 0x63, 0x58, 0x03, 0xc5, 0x72, 0x4c,
		0x1a, 0xe2, 0x90, 0xf4, 0x8c, 0xc2, 0xd2, 0x4a, 0xb5, 0xcb, 0xf7, 0xa5, 0xfc, 0xca, 0x95, 0x62,
		0x5f, 0xd2, 0x93, 0x99, 0x5c, 0x68, 0x48, 0xfa, 0xb3, 0xa4, 0xb3, 0xf1, 0x05, 0x0f, 0x2d, 0x78,
		0x03, 0x78, 0x03, 0x78, 0x43, 0x36, 0x79, 0xc3, 0x77, 0xe9, 0x17, 0x33, 0x6f, 0xb0, 0x68, 0xc1,
		0x1b, 0xc0, 0x1b, 0xc0, 0x1b, 0xd8, 0x78, 0x83, 0xb5, 0x7f, 0x52, 0x96, 0x28, 0x11, 0x09, 0xca,
		0x3a, 0x5f, 0x75, 0x6b, 0xdf, 0xe7, 0x18, 0x46, 0x89, 0xc4, 0xc8, 0xdd, 0x84, 0x7f, 0x75, 0x67,
		0xed, 0x09, 0x2b, 0x5f, 0xe7, 0xcd, 0x0b, 0xa7, 0x76, 0xf3, 0x3b, 0xa8, 0x64, 0xf4, 0xa8, 0x8e,
		0x64, 0x72, 0x53, 0xde, 0xbe, 0x1b, 0x96, 0x3c, 0x2c, 0xf9, 0x25, 0x4b, 0x5e, 0x91, 0x25, 0xd5,
		0x14, 0xc4, 0x89, 0xbd, 0x69, 0x68, 0xcd, 0x79, 0x0f, 0x31, 0x64, 0x33, 0x64, 0xf3, 0x5e, 0x64,
		0xf3, 0x83, 0xa6, 0x29, 0x92, 0xc8, 0x14, 0x41, 0x50, 0x89, 0x51, 0x05, 0x56, 0xb4, 0x47, 0x41,
		0x91, 0x9e, 0x25, 0x85, 0x7e, 0x9b, 0x2d, 0x48, 0xb1, 0xc9, 0xb0, 0xc9, 0xf6, 0xb2, 0xc9, 0x26,
		0xb2, 0x6a, 0x1e, 0x33, 0x6c, 0xb1, 0x3a, 0x22, 0x47, 0x57, 0xe8, 0x11, 0x39, 0xca, 0x55, 0x10,
		0x33, 0x9a, 0x08, 0x54, 0x66, 0xac, 0xb1, 0x60, 0xb5, 0x36, 0x15, 0x04, 0x11, 0x04, 0xd1, 0x5e,
		0x04, 0x91, 0xb5, 0xfa, 0x0a, 0xea, 0x64, 0xf4, 0x20, 0xe9, 0x0c, 0xe2, 0xa8, 0x01, 0x71, 0x04,
		0x71, 0xb4, 0x3a, 0x74, 0x8d, 0x7a, 0xfd, 0xb0, 0x0e, 0x81, 0x04, 0x28, 0xb0, 0xdb, 0xf9, 0x77,
		0x89, 0x00, 0x24, 0x0b, 0x81, 0x04, 0x7e, 0xb1, 0x5a, 0x4f, 0x7e, 0xa8, 0x24, 0xc1, 0x40, 0x51,
		0x46, 0x46, 0x06, 0x8f, 0xcd, 0x1e, 0x43, 0x21, 0x37, 0x76, 0x97, 0x30, 0x04, 0x72, 0x53, 0xe7,
		0xc8, 0x83, 0x1f, 0x9f, 0x25, 0xdd, 0x90, 0x35, 0xd5, 0x08, 0x8a, 0x7d, 0x9c, 0xdf, 0x17, 0x43,
		0xe8, 0xe3, 0x86, 0x67, 0x71, 0xfb, 0x8f, 0x7c, 0x9c, 0xbf, 0x59, 0x54, 0x81, 0x8f, 0xdf, 0xda,
		0x9d, 0xdb, 0xf3, 0xeb, 0xab, 0xdb, 0xe0, 0xb8, 0xc7, 0xf9, 0x9d, 0x09, 0x08, 0x7b, 0xdc, 0x32,
		0x41, 0xb4, 0xfa, 0x6a, 0xcc, 0x51, 0x8f, 0x9b, 0x27, 0x90, 0x8d, 0xd9, 0x05, 0x06, 0x3d, 0x7e,
		0x6e, 0x75, 0x5b, 0x9f, 0x5a, 0xb7, 0x6d, 0x72, 0x67, 0xc9, 0x9c, 0x22, 0x05, 0x0e, 0x13, 0x82,
		0x85, 0xc0, 0x6a, 0xc0, 0xec, 0xd9, 0x5f, 0x12, 0xbc, 0x50, 0xa2, 0x51, 0x2f, 0x88, 0xdd, 0x25,
		0xee, 0xfe, 0xa7, 0xb7, 0x9a, 0x67, 0x84, 0x19, 0x30, 0x9c, 0x29, 0x96, 0x5b, 0xc6, 0xec, 0x66,
		0xf2, 0xe5, 0x98, 0x34, 0xb3, 0x39, 0x9e, 0x00, 0x86, 0x0b, 0x49, 0x7d, 0xb4, 0x35, 0xab, 0x74,
		0xd8, 0xcc, 0x15, 0xd8, 0xcc, 0xac, 0x43, 0x57, 0xad, 0xc3, 0x62, 0xde, 0x68, 0x31, 0xc7, 0x11,
		0xf2, 0xe3, 0xb2, 0x22, 0x21, 0x6f, 0x57, 0x26, 0x76, 0xea, 0x13, 0xbf, 0x54, 0xa6, 0x4e, 0x61,
		0xd8, 0xca, 0x94, 0x17, 0xdc, 0x1a, 0xb1, 0x95, 0x83, 0xea, 0xca, 0x97, 0x37, 0x19, 0x05, 0x34,
		0xe3, 0xdc, 0xab, 0x5f, 0x67, 0xfa, 0x7c, 0x89, 0x50, 0xdf, 0xdb, 0x64, 0x02, 0x7e, 0x73, 0x1b,
		0x14, 0x96, 0xbf, 0xcd, 0x9a, 0x17, 0xe6, 0xcd, 0x27, 0xdf, 0xf8, 0x0f, 0x1a, 0x2a, 0x4a, 0xcb,
		0x3f, 0x60, 0x64, 0xf6, 0x68, 0xf6, 0x6f, 0xe8, 0x28, 0xa1, 0xd1, 0xef, 0xdf, 0x2f, 0x0a, 0x93,
		0x5f, 0x11, 0xd5, 0x40, 0x73, 0x5f, 0x59, 0x8b, 0x6b, 0xd8, 0x8d, 0xa9, 0xaf, 0xf8, 0xc6, 0x4f,
		0xec, 0xdb, 0xcc, 0xb7, 0xde, 0x2a, 0x32, 0x13, 0xff, 0xa2, 0x75, 0x45, 0x60, 0xde, 0x5b, 0x77,
		0x25, 0xc1, 0xb4, 0x57, 0xb6, 0x06, 0xb4, 0x24, 0xd5, 0xac, 0xf7, 0x9d, 0xb0, 0x1d, 0x99, 0xf4,
		0xd6, 0x54, 0x51, 0x56, 0xde, 0x5c, 0x90, 0xa4, 0xc1, 0xa8, 0x57, 0x88, 0x62, 0x9a, 0xd2, 0x66,
		0xd0, 0x6f, 0x5d, 0x22, 0x31, 0x1b, 0xf3, 0xe2, 0x60, 0x24, 0xab, 0x82, 0x61, 0x8a, 0xe6, 0xc4,
		0x60, 0x39, 0xa2, 0xd1, 0x43, 0x9d, 0x05, 0xb3, 0x5e, 0xa1, 0x0b, 0xa2, 0xcb, 0x88, 0x49, 0x4f,
		0xb4, 0x20, 0x93, 0x66, 0xce, 0x33, 0xac, 0x3d, 0x2e, 0x75, 0xa5, 0x93, 0x26, 0x63, 0xe6, 0x9a,
		0x49, 0x03, 0xed, 0x87, 0x9a, 0xd8, 0xf2, 0x46, 0xf6, 0xcb, 0x31, 0xa1, 0x0f, 0xd6, 0x90, 0x34,
		0xb9, 0x72, 0xd2, 0x8b, 0x10, 0x11, 0x48, 0x2d, 0x51, 0x91, 0x45, 0x16, 0x9e, 0x6b, 0x93, 0x81,
		0xd9, 0x82, 0xd9, 0xa6, 0x03, 0x3b, 0x8d, 0x71, 0x47, 0x0d, 0x24, 0xa3, 0xaf, 0xcb, 0x63, 0x62,
		0x9c, 0x64, 0xa9, 0x8b, 0x5e, 0x62, 0xec, 0x2e, 0xec, 0x2e, 0x78, 0x26, 0xe0, 0x99, 0x80, 0x67,
		0x02, 0xb1, 0x7c, 0x61, 0xe4, 0xd1, 0x53, 0x7f, 0x2c, 0x38, 0xb9, 0xfb, 0x0c, 0x8a, 0xde, 0x12,
		0x35, 0x24, 0x12, 0x24, 0x52, 0x8c, 0x12, 0x49, 0x1e, 0x17, 0xc4, 0xc1, 0x40, 0x97, 0x0c, 0x23,
		0x93, 0x47, 0xb8, 0xd2, 0xf7, 0x2d, 0x8c, 0xe4, 0x5d, 0xec, 0x9e, 0x34, 0x9d, 0xe1, 0x9a, 0xff,
		0xfd, 0xee, 0xfe, 0x7e, 0xfc, 0x72, 0x35, 0xb5, 0xfe, 0x5e, 0x4c, 0x7b, 0x1f, 0xf8, 0x8f, 0x19,
		0x3b, 0xb6, 0x35, 0xbd, 0xab, 0x20, 0x75, 0xe7, 0xb6, 0xfa, 0xac, 0xa5, 0x44, 0x9c, 0xcd, 0xfa,
		0x7b, 0x31, 0x8e, 0x65, 0x1d, 0xb5, 0x72, 0x42, 0xc8, 0xfe, 0xa9, 0x6a, 0x52, 0x7b, 0x95, 0x77,
		0xba, 0xda, 0xd4, 0x5e, 0xdd, 0x35, 0x74, 0x8d, 0xea, 0x79, 0x63, 0x54, 0xb5, 0xaa, 0xa3, 0x57,
		0xdb, 0x9e, 0x1b, 0xe1, 0x14, 0x37, 0x0f, 0x3d, 0x54, 0x37, 0xa8, 0x6e, 0xb1, 0xaa, 0x6e, 0x4c,
		0xa2, 0x2d, 0xe6, 0x6a, 0x4d, 0x6f, 0x50, 0x84, 0xed, 0x57, 0x74, 0x41, 0xb4, 0x24, 0x41, 0xb4,
		0x8c, 0xc4, 0x3e, 0xbd, 0x3c, 0xb1, 0x88, 0x20, 0x44, 0x20, 0x44, 0x62, 0x14, 0x22, 0x23, 0xb1,
		0x9f, 0x78, 0x19, 0xe2, 0xe5, 0xfd, 0xd5, 0x69, 0xbe, 0xb9, 0xfc, 0x9d, 0x7f, 0xa9, 0x4f, 0x93,
		0x59, 0x08, 0x74, 0x64, 0x4e, 0x18, 0x78, 0x80, 0x39, 0x01, 0x0f, 0x00, 0x0f, 0x88, 0x93, 0x07,
		0x4c, 0x64, 0xd5, 0xac, 0x34, 0x50, 0x61, 0x02, 0x3e, 0xa9, 0x28, 0x7c, 0x52, 0xff, 0x1f, 0x7b,
		0xd7, 0xde, 0x9b, 0x36, 0xb2, 0xc5, 0xff, 0xef, 0xa7, 0x18, 0x45, 0xba, 0x0a, 0x56, 0x31, 0xaf,
		0xb0, 0xed, 0x36, 0x52, 0x74, 0x95, 0x6d, 0x89, 0x6e, 0xa4, 0x90, 0x45, 0x6c, 0x17, 0xad, 0x2e,
		0x20, 0x6b, 0x00, 0x9b, 0x5a, 0x35, 0x63, 0x34, 0x36, 0x24, 0x6d, 0xc3, 0x77, 0x5f, 0xf9, 0x01,
		0x18, 0x30, 0x78, 0x66, 0x70, 0x1c, 0x0f, 0x9c, 0x7f, 0x5a, 0x9b, 0x78, 0x5e, 0x67, 0x66, 0xce,
		0x9c, 0xf3, 0x3b, 0x8f, 0xf9, 0x54, 0xab, 0x7e, 0x00, 0xa3, 0x54, 0x0e, 0x8e, 0x1f, 0xb1, 0xdb,
		0xd5, 0x4f, 0xe5, 0x6e, 0x75, 0x38, 0x80, 0xe4, 0x39, 0x80, 0x72, 0x9e, 0x71, 0xba, 0x63, 0x61,
		0xb2, 0x0a, 0x2a, 0xbb, 0x5a, 0xbc, 0x74, 0xab, 0xea, 0x55, 0x80, 0x1f, 0xfc, 0xf2, 0xde, 0xea,
		0xfd, 0x6e, 0xc5, 0x7b, 0xfd, 0x7d, 0x89, 0x29, 0x04, 0x3f, 0xf8, 0x26, 0x97, 0x7a, 0x5f, 0xc9,
		0xa7, 0x6c, 0xea, 0x2d, 0x14, 0x73, 0xc4, 0xcf, 0x1e, 0xc2, 0x72, 0xc0, 0x20, 0x80, 0x41, 0x80,
		0x84, 0x0a, 0x12, 0xaa, 0x94, 0x12, 0x6a, 0xbd, 0xf2, 0xa9, 0x0e, 0x12, 0xea, 0x6b, 0x1f, 0x42,
		0x69, 0xdc, 0xce, 0xcb, 0x20, 0x8c, 0xc2, 0x85, 0xbc, 0x89, 0x8d, 0xc7, 0x07, 0x04, 0x5b, 0x98,
		0x44, 0x1f, 0x3b, 0x0f, 0xb7, 0x8f, 0x65, 0xd6, 0xa0, 0x41, 0xb4, 0x2f, 0x4e, 0xd8, 0xc2, 0x44,
		0x5b, 0x3f, 0xf9, 0xd5, 0xad, 0xeb, 0x94, 0x20, 0x1c, 0x3c, 0x86, 0x28, 0xbc, 0x21, 0xe0, 0xbb,
		0x24, 0x60, 0x0e, 0xfb, 0x2e, 0xc6, 0x87, 0xf2, 0x6a, 0xf7, 0x8f, 0x5f, 0x1b, 0xed, 0xbb, 0xdb,
		0xcf, 0x0d, 0xb6, 0xa0, 0xde, 0xc8, 0xf7, 0x10, 0xde, 0x2b, 0x4d, 0x78, 0xef, 0x6a, 0xd2, 0xb4,
		0xfb, 0x56, 0xab, 0xdd, 0xb8, 0xbb, 0xff, 0x47, 0x24, 0xe2, 0x77, 0x5f, 0x2d, 0x10, 0x04, 0x0c,
		0x41, 0xc0, 0xe8, 0xc2, 0xc0, 0x13, 0xd3, 0x12, 0xb8, 0x96, 0x2c, 0x2c, 0x07, 0x5a, 0x1f, 0x68,
		0x7d, 0x19, 0x6a, 0x7d, 0xe6, 0x54, 0xe5, 0x5a, 0x78, 0x48, 0xba, 0xa8, 0xdf, 0xfb, 0xd6, 0xbc,
		0x2e, 0x1c, 0xf7, 0x7b, 0xdf, 0x9a, 0x7f, 0xc8, 0x6d, 0xdc, 0xaf, 0x3f, 0x32, 0x21, 0xf5, 0x28,
		0x18, 0xd7, 0x35, 0xaa, 0xbe, 0x6d, 0xe4, 0x2f, 0xe3, 0xea, 0xd6, 0x9f, 0x5d, 0x8a, 0xd5, 0x19,
		0x71, 0x5c, 0x3c, 0xb0, 0x38, 0xd7, 0xf9, 0x64, 0xe6, 0xb8, 0x59, 0x7a, 0xc4, 0x17, 0x86, 0x36,
		0x71, 0xb1, 0x49, 0x9c, 0x42, 0xa9, 0x54, 0x36, 0xa7, 0x6a, 0xc0, 0x98, 0x8a, 0xe8, 0xf2, 0xfa,
		0x52, 0x41, 0x98, 0x8c, 0xd0, 0x70, 0x46, 0xa9, 0x4e, 0xdc, 0x82, 0x72, 0x73, 0xe9, 0x4d, 0xc2,
		0xa5, 0x82, 0x6c, 0xda, 0x23, 0x3d, 0x77, 0x6f, 0xc1, 0x52, 0x6c, 0xc1, 0xfa, 0xa5, 0x72, 0x71,
		0x02, 0xf6, 0x93, 0xd5, 0x40, 0xf9, 0xcf, 0xcb, 0x75, 0x51, 0x38, 0x32, 0xe1, 0xc8, 0xcc, 0x12,
		0x28, 0x25, 0xec, 0x51, 0xcd, 0x48, 0x96, 0x48, 0x9e, 0x40, 0x21, 0x37, 0xa7, 0x75, 0x55, 0x68,
		0x5d, 0xa0, 0xb3, 0x8a, 0xe6, 0x29, 0x87, 0x8d, 0x29, 0x2f, 0x85, 0x6e, 0x55, 0xad, 0xf5, 0x97,
		0x2f, 0x57, 0xdd, 0x8a, 0x5a, 0xeb, 0x2b, 0xca, 0xe9, 0x84, 0xf6, 0x2c, 0x97, 0xc5, 0x07, 0x79,
		0x97, 0x85, 0x74, 0xbe, 0xd1, 0xd1, 0xd5, 0xe5, 0x1b, 0x40, 0x6b, 0x0b, 0xe5, 0xa5, 0xe0, 0xad,
		0xc9, 0xea, 0x6a, 0xa5, 0x55, 0x6b, 0xbe, 0x31, 0x54, 0x51, 0x94, 0x7c, 0x84, 0xfe, 0x94, 0x4b,
		0xef, 0x15, 0xe9, 0x22, 0x7f, 0xc0, 0x03, 0x04, 0xe4, 0x96, 0x33, 0x92, 0x5b, 0x2c, 0x1d, 0x1b,
		0x54, 0x37, 0x44, 0x24, 0x97, 0x8f, 0x7c, 0x2e, 0x20, 0x01, 0xdc, 0xef, 0x51, 0xe9, 0x3a, 0x02,
		0xf4, 0xfb, 0xef, 0xbe, 0x09, 0x64, 0xf5, 0xe4, 0xe3, 0xa6, 0xc1, 0xab, 0xbf, 0x23, 0xce, 0x58,
		0x6d, 0x5c, 0x6a, 0x77, 0xe8, 0x06, 0x95, 0x4a, 0xe5, 0x52, 0xa9, 0xbc, 0x05, 0x35, 0x7b, 0x94,
		0xea, 0x7a, 0x44, 0xba, 0x59, 0x7d, 0xda, 0x2f, 0x7b, 0xef, 0x22, 0x27, 0xc0, 0x45, 0x83, 0x52,
		0x9b, 0x36, 0x75, 0xc7, 0xc1, 0x63, 0x5d, 0xdc, 0xd8, 0xbb, 0xec, 0x7d, 0x73, 0xe6, 0xb8, 0x68,
		0x68, 0x93, 0x91, 0xe9, 0x9a, 0x36, 0x41, 0xc4, 0x76, 0x91, 0x83, 0x5d, 0xd3, 0x31, 0x4c, 0x7d,
		0x54, 0x44, 0x5f, 0xe9, 0x0f, 0x84, 0x47, 0x23, 0x93, 0x8c, 0x51, 0xc7, 0xc2, 0xa4, 0x37, 0xab,
		0x54, 0xae, 0x86, 0x81, 0x8f, 0x8b, 0xff, 0xac, 0x5f, 0xa3, 0x5f, 0x8b, 0x22, 0x6a, 0x3c, 0xe3,
		0xc9, 0xd4, 0xd2, 0xaf, 0xd1, 0xa5, 0xf7, 0x55, 0xb5, 0x52, 0xb9, 0xf4, 0x7e, 0x17, 0x3d, 0xde,
		0x04, 0x19, 0xcd, 0x3e, 0xa6, 0xa3, 0x7b, 0xf4, 0x52, 0x27, 0x21, 0xc1, 0x8a, 0xe2, 0x75, 0x1e,
		0xcb, 0x87, 0xf6, 0xf2, 0xa4, 0xd7, 0x9c, 0x03, 0xa1, 0x1e, 0x2e, 0xce, 0xd2, 0x21, 0xd4, 0x19,
		0xda, 0x53, 0x01, 0x79, 0x20, 0x28, 0x06, 0x02, 0x01, 0x08, 0x04, 0x19, 0x0a, 0x04, 0x3a, 0x99,
		0x4d, 0x74, 0x8a, 0x5d, 0x41, 0x38, 0x43, 0x0a, 0xf4, 0x7f, 0x6c, 0xd9, 0x03, 0x6c, 0x09, 0xe3,
		0xff, 0x96, 0x3d, 0xc4, 0x56, 0x6e, 0x0d, 0x00, 0xe1, 0xe0, 0xc4, 0x4c, 0x00, 0xc1, 0xd0, 0xde,
		0xdc, 0x06, 0x90, 0x9d, 0x93, 0x13, 0x62, 0x45, 0x8c, 0xc1, 0xdd, 0x89, 0xe1, 0x98, 0x63, 0xf4,
		0xec, 0x59, 0x4b, 0xb0, 0xe5, 0x23, 0x7c, 0x27, 0x10, 0x87, 0x2f, 0xd4, 0xba, 0x85, 0x83, 0x0d,
		0x8a, 0x3a, 0x4a, 0x15, 0x99, 0x5d, 0x4c, 0x8e, 0xf2, 0x2c, 0x01, 0x87, 0x12, 0x70, 0x28, 0x59,
		0x72, 0x79, 0x8a, 0x5d, 0x0d, 0xd3, 0x29, 0xbf, 0x54, 0xb9, 0x2a, 0x09, 0x82, 0x25, 0x08, 0x96,
		0x19, 0x0a, 0x96, 0x39, 0x8f, 0x35, 0xd2, 0x09, 0x1e, 0x58, 0xfa, 0xe8, 0x65, 0x64, 0x3a, 0xfe,
		0x43, 0x3e, 0xa3, 0x87, 0x2c, 0xdb, 0x9e, 0x0e, 0xf0, 0xf0, 0xbb, 0x16, 0x78, 0xc3, 0xf3, 0xef,
		0xfe, 0xed, 0x0a, 0x80, 0x09, 0x00, 0x13, 0xc8, 0x12, 0x6e, 0x16, 0x5a, 0x7e, 0xd9, 0x73, 0x83,
		0x11, 0xb5, 0xa7, 0x2f, 0x86, 0x4d, 0x9f, 0x30, 0xcd, 0x29, 0x27, 0x98, 0x4c, 0x2d, 0x81, 0xc4,
		0x69, 0x7e, 0x29, 0xd8, 0xf3, 0xb0, 0xe7, 0x01, 0x51, 0x4a, 0x15, 0x51, 0x0a, 0xa4, 0x07, 0xf1,
		0x9b, 0x64, 0x02, 0xa1, 0x23, 0xbf, 0x97, 0xc9, 0x84, 0xfd, 0x13, 0xbb, 0x4f, 0x26, 0x24, 0xce,
		0x69, 0xdc, 0x29, 0x03, 0xa6, 0x7d, 0xe0, 0xbb, 0x92, 0xc8, 0x5a, 0xa7, 0x62, 0xda, 0x4f, 0x69,
		0xdf, 0xba, 0xda, 0x4f, 0x9b, 0x08, 0xed, 0xdd, 0xb0, 0x24, 0xe3, 0x8c, 0x7d, 0xd1, 0x0d, 0x3c,
		0xb3, 0xf8, 0x3c, 0x05, 0x2e, 0x2a, 0x6c, 0xb4, 0xe8, 0x03, 0x0f, 0x01, 0x1e, 0x92, 0x21, 0x0f,
		0x99, 0x99, 0xc4, 0xfd, 0x5d, 0x80, 0x83, 0xfc, 0x76, 0xb2, 0xe9, 0x1f, 0x2a, 0x90, 0xfe, 0x41,
		0x94, 0x74, 0x57, 0x90, 0xfb, 0x21, 0x07, 0xc0, 0xc1, 0x94, 0xda, 0xcf, 0x3f, 0xc4, 0x4c, 0x07,
		0xeb, 0xa2, 0x70, 0x0c, 0xc1, 0x31, 0x94, 0xe1, 0x31, 0x04, 0xb6, 0x83, 0x14, 0x36, 0xfe, 0x9c,
		0x1a, 0x9a, 0x98, 0xf6, 0xba, 0x2a, 0x09, 0xdb, 0x1e, 0xb6, 0xfd, 0x29, 0x6b, 0xb0, 0xd4, 0x58,
		0x2a, 0xb0, 0xd4, 0xf0, 0xdf, 0x3a, 0xed, 0xbb, 0xe5, 0xff, 0xa1, 0xee, 0x4a, 0x8d, 0x74, 0x55,
		0x57, 0xc8, 0xd6, 0x14, 0xa9, 0x44, 0x76, 0xf7, 0xa5, 0xac, 0xbc, 0x96, 0x24, 0xce, 0xea, 0x94,
		0x98, 0x23, 0x49, 0x88, 0x40, 0x47, 0x67, 0x7a, 0x6a, 0x36, 0x9a, 0x7f, 0x34, 0xda, 0x8c, 0x69,
		0x9e, 0xc2, 0x8f, 0x21, 0xc7, 0x93, 0x34, 0x39, 0x9e, 0x82, 0x19, 0x13, 0xf1, 0xbe, 0x8b, 0x96,
		0x04, 0xd7, 0x3b, 0x70, 0xbd, 0x03, 0x0b, 0x10, 0xc8, 0xcf, 0x20, 0x3f, 0xef, 0x91, 0x9f, 0x73,
		0x6d, 0x01, 0x9a, 0xda, 0xd4, 0x15, 0xc0, 0xbc, 0xbc, 0x52, 0xb0, 0x6f, 0x61, 0xdf, 0x66, 0xb8,
		0x6f, 0x4f, 0x32, 0x99, 0x0c, 0x3f, 0x33, 0x3a, 0x86, 0x29, 0xed, 0x32, 0x27, 0x6f, 0x23, 0x87,
		0xcc, 0xc9, 0x7b, 0x0c, 0xde, 0x5b, 0x7f, 0xb6, 0xbf, 0xae, 0x9f, 0x02, 0xe6, 0xe4, 0xbf, 0xb2,
		0x33, 0x27, 0xce, 0x65, 0x71, 0x02, 0x94, 0xb4, 0xf0, 0x38, 0x42, 0xc8, 0xe1, 0x37, 0x4c, 0x88,
		0x6e, 0xf9, 0xbf, 0x7a, 0x44, 0xfc, 0xfc, 0xbf, 0xdb, 0xc7, 0xc7, 0xc6, 0xc3, 0xf6, 0x7b, 0x40,
		0x5b, 0xef, 0x47, 0x01, 0xd2, 0xe6, 0x12, 0x4f, 0x75, 0xf1, 0x78, 0x6c, 0x92, 0xb1, 0x36, 0xb1,
		0x47, 0x02, 0xf2, 0xe0, 0x46, 0x69, 0x38, 0x5f, 0xe0, 0x7c, 0xe1, 0x3e, 0x5f, 0x9a, 0x98, 0x8c,
		0xb0, 0x6b, 0xd3, 0x1f, 0xec, 0x6e, 0x79, 0x47, 0x9c, 0x49, 0xde, 0x48, 0x35, 0x81, 0x45, 0x8b,
		0xa4, 0xf3, 0xe5, 0xf4, 0x06, 0xa9, 0x8f, 0x84, 0x7d, 0x39, 0x67, 0x44, 0xbc, 0x82, 0x5a, 0xb0,
		0xac, 0x4d, 0x9b, 0x9a, 0xee, 0x0f, 0x2d, 0xac, 0x27, 0xaf, 0x4e, 0xa1, 0xdb, 0xfd, 0xbc, 0x46,
		0x35, 0x81, 0x21, 0xaf, 0x0a, 0x8b, 0x84, 0x2b, 0xaf, 0x68, 0x7d, 0x4e, 0x11, 0xcb, 0x0c, 0x1a,
		0x09, 0xa0, 0xfd, 0x29, 0xa2, 0xfd, 0x01, 0x02, 0x58, 0xe6, 0x44, 0x03, 0x79, 0x60, 0xec, 0xb0,
		0xd6, 0x9d, 0x16, 0x24, 0x45, 0xf8, 0x0f, 0xc2, 0xe3, 0xfc, 0x74, 0x61, 0xc6, 0xf6, 0xdf, 0x1d,
		0x18, 0x6e, 0xd2, 0x30, 0x99, 0x86, 0x17, 0x33, 0xa4, 0xe4, 0xa1, 0x6c, 0x76, 0x7f, 0xdd, 0xc9,
		0x48, 0x07, 0x2f, 0xd6, 0x4d, 0xa8, 0xce, 0x6c, 0xa0, 0x9a, 0xc4, 0xd5, 0xa9, 0x81, 0x63, 0xc4,
		0xa3, 0xad, 0x1c, 0x8c, 0x31, 0x25, 0xb6, 0x86, 0x1d, 0x8f, 0x49, 0xef, 0x15, 0x0d, 0x0f, 0x89,
		0x80, 0x1b, 0xa2, 0xc0, 0xc1, 0x56, 0x59, 0x04, 0x3c, 0x66, 0x41, 0x8e, 0x59, 0x60, 0xdb, 0x11,
		0xcc, 0xb6, 0xfa, 0xc8, 0xb9, 0x60, 0xf6, 0xe1, 0xc1, 0x81, 0x59, 0xe0, 0xaf, 0xbf, 0xff, 0xe0,
		0xbe, 0x1d, 0x64, 0xb3, 0x4c, 0x4e, 0xac, 0x47, 0x89, 0x13, 0xc9, 0x2b, 0xb1, 0xbf, 0x81, 0x2d,
		0x29, 0x69, 0xa2, 0xc5, 0x18, 0x23, 0x9b, 0x65, 0x69, 0x63, 0x52, 0x8f, 0xba, 0x41, 0xe4, 0x50,
		0x4d, 0x92, 0x58, 0x9e, 0x98, 0x17, 0x93, 0xa8, 0x1a, 0x98, 0x03, 0x3b, 0x14, 0xeb, 0x62, 0x4b,
		0x47, 0xf0, 0x63, 0xb6, 0x4a, 0x41, 0xd2, 0xf4, 0x23, 0x96, 0xe1, 0x09, 0xa2, 0x12, 0xbc, 0xcb,
		0x34, 0x6f, 0x18, 0xf8, 0x32, 0xc9, 0x34, 0x7f, 0x8e, 0x69, 0x48, 0xad, 0xce, 0x06, 0xe6, 0x42,
		0x6a, 0xf5, 0xfc, 0x41, 0xfb, 0x90, 0x5a, 0x1d, 0x52, 0xab, 0x43, 0x6a, 0xf5, 0x43, 0x74, 0x04,
		0xef, 0x1b, 0x90, 0x6e, 0xe4, 0x97, 0x6e, 0x32, 0xf6, 0xcc, 0x89, 0x24, 0x0f, 0xdf, 0xd4, 0x32,
		0x7d, 0xa3, 0x6c, 0x2e, 0xfd, 0xd9, 0x21, 0x31, 0x67, 0x06, 0x58, 0xf7, 0xe6, 0x36, 0xda, 0xff,
		0x87, 0xdd, 0x95, 0x53, 0x3e, 0x12, 0xb2, 0x38, 0x84, 0x9d, 0xfe, 0x35, 0x1b, 0xdc, 0x2f, 0x9b,
		0xd6, 0xe2, 0x7f, 0x8d, 0x69, 0x3d, 0xb1, 0x43, 0xaf, 0x95, 0xdc, 0x73, 0x77, 0x47, 0x1d, 0x05,
		0xfc, 0x00, 0xde, 0x03, 0x78, 0x0f, 0xc3, 0x34, 0xe0, 0xd1, 0xc4, 0x24, 0x9a, 0xe3, 0x62, 0x77,
		0x26, 0x90, 0x07, 0x6c, 0xa3, 0x34, 0xc8, 0x45, 0x20, 0x17, 0xe5, 0x44, 0x2e, 0x12, 0x58, 0x97,
		0x48, 0x3a, 0x07, 0x93, 0xd9, 0x54, 0x3c, 0x51, 0x98, 0xfd, 0x44, 0xf2, 0x9b, 0x25, 0xcc, 0xeb,
		0x9c, 0x58, 0x8a, 0xb0, 0xd9, 0xf4, 0x44, 0xd2, 0x83, 0x41, 0x82, 0x56, 0x60, 0xce, 0x27, 0xab,
		0xb4, 0x42, 0xf2, 0x56, 0x00, 0xb1, 0x80, 0x1f, 0x00, 0x3f, 0x90, 0x23, 0x2b, 0x4b, 0xa1, 0xd7,
		0x7b, 0x7a, 0xaf, 0xf4, 0x7a, 0xa5, 0xc2, 0xda, 0xd4, 0xf4, 0xab, 0x52, 0xac, 0x2d, 0x5e, 0xba,
		0x55, 0xf5, 0x2a, 0x7c, 0xbf, 0x5a, 0xbc, 0x74, 0xeb, 0xfd, 0x6e, 0xa5, 0xef, 0xe3, 0xfb, 0xa1,
		0x91, 0x20, 0xf8, 0xc1, 0x2f, 0x52, 0xef, 0x2b, 0xa9, 0xb3, 0x90, 0x53, 0xbc, 0xaa, 0x30, 0x58,
		0x0b, 0xaa, 0xa5, 0x93, 0xb1, 0xfb, 0x6d, 0x7d, 0x71, 0xa1, 0x82, 0x82, 0x5b, 0xe5, 0x6e, 0x50,
		0xf5, 0xb7, 0xe0, 0xc6, 0xfa, 0x42, 0xc1, 0x99, 0x0d, 0xc2, 0xaf, 0x07, 0xba, 0x61, 0x53, 0x7d,
		0xfd, 0x75, 0x78, 0xb1, 0xfd, 0x0d, 0x12, 0x08, 0xd6, 0x51, 0x90, 0x4d, 0x51, 0xc1, 0x71, 0x31,
		0x75, 0x1d, 0xf5, 0xc9, 0x74, 0xbf, 0x25, 0xb6, 0x53, 0x44, 0x97, 0x0d, 0xf7, 0xdb, 0xf2, 0x22,
		0x7d, 0x9b, 0x0c, 0xb1, 0x5b, 0xf0, 0x7e, 0xd1, 0x29, 0xd1, 0xdd, 0xcb, 0x22, 0x5a, 0x97, 0xc7,
		0x86, 0xab, 0x53, 0xe6, 0xfa, 0x8e, 0x1b, 0x00, 0x03, 0x71, 0x52, 0x88, 0xbf, 0x11, 0xa2, 0x56,
		0xcb, 0xde, 0x22, 0x56, 0xcb, 0xa6, 0xee, 0xe7, 0xa0, 0x79, 0x31, 0x7a, 0x79, 0x35, 0xa6, 0x36,
		0xa4, 0xdc, 0xdf, 0x79, 0x39, 0xb5, 0x74, 0xec, 0xe8, 0xc8, 0xb0, 0x2d, 0xcb, 0x7e, 0x42, 0xde,
		0x09, 0xe0, 0xd1, 0x0c, 0xad, 0x4e, 0x00, 0x44, 0xf0, 0xc4, 0x24, 0x63, 0xaf, 0x82, 0xb9, 0x4e,
		0x38, 0x45, 0xac, 0x34, 0xce, 0xc8, 0x7d, 0xe7, 0xa5, 0xec, 0x17, 0x5d, 0x0a, 0x10, 0x1e, 0x6e,
		0xb7, 0x64, 0x16, 0x66, 0x21, 0xaf, 0x18, 0x08, 0xb5, 0x60, 0x99, 0x85, 0x9c, 0x63, 0xbb, 0x9f,
		0x82, 0x65, 0x36, 0xa9, 0xf1, 0x8c, 0x2c, 0xb3, 0x79, 0x31, 0xc8, 0x4a, 0x14, 0xd5, 0x24, 0x3e,
		0x01, 0x02, 0x81, 0x4f, 0x42, 0x04, 0x7e, 0xe3, 0xb8, 0x28, 0x46, 0x02, 0x71, 0xc4, 0x4c, 0x25,
		0x53, 0x81, 0x23, 0x96, 0x8a, 0x1a, 0x89, 0xc1, 0x53, 0xd4, 0xc8, 0x24, 0x5a, 0x8a, 0x1a, 0x39,
		0x0c, 0x8f, 0xa2, 0x46, 0x7a, 0xf1, 0x50, 0xed, 0x3b, 0x86, 0x00, 0xa8, 0xf6, 0x5d, 0x2e, 0x22,
		0x9e, 0xa8, 0x21, 0x61, 0x88, 0x53, 0xdc, 0x64, 0x89, 0xb1, 0xc5, 0xe4, 0x98, 0xa6, 0x50, 0xe8,
		0xe0, 0x70, 0x61, 0x59, 0x96, 0x90, 0xc1, 0x67, 0x85, 0x1a, 0x27, 0xe8, 0xa4, 0x72, 0x68, 0x79,
		0xa4, 0x23, 0xf3, 0x31, 0x7b, 0xa5, 0x18, 0xd8, 0xb2, 0x06, 0x78, 0xf8, 0x9d, 0x5f, 0x17, 0x5c,
		0x95, 0x7c, 0xcd, 0x5b, 0x56, 0xfc, 0xac, 0xff, 0x67, 0x74, 0xd3, 0x0a, 0x35, 0xce, 0x50, 0x09,
		0x65, 0xd9, 0x0e, 0x79, 0xd3, 0x3a, 0x07, 0xb6, 0x6d, 0xe9, 0x58, 0xc8, 0xa4, 0x5a, 0x05, 0xbb,
		0x25, 0x6c, 0x27, 0xd8, 0x4e, 0x32, 0x59, 0x26, 0x3b, 0xd4, 0xe8, 0x62, 0xf5, 0xe7, 0xad, 0xfa,
		0xff, 0x8a, 0xfa, 0x49, 0x53, 0xfb, 0xef, 0xdf, 0xc0, 0x4b, 0x01, 0x30, 0xa0, 0x7c, 0x63, 0x40,
		0xd4, 0x88, 0x3c, 0x75, 0xda, 0x77, 0x65, 0x46, 0x39, 0x7b, 0xaf, 0x82, 0x4d, 0x0d, 0x6d, 0xf5,
		0xe0, 0xd5, 0xb5, 0xaa, 0x4f, 0x02, 0x3c, 0x66, 0x9b, 0x18, 0xbc, 0x10, 0xcb, 0xd6, 0xd8, 0xdf,
		0x12, 0x39, 0x89, 0x0e, 0x85, 0x15, 0x1b, 0x89, 0x74, 0x9f, 0x03, 0x01, 0x79, 0xb6, 0x30, 0x49,
		0xc4, 0x40, 0x9e, 0x77, 0xd3, 0xda, 0xbc, 0x0a, 0x0a, 0xe2, 0xc4, 0xb5, 0x94, 0x03, 0x20, 0x24,
		0xec, 0x57, 0x6a, 0x58, 0xc8, 0x3f, 0x0f, 0xb7, 0x8f, 0x5a, 0xa3, 0xd3, 0x7a, 0xd4, 0x1e, 0x3b,
		0x7f, 0x32, 0xc0, 0x22, 0x9b, 0xdf, 0xe7, 0x00, 0x21, 0xd9, 0x3b, 0x51, 0x39, 0x07, 0x49, 0xf6,
		0x4d, 0xe4, 0x6b, 0xe1, 0x24, 0x1b, 0x13, 0xc7, 0x0b, 0x99, 0xc4, 0x14, 0x96, 0x00, 0x3d, 0x49,
		0x5c, 0x1a, 0x92, 0x02, 0x28, 0x49, 0x4b, 0x27, 0x63, 0x0c, 0xe5, 0xbc, 0x95, 0x2c, 0xe6, 0x45,
		0x76, 0x62, 0x7a, 0x16, 0xeb, 0x22, 0x3c, 0x21, 0x55, 0x2b, 0x43, 0xe0, 0xc2, 0xf1, 0xd7, 0x88,
		0x36, 0x77, 0x75, 0x81, 0x6b, 0x2f, 0xa3, 0x85, 0x61, 0x87, 0xc1, 0x0e, 0x13, 0xda, 0x61, 0xd9,
		0x66, 0x6b, 0xce, 0xda, 0x8b, 0x25, 0xa0, 0xed, 0x75, 0x44, 0xa9, 0x58, 0xfe, 0x14, 0xc8, 0x3a,
		0x5f, 0xff, 0xf6, 0x1d, 0x38, 0x63, 0x7e, 0x0b, 0x5c, 0x5c, 0xc2, 0x3f, 0x80, 0x97, 0x4b, 0x32,
		0xc2, 0x21, 0x27, 0x9c, 0xf1, 0x1c, 0xc9, 0xa4, 0xea, 0x3f, 0x6f, 0xca, 0xc0, 0x65, 0x7e, 0x91,
		0x78, 0xaf, 0xb6, 0xfc, 0xbc, 0x4e, 0xbf, 0xea, 0x3f, 0x6e, 0x55, 0x1d, 0xd7, 0x92, 0x04, 0x10,
		0x48, 0x02, 0x01, 0x79, 0x11, 0x91, 0xc3, 0x44, 0x3a, 0xea, 0x3a, 0xbd, 0xc8, 0xe6, 0x66, 0x55,
		0x80, 0xc3, 0xaf, 0x41, 0xfd, 0x95, 0x4b, 0xfd, 0x8d, 0x70, 0x70, 0x5e, 0xe5, 0x37, 0x5a, 0x14,
		0x54, 0x5f, 0x50, 0x7d, 0x41, 0xf5, 0x05, 0xc1, 0xfc, 0x8c, 0x54, 0x5f, 0x8e, 0x32, 0x0f, 0x7e,
		0x48, 0x5d, 0x16, 0xc1, 0x7c, 0x4d, 0x93, 0x88, 0x87, 0x40, 0x75, 0xb0, 0x35, 0xd3, 0xc5, 0xb2,
		0x3f, 0xf8, 0xe5, 0xef, 0x68, 0x10, 0x55, 0xfe, 0xc5, 0x1c, 0x9b, 0xac, 0xa2, 0x71, 0xfc, 0xec,
		0xe8, 0x63, 0xec, 0x9a, 0x73, 0xaf, 0x2f, 0xbe, 0xbb, 0x0f, 0x7f, 0x4c, 0x8e, 0x40, 0x18, 0x59,
		0x13, 0x3f, 0xa7, 0x40, 0xba, 0x8a, 0xfc, 0xb4, 0x3b, 0x81, 0x78, 0x26, 0x87, 0x0e, 0x35, 0x53,
		0x04, 0x26, 0x0a, 0xca, 0xc1, 0x41, 0x04, 0x07, 0x51, 0xc6, 0x07, 0x91, 0x39, 0x9d, 0xd7, 0x55,
		0x3c, 0x1a, 0x51, 0xdd, 0x71, 0xf2, 0x1b, 0x8e, 0x9f, 0x61, 0xc2, 0xe8, 0xc2, 0x7f, 0xba, 0xbd,
		0xde, 0xf4, 0xd7, 0xe3, 0xc2, 0xfb, 0xf7, 0x61, 0xd1, 0x7f, 0xaf, 0xfc, 0x17, 0x5c, 0x6c, 0x00,
		0x80, 0x8a, 0xc1, 0x4f, 0x42, 0x60, 0x92, 0x57, 0x29, 0xe5, 0xc4, 0x55, 0xc2, 0x8a, 0x77, 0x5b,
		0x91, 0x17, 0x78, 0x3a, 0x08, 0xd9, 0x08, 0x91, 0x27, 0x2d, 0xd0, 0x49, 0x6b, 0xde, 0xb6, 0xf8,
		0x80, 0x27, 0xbf, 0x04, 0x80, 0x4f, 0x52, 0x82, 0x4f, 0xcd, 0xdb, 0xd6, 0x31, 0x00, 0xd4, 0xaa,
		0x38, 0x80, 0x50, 0x00, 0x42, 0x05, 0x1f, 0x4e, 0xf0, 0x54, 0x0c, 0x87, 0x5a, 0x16, 0x04, 0x0d,
		0x00, 0x34, 0x00, 0x79, 0xa0, 0x28, 0x08, 0x1f, 0x81, 0x3d, 0x05, 0x7b, 0x2a, 0x66, 0xbe, 0xc0,
		0x87, 0x82, 0x2d, 0xfd, 0x4f, 0x9c, 0x9b, 0x79, 0x22, 0x71, 0x39, 0xae, 0x8b, 0x87, 0x4d, 0x0d,
		0x9b, 0x7a, 0x07, 0x91, 0xc8, 0xd2, 0x99, 0x2a, 0xef, 0xd1, 0x64, 0x16, 0x26, 0xe1, 0xcd, 0x55,
		0xd5, 0xe2, 0xd5, 0x9b, 0x67, 0xb7, 0x4c, 0x87, 0xa9, 0x10, 0x53, 0x80, 0xa7, 0x10, 0x13, 0x58,
		0x0a, 0xb0, 0x14, 0x19, 0x58, 0xca, 0x9c, 0x98, 0x23, 0xcd, 0xf5, 0x8a, 0xf3, 0x73, 0x15, 0x1e,
		0xe1, 0xa2, 0x8d, 0xc9, 0x58, 0x07, 0xdb, 0x31, 0xf3, 0xf4, 0xc8, 0x6b, 0x3b, 0xfe, 0xf0, 0xf1,
		0xe3, 0xc7, 0x1a, 0x4b, 0xb0, 0x6b, 0xde, 0x29, 0x98, 0x77, 0x0b, 0x72, 0x6a, 0x17, 0x9c, 0xb1,
		0xc1, 0x45, 0x10, 0x40, 0x9d, 0xd8, 0xb8, 0x80, 0xdd, 0x42, 0x6b, 0xde, 0xb6, 0xca, 0x22, 0x40,
		0x30, 0x12, 0x32, 0xfc, 0x78, 0x95, 0xc7, 0xb7, 0x26, 0xbb, 0x01, 0xe8, 0x80, 0xe9, 0x44, 0x98,
		0x54, 0x6f, 0x19, 0x9e, 0xbd, 0x3d, 0x58, 0xd6, 0x10, 0xed, 0xad, 0x31, 0xed, 0x0d, 0xd3, 0x7e,
		0x17, 0xe9, 0xea, 0xbe, 0x2e, 0x5e, 0x98, 0xce, 0x1d, 0xfe, 0xae, 0xb7, 0x6d, 0x7b, 0x57, 0xaa,
		0xda, 0xee, 0xf6, 0x45, 0xf4, 0x4f, 0x1b, 0xfd, 0xfa, 0xa2, 0xcf, 0xcd, 0x65, 0xc6, 0xbc, 0xc5,
		0xbb, 0xc5, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x89, 0xfb, 0x61,
		0x9a, 0xaf, 0x8e, 0x0c, 0x00,
	}
)


// ΛEnumTypes is a map, keyed by a YANG schema path, of the enumerated types that
// correspond with the leaf. The type is represented as a reflect.Type. The naming
// of the map ensures that there are no clashes with valid YANG identifiers.
func initΛEnumTypes(){
  ΛEnumTypes = map[string][]reflect.Type{
	"/sonic-auto_techsupport/AUTO_TECHSUPPORT/GLOBAL/state": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_AdminMode)(0)),
	},
	"/sonic-auto_techsupport/AUTO_TECHSUPPORT_FEATURE/AUTO_TECHSUPPORT_FEATURE_LIST/state": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_AdminMode)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/ACL/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/BUFFER_POOL_WATERMARK/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/DEBUG_COUNTER/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/FLOW_CNT_ROUTE/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/FLOW_CNT_TRAP/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/PFCWD/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/PG_DROP/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/PG_WATERMARK/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/PORT/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/PORT_BUFFER_DROP/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/PORT_RATES/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/QUEUE/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/QUEUE_WATERMARK/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/RIF/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/RIF_RATES/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-flex_counter/FLEX_COUNTER_TABLE/TUNNEL/FLEX_COUNTER_STATUS": []reflect.Type{
		reflect.TypeOf((E_SonicFlexCounter_FlexStatus)(0)),
	},
	"/sonic-hash/SWITCH_HASH/GLOBAL/ecmp_hash": []reflect.Type{
		reflect.TypeOf((E_SonicHash_HashField)(0)),
	},
	"/sonic-hash/SWITCH_HASH/GLOBAL/lag_hash": []reflect.Type{
		reflect.TypeOf((E_SonicHash_HashField)(0)),
	},
	"/sonic-interface/INTERFACE/INTERFACE_IPPREFIX_LIST/family": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_IpFamily)(0)),
	},
	"/sonic-interface/INTERFACE/INTERFACE_IPPREFIX_LIST/scope": []reflect.Type{
		reflect.TypeOf((E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_IPPREFIX_LIST_Scope)(0)),
	},
	"/sonic-interface/INTERFACE/INTERFACE_LIST/mpls": []reflect.Type{
		reflect.TypeOf((E_SonicInterface_SonicInterface_INTERFACE_INTERFACE_LIST_Mpls)(0)),
	},
	"/sonic-lldp/LLDP/GLOBAL/mode": []reflect.Type{
		reflect.TypeOf((E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode)(0)),
	},
	"/sonic-lldp/LLDP_PORT/LLDP_PORT_LIST/mode": []reflect.Type{
		reflect.TypeOf((E_SonicLldp_SonicLldp_LLDP_GLOBAL_Mode)(0)),
	},
	"/sonic-loopback-interface/LOOPBACK_INTERFACE/LOOPBACK_INTERFACE_IPPREFIX_LIST/family": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_IpFamily)(0)),
	},
	"/sonic-loopback-interface/LOOPBACK_INTERFACE/LOOPBACK_INTERFACE_IPPREFIX_LIST/scope": []reflect.Type{
		reflect.TypeOf((E_SonicLoopbackInterface_SonicLoopbackInterface_LOOPBACK_INTERFACE_LOOPBACK_INTERFACE_IPPREFIX_LIST_Scope)(0)),
	},
	"/sonic-mclag/MCLAG_UNIQUE_IP/MCLAG_UNIQUE_IP_LIST/unique_ip": []reflect.Type{
		reflect.TypeOf((E_SonicMclag_SonicMclag_MCLAG_UNIQUE_IP_MCLAG_UNIQUE_IP_LIST_UniqueIp)(0)),
	},
	"/sonic-mgmt_port/MGMT_PORT/MGMT_PORT_LIST/admin_status": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_AdminStatus)(0)),
	},
	"/sonic-mux-cable/MUX_CABLE/MUX_CABLE_LIST/cable_type": []reflect.Type{
		reflect.TypeOf((E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_CableType)(0)),
	},
	"/sonic-mux-cable/MUX_CABLE/MUX_CABLE_LIST/state": []reflect.Type{
		reflect.TypeOf((E_SonicMuxCable_SonicMuxCable_MUX_CABLE_MUX_CABLE_LIST_State)(0)),
	},
	"/sonic-nat/NAT_BINDINGS/NAT_BINDINGS_LIST/nat_type": []reflect.Type{
		reflect.TypeOf((E_SonicNat_NatType)(0)),
	},
	"/sonic-nat/NAT_GLOBAL/Values/admin_mode": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_AdminMode)(0)),
	},
	"/sonic-nat/STATIC_NAPT/STATIC_NAPT_LIST/ip_protocol": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_IpProtocolType)(0)),
	},
	"/sonic-nat/STATIC_NAPT/STATIC_NAPT_LIST/nat_type": []reflect.Type{
		reflect.TypeOf((E_SonicNat_NatType)(0)),
	},
	"/sonic-nat/STATIC_NAT/STATIC_NAT_LIST/nat_type": []reflect.Type{
		reflect.TypeOf((E_SonicNat_NatType)(0)),
	},
	"/sonic-passwh/PASSW_HARDENING/POLICIES/state": []reflect.Type{
		reflect.TypeOf((E_SonicPasswh_FeatureState)(0)),
	},
	"/sonic-pbh/PBH_HASH_FIELD/PBH_HASH_FIELD_LIST/hash_field": []reflect.Type{
		reflect.TypeOf((E_SonicPbh_HashField)(0)),
	},
	"/sonic-pbh/PBH_RULE/PBH_RULE_LIST/flow_counter": []reflect.Type{
		reflect.TypeOf((E_SonicPbh_FlowCounter)(0)),
	},
	"/sonic-pbh/PBH_RULE/PBH_RULE_LIST/packet_action": []reflect.Type{
		reflect.TypeOf((E_SonicPbh_PacketAction)(0)),
	},
	"/sonic-port/PORT/PORT_LIST/admin_status": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_AdminStatus)(0)),
	},
	"/sonic-port/PORT/PORT_LIST/adv_interface_types": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_InterfaceType)(0)),
	},
	"/sonic-port/PORT/PORT_LIST/interface_type": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_InterfaceType)(0)),
	},
	"/sonic-portchannel/PORTCHANNEL/PORTCHANNEL_LIST/admin_status": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_AdminStatus)(0)),
	},
	"/sonic-portchannel/PORTCHANNEL_INTERFACE/PORTCHANNEL_INTERFACE_LIST/mpls": []reflect.Type{
		reflect.TypeOf((E_SonicPortchannel_SonicPortchannel_PORTCHANNEL_INTERFACE_PORTCHANNEL_INTERFACE_LIST_Mpls)(0)),
	},
	"/sonic-route-map/ROUTE_MAP/ROUTE_MAP_LIST/route_operation": []reflect.Type{
		reflect.TypeOf((E_SonicRoutingPolicySets_RoutingPolicyActionType)(0)),
	},
	"/sonic-route-map/ROUTE_MAP/ROUTE_MAP_LIST/set_metric_action": []reflect.Type{
		reflect.TypeOf((E_SonicRouteMap_MetricActionType)(0)),
	},
	"/sonic-routing-policy-sets/AS_PATH_SET/AS_PATH_SET_LIST/action": []reflect.Type{
		reflect.TypeOf((E_SonicRoutingPolicySets_RoutingPolicyActionType)(0)),
	},
	"/sonic-routing-policy-sets/COMMUNITY_SET/COMMUNITY_SET_LIST/action": []reflect.Type{
		reflect.TypeOf((E_SonicRoutingPolicySets_RoutingPolicyActionType)(0)),
	},
	"/sonic-routing-policy-sets/COMMUNITY_SET/COMMUNITY_SET_LIST/match_action": []reflect.Type{
		reflect.TypeOf((E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_MatchAction)(0)),
	},
	"/sonic-routing-policy-sets/COMMUNITY_SET/COMMUNITY_SET_LIST/set_type": []reflect.Type{
		reflect.TypeOf((E_SonicRoutingPolicySets_SonicRoutingPolicySets_COMMUNITY_SET_COMMUNITY_SET_LIST_SetType)(0)),
	},
	"/sonic-routing-policy-sets/EXTENDED_COMMUNITY_SET/EXTENDED_COMMUNITY_SET_LIST/action": []reflect.Type{
		reflect.TypeOf((E_SonicRoutingPolicySets_RoutingPolicyActionType)(0)),
	},
	"/sonic-routing-policy-sets/EXTENDED_COMMUNITY_SET/EXTENDED_COMMUNITY_SET_LIST/match_action": []reflect.Type{
		reflect.TypeOf((E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_MatchAction)(0)),
	},
	"/sonic-routing-policy-sets/EXTENDED_COMMUNITY_SET/EXTENDED_COMMUNITY_SET_LIST/set_type": []reflect.Type{
		reflect.TypeOf((E_SonicRoutingPolicySets_SonicRoutingPolicySets_EXTENDED_COMMUNITY_SET_EXTENDED_COMMUNITY_SET_LIST_SetType)(0)),
	},
	"/sonic-routing-policy-sets/PREFIX/PREFIX_LIST/action": []reflect.Type{
		reflect.TypeOf((E_SonicRoutingPolicySets_RoutingPolicyActionType)(0)),
	},
	"/sonic-routing-policy-sets/PREFIX_SET/PREFIX_SET_LIST/mode": []reflect.Type{
		reflect.TypeOf((E_SonicRoutingPolicySets_SonicRoutingPolicySets_PREFIX_SET_PREFIX_SET_LIST_Mode)(0)),
	},
	"/sonic-scheduler/SCHEDULER/SCHEDULER_LIST/meter_type": []reflect.Type{
		reflect.TypeOf((E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_MeterType)(0)),
	},
	"/sonic-scheduler/SCHEDULER/SCHEDULER_LIST/type": []reflect.Type{
		reflect.TypeOf((E_SonicScheduler_SonicScheduler_SCHEDULER_SCHEDULER_LIST_Type)(0)),
	},
	"/sonic-sflow/SFLOW/global/admin_state": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_AdminStatus)(0)),
	},
	"/sonic-sflow/SFLOW_SESSION/SFLOW_SESSION_LIST/admin_state": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_AdminStatus)(0)),
	},
	"/sonic-snmp/SNMP_COMMUNITY/SNMP_COMMUNITY_LIST/TYPE": []reflect.Type{
		reflect.TypeOf((E_SonicSnmp_SonicSnmp_SNMP_COMMUNITY_SNMP_COMMUNITY_LIST_TYPE)(0)),
	},
	"/sonic-storm-control/PORT_STORM_CONTROL/PORT_STORM_CONTROL_LIST/storm_type": []reflect.Type{
		reflect.TypeOf((E_SonicStormControl_SonicStormControl_PORT_STORM_CONTROL_PORT_STORM_CONTROL_LIST_StormType)(0)),
	},
	"/sonic-vlan-sub-interface/VLAN_SUB_INTERFACE/VLAN_SUB_INTERFACE_LIST/admin_status": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_AdminStatus)(0)),
	},
	"/sonic-vlan/VLAN/VLAN_LIST/admin_status": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_AdminStatus)(0)),
	},
	"/sonic-vlan/VLAN_INTERFACE/VLAN_INTERFACE_IPPREFIX_LIST/family": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_IpFamily)(0)),
	},
	"/sonic-vlan/VLAN_INTERFACE/VLAN_INTERFACE_IPPREFIX_LIST/scope": []reflect.Type{
		reflect.TypeOf((E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_IPPREFIX_LIST_Scope)(0)),
	},
	"/sonic-vlan/VLAN_INTERFACE/VLAN_INTERFACE_LIST/mpls": []reflect.Type{
		reflect.TypeOf((E_SonicVlan_SonicVlan_VLAN_INTERFACE_VLAN_INTERFACE_LIST_Mpls)(0)),
	},
	"/sonic-vlan/VLAN_MEMBER/VLAN_MEMBER_LIST/tagging_mode": []reflect.Type{
		reflect.TypeOf((E_SonicTypes_VlanTaggingMode)(0)),
	},
  }
}

